{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"Serializer.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/cache/serializer/Serializer.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AccountCache,\n    IdTokenCache,\n    AccessTokenCache,\n    RefreshTokenCache,\n    AppMetadataCache,\n} from \"@azure/msal-common/node\";\nimport {\n    InMemoryCache,\n    JsonCache,\n    SerializedAccountEntity,\n    SerializedIdTokenEntity,\n    SerializedAccessTokenEntity,\n    SerializedRefreshTokenEntity,\n    SerializedAppMetadataEntity,\n} from \"./SerializerTypes.js\";\n\n/**\n * This class serializes cache entities to be saved into in-memory object types defined internally\n * @internal\n */\nexport class Serializer {\n    /**\n     * serialize the JSON blob\n     * @param data - JSON blob cache\n     */\n    static serializeJSONBlob(data: JsonCache): string {\n        return JSON.stringify(data);\n    }\n\n    /**\n     * Serialize Accounts\n     * @param accCache - cache of accounts\n     */\n    static serializeAccounts(\n        accCache: AccountCache\n    ): Record<string, SerializedAccountEntity> {\n        const accounts: Record<string, SerializedAccountEntity> = {};\n        Object.keys(accCache).map(function (key) {\n            const accountEntity = accCache[key];\n            accounts[key] = {\n                home_account_id: accountEntity.homeAccountId,\n                environment: accountEntity.environment,\n                realm: accountEntity.realm,\n                local_account_id: accountEntity.localAccountId,\n                username: accountEntity.username,\n                authority_type: accountEntity.authorityType,\n                name: accountEntity.name,\n                client_info: accountEntity.clientInfo,\n                last_modification_time: accountEntity.lastModificationTime,\n                last_modification_app: accountEntity.lastModificationApp,\n                tenantProfiles: accountEntity.tenantProfiles?.map(\n                    (tenantProfile) => {\n                        return JSON.stringify(tenantProfile);\n                    }\n                ),\n            };\n        });\n\n        return accounts;\n    }\n\n    /**\n     * Serialize IdTokens\n     * @param idTCache - cache of ID tokens\n     */\n    static serializeIdTokens(\n        idTCache: IdTokenCache\n    ): Record<string, SerializedIdTokenEntity> {\n        const idTokens: Record<string, SerializedIdTokenEntity> = {};\n        Object.keys(idTCache).map(function (key) {\n            const idTEntity = idTCache[key];\n            idTokens[key] = {\n                home_account_id: idTEntity.homeAccountId,\n                environment: idTEntity.environment,\n                credential_type: idTEntity.credentialType,\n                client_id: idTEntity.clientId,\n                secret: idTEntity.secret,\n                realm: idTEntity.realm,\n            };\n        });\n\n        return idTokens;\n    }\n\n    /**\n     * Serializes AccessTokens\n     * @param atCache - cache of access tokens\n     */\n    static serializeAccessTokens(\n        atCache: AccessTokenCache\n    ): Record<string, SerializedAccessTokenEntity> {\n        const accessTokens: Record<string, SerializedAccessTokenEntity> = {};\n        Object.keys(atCache).map(function (key) {\n            const atEntity = atCache[key];\n            accessTokens[key] = {\n                home_account_id: atEntity.homeAccountId,\n                environment: atEntity.environment,\n                credential_type: atEntity.credentialType,\n                client_id: atEntity.clientId,\n                secret: atEntity.secret,\n                realm: atEntity.realm,\n                target: atEntity.target,\n                cached_at: atEntity.cachedAt,\n                expires_on: atEntity.expiresOn,\n                extended_expires_on: atEntity.extendedExpiresOn,\n                refresh_on: atEntity.refreshOn,\n                key_id: atEntity.keyId,\n                token_type: atEntity.tokenType,\n                requestedClaims: atEntity.requestedClaims,\n                requestedClaimsHash: atEntity.requestedClaimsHash,\n                userAssertionHash: atEntity.userAssertionHash,\n            };\n        });\n\n        return accessTokens;\n    }\n\n    /**\n     * Serialize refreshTokens\n     * @param rtCache - cache of refresh tokens\n     */\n    static serializeRefreshTokens(\n        rtCache: RefreshTokenCache\n    ): Record<string, SerializedRefreshTokenEntity> {\n        const refreshTokens: Record<string, SerializedRefreshTokenEntity> = {};\n        Object.keys(rtCache).map(function (key) {\n            const rtEntity = rtCache[key];\n            refreshTokens[key] = {\n                home_account_id: rtEntity.homeAccountId,\n                environment: rtEntity.environment,\n                credential_type: rtEntity.credentialType,\n                client_id: rtEntity.clientId,\n                secret: rtEntity.secret,\n                family_id: rtEntity.familyId,\n                target: rtEntity.target,\n                realm: rtEntity.realm,\n            };\n        });\n\n        return refreshTokens;\n    }\n\n    /**\n     * Serialize amdtCache\n     * @param amdtCache - cache of app metadata\n     */\n    static serializeAppMetadata(\n        amdtCache: AppMetadataCache\n    ): Record<string, SerializedAppMetadataEntity> {\n        const appMetadata: Record<string, SerializedAppMetadataEntity> = {};\n        Object.keys(amdtCache).map(function (key) {\n            const amdtEntity = amdtCache[key];\n            appMetadata[key] = {\n                client_id: amdtEntity.clientId,\n                environment: amdtEntity.environment,\n                family_id: amdtEntity.familyId,\n            };\n        });\n\n        return appMetadata;\n    }\n\n    /**\n     * Serialize the cache\n     * @param inMemCache - itemised cache read from the JSON\n     */\n    static serializeAllCache(inMemCache: InMemoryCache): JsonCache {\n        return {\n            Account: this.serializeAccounts(inMemCache.accounts),\n            IdToken: this.serializeIdTokens(inMemCache.idTokens),\n            AccessToken: this.serializeAccessTokens(inMemCache.accessTokens),\n            RefreshToken: this.serializeRefreshTokens(inMemCache.refreshTokens),\n            AppMetadata: this.serializeAppMetadata(inMemCache.appMetadata),\n        };\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 151, "column": 0}, "map": {"version":3,"file":"Deserializer.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/cache/serializer/Deserializer.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AccountCache,\n    IdTokenCache,\n    AccessTokenCache,\n    RefreshTokenCache,\n    AppMetadataCache,\n    AccountEntity,\n    IdTokenEntity,\n    AccessTokenEntity,\n    RefreshTokenEntity,\n    CacheManager,\n    CredentialType,\n    AuthenticationScheme,\n} from \"@azure/msal-common/node\";\nimport {\n    JsonCache,\n    InMemoryCache,\n    SerializedAccountEntity,\n    SerializedIdTokenEntity,\n    SerializedAccessTokenEntity,\n    SerializedRefreshTokenEntity,\n    SerializedAppMetadataEntity,\n} from \"./SerializerTypes.js\";\n\n/**\n * This class deserializes cache entities read from the file into in-memory object types defined internally\n * @internal\n */\nexport class Deserializer {\n    /**\n     * Parse the JSON blob in memory and deserialize the content\n     * @param cachedJson - JSON blob cache\n     */\n    static deserializeJSONBlob(jsonFile: string): JsonCache {\n        const deserializedCache = !jsonFile ? {} : JSON.parse(jsonFile);\n        return deserializedCache;\n    }\n\n    /**\n     * Deserializes accounts to AccountEntity objects\n     * @param accounts - accounts of type SerializedAccountEntity\n     */\n    static deserializeAccounts(\n        accounts: Record<string, SerializedAccountEntity>\n    ): AccountCache {\n        const accountObjects: AccountCache = {};\n        if (accounts) {\n            Object.keys(accounts).map(function (key) {\n                const serializedAcc = accounts[key];\n                const mappedAcc = {\n                    homeAccountId: serializedAcc.home_account_id,\n                    environment: serializedAcc.environment,\n                    realm: serializedAcc.realm,\n                    localAccountId: serializedAcc.local_account_id,\n                    username: serializedAcc.username,\n                    authorityType: serializedAcc.authority_type,\n                    name: serializedAcc.name,\n                    clientInfo: serializedAcc.client_info,\n                    lastModificationTime: serializedAcc.last_modification_time,\n                    lastModificationApp: serializedAcc.last_modification_app,\n                    tenantProfiles: serializedAcc.tenantProfiles?.map(\n                        (serializedTenantProfile) => {\n                            return JSON.parse(serializedTenantProfile);\n                        }\n                    ),\n                };\n                const account: AccountEntity = new AccountEntity();\n                CacheManager.toObject(account, mappedAcc);\n                accountObjects[key] = account;\n            });\n        }\n\n        return accountObjects;\n    }\n\n    /**\n     * Deserializes id tokens to IdTokenEntity objects\n     * @param idTokens - credentials of type SerializedIdTokenEntity\n     */\n    static deserializeIdTokens(\n        idTokens: Record<string, SerializedIdTokenEntity>\n    ): IdTokenCache {\n        const idObjects: IdTokenCache = {};\n        if (idTokens) {\n            Object.keys(idTokens).map(function (key) {\n                const serializedIdT = idTokens[key];\n                const idToken: IdTokenEntity = {\n                    homeAccountId: serializedIdT.home_account_id,\n                    environment: serializedIdT.environment,\n                    credentialType:\n                        serializedIdT.credential_type as CredentialType,\n                    clientId: serializedIdT.client_id,\n                    secret: serializedIdT.secret,\n                    realm: serializedIdT.realm,\n                };\n                idObjects[key] = idToken;\n            });\n        }\n        return idObjects;\n    }\n\n    /**\n     * Deserializes access tokens to AccessTokenEntity objects\n     * @param accessTokens - access tokens of type SerializedAccessTokenEntity\n     */\n    static deserializeAccessTokens(\n        accessTokens: Record<string, SerializedAccessTokenEntity>\n    ): AccessTokenCache {\n        const atObjects: AccessTokenCache = {};\n        if (accessTokens) {\n            Object.keys(accessTokens).map(function (key) {\n                const serializedAT = accessTokens[key];\n                const accessToken: AccessTokenEntity = {\n                    homeAccountId: serializedAT.home_account_id,\n                    environment: serializedAT.environment,\n                    credentialType:\n                        serializedAT.credential_type as CredentialType,\n                    clientId: serializedAT.client_id,\n                    secret: serializedAT.secret,\n                    realm: serializedAT.realm,\n                    target: serializedAT.target,\n                    cachedAt: serializedAT.cached_at,\n                    expiresOn: serializedAT.expires_on,\n                    extendedExpiresOn: serializedAT.extended_expires_on,\n                    refreshOn: serializedAT.refresh_on,\n                    keyId: serializedAT.key_id,\n                    tokenType: serializedAT.token_type as AuthenticationScheme,\n                    requestedClaims: serializedAT.requestedClaims,\n                    requestedClaimsHash: serializedAT.requestedClaimsHash,\n                    userAssertionHash: serializedAT.userAssertionHash,\n                };\n                atObjects[key] = accessToken;\n            });\n        }\n\n        return atObjects;\n    }\n\n    /**\n     * Deserializes refresh tokens to RefreshTokenEntity objects\n     * @param refreshTokens - refresh tokens of type SerializedRefreshTokenEntity\n     */\n    static deserializeRefreshTokens(\n        refreshTokens: Record<string, SerializedRefreshTokenEntity>\n    ): RefreshTokenCache {\n        const rtObjects: RefreshTokenCache = {};\n        if (refreshTokens) {\n            Object.keys(refreshTokens).map(function (key) {\n                const serializedRT = refreshTokens[key];\n                const refreshToken: RefreshTokenEntity = {\n                    homeAccountId: serializedRT.home_account_id,\n                    environment: serializedRT.environment,\n                    credentialType:\n                        serializedRT.credential_type as CredentialType,\n                    clientId: serializedRT.client_id,\n                    secret: serializedRT.secret,\n                    familyId: serializedRT.family_id,\n                    target: serializedRT.target,\n                    realm: serializedRT.realm,\n                };\n                rtObjects[key] = refreshToken;\n            });\n        }\n\n        return rtObjects;\n    }\n\n    /**\n     * Deserializes appMetadata to AppMetaData objects\n     * @param appMetadata - app metadata of type SerializedAppMetadataEntity\n     */\n    static deserializeAppMetadata(\n        appMetadata: Record<string, SerializedAppMetadataEntity>\n    ): AppMetadataCache {\n        const appMetadataObjects: AppMetadataCache = {};\n        if (appMetadata) {\n            Object.keys(appMetadata).map(function (key) {\n                const serializedAmdt = appMetadata[key];\n                appMetadataObjects[key] = {\n                    clientId: serializedAmdt.client_id,\n                    environment: serializedAmdt.environment,\n                    familyId: serializedAmdt.family_id,\n                };\n            });\n        }\n\n        return appMetadataObjects;\n    }\n\n    /**\n     * Deserialize an inMemory Cache\n     * @param jsonCache - JSON blob cache\n     */\n    static deserializeAllCache(jsonCache: JsonCache): InMemoryCache {\n        return {\n            accounts: jsonCache.Account\n                ? this.deserializeAccounts(jsonCache.Account)\n                : {},\n            idTokens: jsonCache.IdToken\n                ? this.deserializeIdTokens(jsonCache.IdToken)\n                : {},\n            accessTokens: jsonCache.AccessToken\n                ? this.deserializeAccessTokens(jsonCache.AccessToken)\n                : {},\n            refreshTokens: jsonCache.RefreshToken\n                ? this.deserializeRefreshTokens(jsonCache.RefreshToken)\n                : {},\n            appMetadata: jsonCache.AppMetadata\n                ? this.deserializeAppMetadata(jsonCache.AppMetadata)\n                : {},\n        };\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 315, "column": 0}, "map": {"version":3,"file":"internals.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/internals.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Warning: This set of exports is purely intended to be used by other MSAL libraries, and should be considered potentially unstable. We strongly discourage using them directly, you do so at your own risk.\n * Breaking changes to these APIs will be shipped under a minor version, instead of a major version.\n */\n\nexport { Serializer } from \"./cache/serializer/Serializer.js\";\nexport { Deserializer } from \"./cache/serializer/Deserializer.js\";\n"],"names":[],"mappings":";;gUAAA;;;CAGG,IAEH;;;CAGG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 343, "column": 0}, "map": {"version":3,"file":"Constants.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/utils/Constants.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { HttpStatus } from \"@azure/msal-common/node\";\nimport { DefaultManagedIdentityRetryPolicy } from \"../retry/DefaultManagedIdentityRetryPolicy.js\";\nimport { ImdsRetryPolicy } from \"../retry/ImdsRetryPolicy.js\";\n\n// MSI Constants. Docs for MSI are available here https://docs.microsoft.com/azure/app-service/overview-managed-identity\nexport const DEFAULT_MANAGED_IDENTITY_ID = \"system_assigned_managed_identity\";\nexport const MANAGED_IDENTITY_DEFAULT_TENANT = \"managed_identity\";\nexport const DEFAULT_AUTHORITY_FOR_MANAGED_IDENTITY = `https://login.microsoftonline.com/${MANAGED_IDENTITY_DEFAULT_TENANT}/`;\n\n/**\n * Managed Identity Headers - used in network requests\n */\nexport const ManagedIdentityHeaders = {\n    AUTHORIZATION_HEADER_NAME: \"Authorization\",\n    METADATA_HEADER_NAME: \"Metadata\",\n    APP_SERVICE_SECRET_HEADER_NAME: \"X-IDENTITY-HEADER\",\n    ML_AND_SF_SECRET_HEADER_NAME: \"secret\",\n} as const;\nexport type ManagedIdentityHeaders =\n    (typeof ManagedIdentityHeaders)[keyof typeof ManagedIdentityHeaders];\n\n/**\n * Managed Identity Query Parameters - used in network requests\n */\nexport const ManagedIdentityQueryParameters = {\n    API_VERSION: \"api-version\",\n    RESOURCE: \"resource\",\n    SHA256_TOKEN_TO_REFRESH: \"token_sha256_to_refresh\",\n    XMS_CC: \"xms_cc\",\n} as const;\nexport type ManagedIdentityQueryParameters =\n    (typeof ManagedIdentityQueryParameters)[keyof typeof ManagedIdentityQueryParameters];\n\n/**\n * Managed Identity Environment Variable Names\n */\nexport const ManagedIdentityEnvironmentVariableNames = {\n    AZURE_POD_IDENTITY_AUTHORITY_HOST: \"AZURE_POD_IDENTITY_AUTHORITY_HOST\",\n    DEFAULT_IDENTITY_CLIENT_ID: \"DEFAULT_IDENTITY_CLIENT_ID\",\n    IDENTITY_ENDPOINT: \"IDENTITY_ENDPOINT\",\n    IDENTITY_HEADER: \"IDENTITY_HEADER\",\n    IDENTITY_SERVER_THUMBPRINT: \"IDENTITY_SERVER_THUMBPRINT\",\n    IMDS_ENDPOINT: \"IMDS_ENDPOINT\",\n    MSI_ENDPOINT: \"MSI_ENDPOINT\",\n    MSI_SECRET: \"MSI_SECRET\",\n} as const;\nexport type ManagedIdentityEnvironmentVariableNames =\n    (typeof ManagedIdentityEnvironmentVariableNames)[keyof typeof ManagedIdentityEnvironmentVariableNames];\n\n/**\n * Managed Identity Source Names\n * @public\n */\nexport const ManagedIdentitySourceNames = {\n    APP_SERVICE: \"AppService\",\n    AZURE_ARC: \"AzureArc\",\n    CLOUD_SHELL: \"CloudShell\",\n    DEFAULT_TO_IMDS: \"DefaultToImds\",\n    IMDS: \"Imds\",\n    MACHINE_LEARNING: \"MachineLearning\",\n    SERVICE_FABRIC: \"ServiceFabric\",\n} as const;\n/**\n * The ManagedIdentitySourceNames type\n * @public\n */\nexport type ManagedIdentitySourceNames =\n    (typeof ManagedIdentitySourceNames)[keyof typeof ManagedIdentitySourceNames];\n\n/**\n * Managed Identity Ids\n */\nexport const ManagedIdentityIdType = {\n    SYSTEM_ASSIGNED: \"system-assigned\",\n    USER_ASSIGNED_CLIENT_ID: \"user-assigned-client-id\",\n    USER_ASSIGNED_RESOURCE_ID: \"user-assigned-resource-id\",\n    USER_ASSIGNED_OBJECT_ID: \"user-assigned-object-id\",\n} as const;\nexport type ManagedIdentityIdType =\n    (typeof ManagedIdentityIdType)[keyof typeof ManagedIdentityIdType];\n\n/**\n * http methods\n */\nexport const HttpMethod = {\n    GET: \"get\",\n    POST: \"post\",\n} as const;\nexport type HttpMethod = (typeof HttpMethod)[keyof typeof HttpMethod];\n\nexport const ProxyStatus = {\n    SUCCESS: HttpStatus.SUCCESS,\n    SUCCESS_RANGE_START: HttpStatus.SUCCESS_RANGE_START,\n    SUCCESS_RANGE_END: HttpStatus.SUCCESS_RANGE_END,\n    SERVER_ERROR: HttpStatus.SERVER_ERROR,\n} as const;\nexport type ProxyStatus = (typeof ProxyStatus)[keyof typeof ProxyStatus];\n\n/**\n * Constants used for region discovery\n */\nexport const REGION_ENVIRONMENT_VARIABLE = \"REGION_NAME\";\nexport const MSAL_FORCE_REGION = \"MSAL_FORCE_REGION\";\n\n/**\n * Constant used for PKCE\n */\nexport const RANDOM_OCTET_SIZE = 32;\n\n/**\n * Constants used in PKCE\n */\nexport const Hash = {\n    SHA256: \"sha256\",\n};\n\n/**\n * Constants for encoding schemes\n */\nexport const CharSet = {\n    CV_CHARSET:\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~\",\n};\n\n/**\n * Cache Constants\n */\nexport const CACHE = {\n    FILE_CACHE: \"fileCache\",\n    EXTENSION_LIB: \"extenstion_library\",\n};\n\n/**\n * Constants\n */\nexport const Constants = {\n    MSAL_SKU: \"msal.js.node\",\n    JWT_BEARER_ASSERTION_TYPE:\n        \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\",\n    AUTHORIZATION_PENDING: \"authorization_pending\",\n    HTTP_PROTOCOL: \"http://\",\n    LOCALHOST: \"localhost\",\n};\n\n/**\n * API Codes for Telemetry purposes.\n * Before adding a new code you must claim it in the MSAL Telemetry tracker as these number spaces are shared across all MSALs\n * 0-99 Silent Flow\n * 600-699 Device Code Flow\n * 800-899 Auth Code Flow\n */\nexport const ApiId = {\n    acquireTokenSilent: 62,\n    acquireTokenByUsernamePassword: 371,\n    acquireTokenByDeviceCode: 671,\n    acquireTokenByClientCredential: 771,\n    acquireTokenByCode: 871,\n    acquireTokenByRefreshToken: 872,\n};\nexport type ApiId = (typeof ApiId)[keyof typeof ApiId];\n\n/**\n * JWT  constants\n */\nexport const JwtConstants = {\n    ALGORITHM: \"alg\",\n    RSA_256: \"RS256\",\n    PSS_256: \"PS256\",\n    X5T_256: \"x5t#S256\",\n    X5T: \"x5t\",\n    X5C: \"x5c\",\n    AUDIENCE: \"aud\",\n    EXPIRATION_TIME: \"exp\",\n    ISSUER: \"iss\",\n    SUBJECT: \"sub\",\n    NOT_BEFORE: \"nbf\",\n    JWT_ID: \"jti\",\n};\n\nexport const LOOPBACK_SERVER_CONSTANTS = {\n    INTERVAL_MS: 100,\n    TIMEOUT_MS: 5000,\n};\n\nexport const AZURE_ARC_SECRET_FILE_MAX_SIZE_BYTES: number = 4096; // 4 KB\n\nexport type RetryPolicies = DefaultManagedIdentityRetryPolicy | ImdsRetryPolicy;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 504, "column": 0}, "map": {"version":3,"file":"NetworkUtils.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/utils/NetworkUtils.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { NetworkResponse } from \"@azure/msal-common/node\";\n\nexport type UrlToHttpRequestOptions = {\n    protocol: string;\n    hostname: string;\n    hash: string;\n    search: string;\n    pathname: string;\n    path: string;\n    href: string;\n    port?: number;\n    auth?: string;\n};\n\nexport class NetworkUtils {\n    static getNetworkResponse<T>(\n        headers: Record<string, string>,\n        body: T,\n        statusCode: number\n    ): NetworkResponse<T> {\n        return {\n            headers: headers,\n            body: body,\n            status: statusCode,\n        };\n    }\n\n    /*\n     * Utility function that converts a URL object into an ordinary options object as expected by the\n     * http.request and https.request APIs.\n     * https://github.com/nodejs/node/blob/main/lib/internal/url.js#L1090\n     */\n    static urlToHttpOptions(url: URL): UrlToHttpRequestOptions {\n        const options: UrlToHttpRequestOptions = {\n            protocol: url.protocol,\n            hostname:\n                url.hostname && url.hostname.startsWith(\"[\")\n                    ? url.hostname.slice(1, -1)\n                    : url.hostname,\n            hash: url.hash,\n            search: url.search,\n            pathname: url.pathname,\n            path: `${url.pathname || \"\"}${url.search || \"\"}`,\n            href: url.href,\n        };\n        if (url.port !== \"\") {\n            options.port = Number(url.port);\n        }\n        if (url.username || url.password) {\n            options.auth = `${decodeURIComponent(\n                url.username\n            )}:${decodeURIComponent(url.password)}`;\n        }\n        return options;\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;;;CAGG,SAgBU,YAAY,CAAA;IACrB,OAAO,kBAAkB,CACrB,OAA+B,EAC/B,IAAO,EACP,UAAkB,EAAA;QAElB,OAAO;YACH,OAAO,EAAE,OAAO;YAChB,IAAI,EAAE,IAAI;YACV,MAAM,EAAE,UAAU;SACrB,CAAC;KACL;IAED;;;;KAIG,GACH,OAAO,gBAAgB,CAAC,GAAQ,EAAA;QAC5B,MAAM,OAAO,GAA4B;YACrC,QAAQ,EAAE,GAAG,CAAC,QAAQ;YACtB,QAAQ,EACJ,GAAG,CAAC,QAAQ,IAAI,GAAG,CAAC,QAAQ,CAAC,UAAU,CAAC,GAAG,CAAC,GACtC,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,CAAA,CAAE,CAAC,GACzB,GAAG,CAAC,QAAQ;YACtB,IAAI,EAAE,GAAG,CAAC,IAAI;YACd,MAAM,EAAE,GAAG,CAAC,MAAM;YAClB,QAAQ,EAAE,GAAG,CAAC,QAAQ;YACtB,IAAI,EAAE,CAAA,EAAG,GAAG,CAAC,QAAQ,IAAI,EAAE,CAAA,EAAG,GAAG,CAAC,MAAM,IAAI,EAAE,CAAE,CAAA;YAChD,IAAI,EAAE,GAAG,CAAC,IAAI;SACjB,CAAC;QACF,IAAI,GAAG,CAAC,IAAI,KAAK,EAAE,EAAE;YACjB,OAAO,CAAC,IAAI,GAAG,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACnC,CAAA;QACD,IAAI,GAAG,CAAC,QAAQ,IAAI,GAAG,CAAC,QAAQ,EAAE;YAC9B,OAAO,CAAC,IAAI,GAAG,GAAG,kBAAkB,CAChC,GAAG,CAAC,QAAQ,CACf,CAAA,CAAA,EAAI,kBAAkB,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC;QAC3C,CAAA;QACD,OAAO,OAAO,CAAC;KAClB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 550, "column": 0}, "map": {"version":3,"file":"HttpClient.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/network/HttpClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    INetworkModule,\n    NetworkRequestOptions,\n    NetworkResponse,\n    HttpStatus,\n} from \"@azure/msal-common/node\";\nimport { HttpMethod, Constants, ProxyStatus } from \"../utils/Constants.js\";\nimport { NetworkUtils } from \"../utils/NetworkUtils.js\";\nimport http from \"http\";\nimport https from \"https\";\n\n/**\n * This class implements the API for network requests.\n */\nexport class HttpClient implements INetworkModule {\n    private proxyUrl: string;\n    private customAgentOptions: http.AgentOptions | https.AgentOptions;\n\n    constructor(\n        proxyUrl?: string,\n        customAgentOptions?: http.AgentOptions | https.AgentOptions\n    ) {\n        this.proxyUrl = proxyUrl || \"\";\n        this.customAgentOptions = customAgentOptions || {};\n    }\n\n    /**\n     * Http Get request\n     * @param url\n     * @param options\n     */\n    async sendGetRequestAsync<T>(\n        url: string,\n        options?: NetworkRequestOptions,\n        timeout?: number\n    ): Promise<NetworkResponse<T>> {\n        if (this.proxyUrl) {\n            return networkRequestViaProxy(\n                url,\n                this.proxyUrl,\n                HttpMethod.GET,\n                options,\n                this.customAgentOptions as http.AgentOptions,\n                timeout\n            );\n        } else {\n            return networkRequestViaHttps(\n                url,\n                HttpMethod.GET,\n                options,\n                this.customAgentOptions as https.AgentOptions,\n                timeout\n            );\n        }\n    }\n\n    /**\n     * Http Post request\n     * @param url\n     * @param options\n     */\n    async sendPostRequestAsync<T>(\n        url: string,\n        options?: NetworkRequestOptions\n    ): Promise<NetworkResponse<T>> {\n        if (this.proxyUrl) {\n            return networkRequestViaProxy(\n                url,\n                this.proxyUrl,\n                HttpMethod.POST,\n                options,\n                this.customAgentOptions as http.AgentOptions\n            );\n        } else {\n            return networkRequestViaHttps(\n                url,\n                HttpMethod.POST,\n                options,\n                this.customAgentOptions as https.AgentOptions\n            );\n        }\n    }\n}\n\nconst networkRequestViaProxy = <T>(\n    destinationUrlString: string,\n    proxyUrlString: string,\n    httpMethod: string,\n    options?: NetworkRequestOptions,\n    agentOptions?: http.AgentOptions,\n    timeout?: number\n): Promise<NetworkResponse<T>> => {\n    const destinationUrl = new URL(destinationUrlString);\n    const proxyUrl = new URL(proxyUrlString);\n\n    // \"method: connect\" must be used to establish a connection to the proxy\n    const headers = options?.headers || ({} as Record<string, string>);\n    const tunnelRequestOptions: https.RequestOptions = {\n        host: proxyUrl.hostname,\n        port: proxyUrl.port,\n        method: \"CONNECT\",\n        path: destinationUrl.hostname,\n        headers: headers,\n    };\n\n    if (agentOptions && Object.keys(agentOptions).length) {\n        tunnelRequestOptions.agent = new http.Agent(agentOptions);\n    }\n\n    // compose a request string for the socket\n    let postRequestStringContent: string = \"\";\n    if (httpMethod === HttpMethod.POST) {\n        const body = options?.body || \"\";\n        postRequestStringContent =\n            \"Content-Type: application/x-www-form-urlencoded\\r\\n\" +\n            `Content-Length: ${body.length}\\r\\n` +\n            `\\r\\n${body}`;\n    } else {\n        // optional timeout is only for get requests (regionDiscovery, for example)\n        if (timeout) {\n            tunnelRequestOptions.timeout = timeout;\n        }\n    }\n    const outgoingRequestString =\n        `${httpMethod.toUpperCase()} ${destinationUrl.href} HTTP/1.1\\r\\n` +\n        `Host: ${destinationUrl.host}\\r\\n` +\n        \"Connection: close\\r\\n\" +\n        postRequestStringContent +\n        \"\\r\\n\";\n\n    return new Promise<NetworkResponse<T>>((resolve, reject) => {\n        const request = http.request(tunnelRequestOptions);\n\n        if (timeout) {\n            request.on(\"timeout\", () => {\n                request.destroy();\n                reject(new Error(\"Request time out\"));\n            });\n        }\n\n        request.end();\n\n        // establish connection to the proxy\n        request.on(\"connect\", (response, socket) => {\n            const proxyStatusCode =\n                response?.statusCode || ProxyStatus.SERVER_ERROR;\n            if (\n                proxyStatusCode < ProxyStatus.SUCCESS_RANGE_START ||\n                proxyStatusCode > ProxyStatus.SUCCESS_RANGE_END\n            ) {\n                request.destroy();\n                socket.destroy();\n                reject(\n                    new Error(\n                        `Error connecting to proxy. Http status code: ${\n                            response.statusCode\n                        }. Http status message: ${\n                            response?.statusMessage || \"Unknown\"\n                        }`\n                    )\n                );\n            }\n\n            // make a request over an HTTP tunnel\n            socket.write(outgoingRequestString);\n\n            const data: Buffer[] = [];\n            socket.on(\"data\", (chunk) => {\n                data.push(chunk);\n            });\n\n            socket.on(\"end\", () => {\n                // combine all received buffer streams into one buffer, and then into a string\n                const dataString = Buffer.concat([...data]).toString();\n\n                // separate each line into it's own entry in an arry\n                const dataStringArray = dataString.split(\"\\r\\n\");\n                // the first entry will contain the statusCode and statusMessage\n                const httpStatusCode = parseInt(\n                    dataStringArray[0].split(\" \")[1]\n                );\n                // remove \"HTTP/1.1\" and the status code to get the status message\n                const statusMessage = dataStringArray[0]\n                    .split(\" \")\n                    .slice(2)\n                    .join(\" \");\n                // the last entry will contain the body\n                const body = dataStringArray[dataStringArray.length - 1];\n\n                // everything in between the first and last entries are the headers\n                const headersArray = dataStringArray.slice(\n                    1,\n                    dataStringArray.length - 2\n                );\n\n                // build an object out of all the headers\n                const entries = new Map();\n                headersArray.forEach((header) => {\n                    /**\n                     * the header might look like \"Content-Length: 1531\", but that is just a string\n                     * it needs to be converted to a key/value pair\n                     * split the string at the first instance of \":\"\n                     * there may be more than one \":\" if the value of the header is supposed to be a JSON object\n                     */\n                    const headerKeyValue = header.split(new RegExp(/:\\s(.*)/s));\n                    const headerKey = headerKeyValue[0];\n                    let headerValue = headerKeyValue[1];\n\n                    // check if the value of the header is supposed to be a JSON object\n                    try {\n                        const object = JSON.parse(headerValue);\n\n                        // if it is, then convert it from a string to a JSON object\n                        if (object && typeof object === \"object\") {\n                            headerValue = object;\n                        }\n                    } catch (e) {\n                        // otherwise, leave it as a string\n                    }\n\n                    entries.set(headerKey, headerValue);\n                });\n                const headers = Object.fromEntries(entries);\n\n                const parsedHeaders = headers as Record<string, string>;\n                const networkResponse = NetworkUtils.getNetworkResponse(\n                    parsedHeaders,\n                    parseBody(\n                        httpStatusCode,\n                        statusMessage,\n                        parsedHeaders,\n                        body\n                    ) as T,\n                    httpStatusCode\n                );\n\n                if (\n                    (httpStatusCode < HttpStatus.SUCCESS_RANGE_START ||\n                        httpStatusCode > HttpStatus.SUCCESS_RANGE_END) &&\n                    // do not destroy the request for the device code flow\n                    networkResponse.body[\"error\"] !==\n                        Constants.AUTHORIZATION_PENDING\n                ) {\n                    request.destroy();\n                }\n                resolve(networkResponse);\n            });\n\n            socket.on(\"error\", (chunk) => {\n                request.destroy();\n                socket.destroy();\n                reject(new Error(chunk.toString()));\n            });\n        });\n\n        request.on(\"error\", (chunk) => {\n            request.destroy();\n            reject(new Error(chunk.toString()));\n        });\n    });\n};\n\nconst networkRequestViaHttps = <T>(\n    urlString: string,\n    httpMethod: string,\n    options?: NetworkRequestOptions,\n    agentOptions?: https.AgentOptions,\n    timeout?: number\n): Promise<NetworkResponse<T>> => {\n    const isPostRequest = httpMethod === HttpMethod.POST;\n    const body: string = options?.body || \"\";\n\n    const url = new URL(urlString);\n    const headers = options?.headers || ({} as Record<string, string>);\n    const customOptions: https.RequestOptions = {\n        method: httpMethod,\n        headers: headers,\n        ...NetworkUtils.urlToHttpOptions(url),\n    };\n\n    if (agentOptions && Object.keys(agentOptions).length) {\n        customOptions.agent = new https.Agent(agentOptions);\n    }\n\n    if (isPostRequest) {\n        // needed for post request to work\n        customOptions.headers = {\n            ...customOptions.headers,\n            \"Content-Length\": body.length,\n        };\n    } else {\n        // optional timeout is only for get requests (regionDiscovery, for example)\n        if (timeout) {\n            customOptions.timeout = timeout;\n        }\n    }\n\n    return new Promise<NetworkResponse<T>>((resolve, reject) => {\n        let request: http.ClientRequest;\n        // managed identity sources use http instead of https\n        if (customOptions.protocol === \"http:\") {\n            request = http.request(customOptions);\n        } else {\n            request = https.request(customOptions);\n        }\n\n        if (isPostRequest) {\n            request.write(body);\n        }\n\n        if (timeout) {\n            request.on(\"timeout\", () => {\n                request.destroy();\n                reject(new Error(\"Request time out\"));\n            });\n        }\n\n        request.end();\n\n        request.on(\"response\", (response) => {\n            const headers = response.headers;\n            const statusCode = response.statusCode as number;\n            const statusMessage = response.statusMessage;\n\n            const data: Buffer[] = [];\n            response.on(\"data\", (chunk) => {\n                data.push(chunk);\n            });\n\n            response.on(\"end\", () => {\n                // combine all received buffer streams into one buffer, and then into a string\n                const body = Buffer.concat([...data]).toString();\n\n                const parsedHeaders = headers as Record<string, string>;\n                const networkResponse = NetworkUtils.getNetworkResponse(\n                    parsedHeaders,\n                    parseBody(\n                        statusCode,\n                        statusMessage,\n                        parsedHeaders,\n                        body\n                    ) as T,\n                    statusCode\n                );\n\n                if (\n                    (statusCode < HttpStatus.SUCCESS_RANGE_START ||\n                        statusCode > HttpStatus.SUCCESS_RANGE_END) &&\n                    // do not destroy the request for the device code flow\n                    networkResponse.body[\"error\"] !==\n                        Constants.AUTHORIZATION_PENDING\n                ) {\n                    request.destroy();\n                }\n                resolve(networkResponse);\n            });\n        });\n\n        request.on(\"error\", (chunk) => {\n            request.destroy();\n            reject(new Error(chunk.toString()));\n        });\n    });\n};\n\n/**\n * Check if extra parsing is needed on the repsonse from the server\n * @param statusCode {number} the status code of the response from the server\n * @param statusMessage {string | undefined} the status message of the response from the server\n * @param headers {Record<string, string>} the headers of the response from the server\n * @param body {string} the body from the response of the server\n * @returns {Object} JSON parsed body or error object\n */\nconst parseBody = (\n    statusCode: number,\n    statusMessage: string | undefined,\n    headers: Record<string, string>,\n    body: string\n) => {\n    /*\n     * Informational responses (100 – 199)\n     * Successful responses (200 – 299)\n     * Redirection messages (300 – 399)\n     * Client error responses (400 – 499)\n     * Server error responses (500 – 599)\n     */\n\n    let parsedBody;\n    try {\n        parsedBody = JSON.parse(body);\n    } catch (error) {\n        let errorType;\n        let errorDescriptionHelper;\n        if (\n            statusCode >= HttpStatus.CLIENT_ERROR_RANGE_START &&\n            statusCode <= HttpStatus.CLIENT_ERROR_RANGE_END\n        ) {\n            errorType = \"client_error\";\n            errorDescriptionHelper = \"A client\";\n        } else if (\n            statusCode >= HttpStatus.SERVER_ERROR_RANGE_START &&\n            statusCode <= HttpStatus.SERVER_ERROR_RANGE_END\n        ) {\n            errorType = \"server_error\";\n            errorDescriptionHelper = \"A server\";\n        } else {\n            errorType = \"unknown_error\";\n            errorDescriptionHelper = \"An unknown\";\n        }\n\n        parsedBody = {\n            error: errorType,\n            error_description: `${errorDescriptionHelper} error occured.\\nHttp status code: ${statusCode}\\nHttp status message: ${\n                statusMessage || \"Unknown\"\n            }\\nHeaders: ${JSON.stringify(headers)}`,\n        };\n    }\n\n    return parsedBody;\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 822, "column": 0}, "map": {"version":3,"file":"ManagedIdentityErrorCodes.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/error/ManagedIdentityErrorCodes.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ManagedIdentityEnvironmentVariableNames } from \"../utils/Constants.js\";\n\nexport const invalidFileExtension = \"invalid_file_extension\";\nexport const invalidFilePath = \"invalid_file_path\";\nexport const invalidManagedIdentityIdType = \"invalid_managed_identity_id_type\";\nexport const invalidSecret = \"invalid_secret\";\nexport const missingId = \"missing_client_id\";\nexport const networkUnavailable = \"network_unavailable\";\nexport const platformNotSupported = \"platform_not_supported\";\nexport const unableToCreateAzureArc = \"unable_to_create_azure_arc\";\nexport const unableToCreateCloudShell = \"unable_to_create_cloud_shell\";\nexport const unableToCreateSource = \"unable_to_create_source\";\nexport const unableToReadSecretFile = \"unable_to_read_secret_file\";\nexport const urlParseError = \"url_parse_error\";\nexport const userAssignedNotAvailableAtRuntime =\n    \"user_assigned_not_available_at_runtime\";\nexport const wwwAuthenticateHeaderMissing = \"www_authenticate_header_missing\";\nexport const wwwAuthenticateHeaderUnsupportedFormat =\n    \"www_authenticate_header_unsupported_format\";\n\nexport const MsiEnvironmentVariableUrlMalformedErrorCodes = {\n    [ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST]:\n        \"azure_pod_identity_authority_host_url_malformed\",\n    [ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT]:\n        \"identity_endpoint_url_malformed\",\n    [ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT]:\n        \"imds_endpoint_url_malformed\",\n    [ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT]:\n        \"msi_endpoint_url_malformed\",\n} as const;\nexport type MsiEnvironmentVariableErrorCodes =\n    (typeof MsiEnvironmentVariableUrlMalformedErrorCodes)[keyof typeof MsiEnvironmentVariableUrlMalformedErrorCodes];\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;;;CAGG,GAII,MAAM,oBAAoB,GAAG,yBAAyB;AACtD,MAAM,eAAe,GAAG,oBAAoB;AAC5C,MAAM,4BAA4B,GAAG,mCAAmC;AACxE,MAAM,aAAa,GAAG,iBAAiB;AACvC,MAAM,SAAS,GAAG,oBAAoB;AACtC,MAAM,kBAAkB,GAAG,sBAAsB;AACjD,MAAM,oBAAoB,GAAG,yBAAyB;AACtD,MAAM,sBAAsB,GAAG,6BAA6B;AAC5D,MAAM,wBAAwB,GAAG,+BAA+B;AAChE,MAAM,oBAAoB,GAAG,0BAA0B;AACvD,MAAM,sBAAsB,GAAG,6BAA6B;AAE5D,MAAM,iCAAiC,GAC1C,yCAAyC;AACtC,MAAM,4BAA4B,GAAG,kCAAkC;AACvE,MAAM,sCAAsC,GAC/C,6CAA6C;AAEpC,MAAA,4CAA4C,GAAG;IACxD,wKAAC,0CAAuC,CAAC,iCAAiC,CAAA,EACtE,iDAAiD;IACrD,wKAAC,0CAAuC,CAAC,iBAAiB,CAAA,EACtD,iCAAiC;IACrC,wKAAC,0CAAuC,CAAC,aAAa,CAAA,EAClD,6BAA6B;IACjC,wKAAC,0CAAuC,CAAC,YAAY,CAAA,EACjD,4BAA4B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 873, "column": 0}, "map": {"version":3,"file":"ManagedIdentityError.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/error/ManagedIdentityError.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { AuthError } from \"@azure/msal-common/node\";\nimport * as ManagedIdentityErrorCodes from \"./ManagedIdentityErrorCodes.js\";\nimport { ManagedIdentityEnvironmentVariableNames } from \"../utils/Constants.js\";\nexport { ManagedIdentityErrorCodes };\n\n/**\n * ManagedIdentityErrorMessage class containing string constants used by error codes and messages.\n */\nexport const ManagedIdentityErrorMessages = {\n    [ManagedIdentityErrorCodes.invalidFileExtension]:\n        \"The file path in the WWW-Authenticate header does not contain a .key file.\",\n    [ManagedIdentityErrorCodes.invalidFilePath]:\n        \"The file path in the WWW-Authenticate header is not in a valid Windows or Linux Format.\",\n    [ManagedIdentityErrorCodes.invalidManagedIdentityIdType]:\n        \"More than one ManagedIdentityIdType was provided.\",\n    [ManagedIdentityErrorCodes.invalidSecret]:\n        \"The secret in the file on the file path in the WWW-Authenticate header is greater than 4096 bytes.\",\n    [ManagedIdentityErrorCodes.platformNotSupported]:\n        \"The platform is not supported by Azure Arc. Azure Arc only supports Windows and Linux.\",\n    [ManagedIdentityErrorCodes.missingId]:\n        \"A ManagedIdentityId id was not provided.\",\n    [ManagedIdentityErrorCodes.MsiEnvironmentVariableUrlMalformedErrorCodes\n        .AZURE_POD_IDENTITY_AUTHORITY_HOST]: `The Managed Identity's '${ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST}' environment variable is malformed.`,\n    [ManagedIdentityErrorCodes.MsiEnvironmentVariableUrlMalformedErrorCodes\n        .IDENTITY_ENDPOINT]: `The Managed Identity's '${ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT}' environment variable is malformed.`,\n    [ManagedIdentityErrorCodes.MsiEnvironmentVariableUrlMalformedErrorCodes\n        .IMDS_ENDPOINT]: `The Managed Identity's '${ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT}' environment variable is malformed.`,\n    [ManagedIdentityErrorCodes.MsiEnvironmentVariableUrlMalformedErrorCodes\n        .MSI_ENDPOINT]: `The Managed Identity's '${ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT}' environment variable is malformed.`,\n    [ManagedIdentityErrorCodes.networkUnavailable]:\n        \"Authentication unavailable. The request to the managed identity endpoint timed out.\",\n    [ManagedIdentityErrorCodes.unableToCreateAzureArc]:\n        \"Azure Arc Managed Identities can only be system assigned.\",\n    [ManagedIdentityErrorCodes.unableToCreateCloudShell]:\n        \"Cloud Shell Managed Identities can only be system assigned.\",\n    [ManagedIdentityErrorCodes.unableToCreateSource]:\n        \"Unable to create a Managed Identity source based on environment variables.\",\n    [ManagedIdentityErrorCodes.unableToReadSecretFile]:\n        \"Unable to read the secret file.\",\n    [ManagedIdentityErrorCodes.userAssignedNotAvailableAtRuntime]:\n        \"Service Fabric user assigned managed identity ClientId or ResourceId is not configurable at runtime.\",\n    [ManagedIdentityErrorCodes.wwwAuthenticateHeaderMissing]:\n        \"A 401 response was received form the Azure Arc Managed Identity, but the www-authenticate header is missing.\",\n    [ManagedIdentityErrorCodes.wwwAuthenticateHeaderUnsupportedFormat]:\n        \"A 401 response was received form the Azure Arc Managed Identity, but the www-authenticate header is in an unsupported format.\",\n};\n\nexport class ManagedIdentityError extends AuthError {\n    constructor(errorCode: string) {\n        super(errorCode, ManagedIdentityErrorMessages[errorCode]);\n        this.name = \"ManagedIdentityError\";\n        Object.setPrototypeOf(this, ManagedIdentityError.prototype);\n    }\n}\n\nexport function createManagedIdentityError(\n    errorCode: string\n): ManagedIdentityError {\n    return new ManagedIdentityError(errorCode);\n}\n"],"names":["ManagedIdentityErrorCodes.invalidFileExtension","ManagedIdentityErrorCodes.invalidFilePath","ManagedIdentityErrorCodes.invalidManagedIdentityIdType","ManagedIdentityErrorCodes.invalidSecret","ManagedIdentityErrorCodes.platformNotSupported","ManagedIdentityErrorCodes.missingId","ManagedIdentityErrorCodes.MsiEnvironmentVariableUrlMalformedErrorCodes","ManagedIdentityErrorCodes.networkUnavailable","ManagedIdentityErrorCodes.unableToCreateAzureArc","ManagedIdentityErrorCodes.unableToCreateCloudShell","ManagedIdentityErrorCodes.unableToCreateSource","ManagedIdentityErrorCodes.unableToReadSecretFile","ManagedIdentityErrorCodes.userAssignedNotAvailableAtRuntime","ManagedIdentityErrorCodes.wwwAuthenticateHeaderMissing","ManagedIdentityErrorCodes.wwwAuthenticateHeaderUnsupportedFormat"],"mappings":";;;;;;;;;;;;AAAA;;;CAGG,GAOH;;CAEG,GACU,MAAA,4BAA4B,GAAG;IACxC,wLAACA,uBAA8C,CAAA,EAC3C,4EAA4E;IAChF,uLAACC,mBAAyC,CAAA,EACtC,yFAAyF;IAC7F,wLAACC,+BAAsD,CAAA,EACnD,mDAAmD;IACvD,wLAACC,gBAAuC,CAAA,EACpC,oGAAoG;IACxG,wLAACC,uBAA8C,CAAA,EAC3C,wFAAwF;IAC5F,wLAACC,YAAmC,CAAA,EAChC,0CAA0C;IAC9C,wLAACC,+CAAsE,CAClE,iCAAiC,CAAA,EAAG,CAAA,wBAAA,EAA2B,iNAAuC,CAAC,iCAAiC,CAAsC,oCAAA,CAAA;IACnL,wLAACA,+CAAsE,CAClE,iBAAiB,CAAA,EAAG,CAAA,wBAAA,yKAA2B,0CAAuC,CAAC,iBAAiB,CAAsC,oCAAA,CAAA;IACnJ,CAACA,sOAAsE,CAClE,aAAa,CAAA,EAAG,CAAA,wBAAA,yKAA2B,0CAAuC,CAAC,aAAa,CAAsC,oCAAA,CAAA;IAC3I,wLAACA,+CAAsE,CAClE,YAAY,CAAA,EAAG,CAAA,wBAAA,wKAA2B,2CAAuC,CAAC,YAAY,CAAsC,oCAAA,CAAA;IACzI,wLAACC,qBAA4C,CAAA,EACzC,qFAAqF;IACzF,wLAACC,yBAAgD,CAAA,EAC7C,2DAA2D;IAC/D,wLAACC,2BAAkD,CAAA,EAC/C,6DAA6D;IACjE,CAACC,8MAA8C,CAAA,EAC3C,4EAA4E;IAChF,wLAACC,yBAAgD,CAAA,EAC7C,iCAAiC;IACrC,wLAACC,oCAA2D,CAAA,EACxD,sGAAsG;IAC1G,wLAACC,+BAAsD,CAAA,EACnD,8GAA8G;IAClH,wLAACC,yCAAgE,CAAA,EAC7D,+HAA+H;EACrI;AAEI,MAAO,oBAAqB,kMAAQ,YAAS,CAAA;IAC/C,WAAA,CAAY,SAAiB,CAAA;QACzB,KAAK,CAAC,SAAS,EAAE,4BAA4B,CAAC,SAAS,CAAC,CAAC,CAAC;QAC1D,IAAI,CAAC,IAAI,GAAG,sBAAsB,CAAC;QACnC,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,oBAAoB,CAAC,SAAS,CAAC,CAAC;KAC/D;AACJ,CAAA;AAEK,SAAU,0BAA0B,CACtC,SAAiB,EAAA;IAEjB,OAAO,IAAI,oBAAoB,CAAC,SAAS,CAAC,CAAC;AAC/C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 928, "column": 0}, "map": {"version":3,"file":"ManagedIdentityId.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/config/ManagedIdentityId.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    ManagedIdentityErrorCodes,\n    createManagedIdentityError,\n} from \"../error/ManagedIdentityError.js\";\nimport {\n    DEFAULT_MANAGED_IDENTITY_ID,\n    ManagedIdentityIdType,\n} from \"../utils/Constants.js\";\nimport type { ManagedIdentityIdParams } from \"./Configuration.js\";\n\nexport class ManagedIdentityId {\n    private _id: string;\n    public get id(): string {\n        return this._id;\n    }\n    private set id(value: string) {\n        this._id = value;\n    }\n\n    private _idType: ManagedIdentityIdType;\n    public get idType(): ManagedIdentityIdType {\n        return this._idType;\n    }\n    private set idType(value: ManagedIdentityIdType) {\n        this._idType = value;\n    }\n\n    constructor(managedIdentityIdParams?: ManagedIdentityIdParams) {\n        const userAssignedClientId =\n            managedIdentityIdParams?.userAssignedClientId;\n        const userAssignedResourceId =\n            managedIdentityIdParams?.userAssignedResourceId;\n        const userAssignedObjectId =\n            managedIdentityIdParams?.userAssignedObjectId;\n\n        if (userAssignedClientId) {\n            if (userAssignedResourceId || userAssignedObjectId) {\n                throw createManagedIdentityError(\n                    ManagedIdentityErrorCodes.invalidManagedIdentityIdType\n                );\n            }\n\n            this.id = userAssignedClientId;\n            this.idType = ManagedIdentityIdType.USER_ASSIGNED_CLIENT_ID;\n        } else if (userAssignedResourceId) {\n            if (userAssignedClientId || userAssignedObjectId) {\n                throw createManagedIdentityError(\n                    ManagedIdentityErrorCodes.invalidManagedIdentityIdType\n                );\n            }\n\n            this.id = userAssignedResourceId;\n            this.idType = ManagedIdentityIdType.USER_ASSIGNED_RESOURCE_ID;\n        } else if (userAssignedObjectId) {\n            if (userAssignedClientId || userAssignedResourceId) {\n                throw createManagedIdentityError(\n                    ManagedIdentityErrorCodes.invalidManagedIdentityIdType\n                );\n            }\n\n            this.id = userAssignedObjectId;\n            this.idType = ManagedIdentityIdType.USER_ASSIGNED_OBJECT_ID;\n        } else {\n            this.id = DEFAULT_MANAGED_IDENTITY_ID;\n            this.idType = ManagedIdentityIdType.SYSTEM_ASSIGNED;\n        }\n    }\n}\n"],"names":["ManagedIdentityErrorCodes.invalidManagedIdentityIdType"],"mappings":";;;;;;;;;;AAAA;;;CAGG,SAYU,iBAAiB,CAAA;IAE1B,IAAW,EAAE,GAAA;QACT,OAAO,IAAI,CAAC,GAAG,CAAC;KACnB;IACD,IAAY,EAAE,CAAC,KAAa,EAAA;QACxB,IAAI,CAAC,GAAG,GAAG,KAAK,CAAC;KACpB;IAGD,IAAW,MAAM,GAAA;QACb,OAAO,IAAI,CAAC,OAAO,CAAC;KACvB;IACD,IAAY,MAAM,CAAC,KAA4B,EAAA;QAC3C,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;KACxB;IAED,WAAA,CAAY,uBAAiD,CAAA;QACzD,MAAM,oBAAoB,GACtB,uBAAuB,EAAE,oBAAoB,CAAC;QAClD,MAAM,sBAAsB,GACxB,uBAAuB,EAAE,sBAAsB,CAAC;QACpD,MAAM,oBAAoB,GACtB,uBAAuB,EAAE,oBAAoB,CAAC;QAElD,IAAI,oBAAoB,EAAE;YACtB,IAAI,sBAAsB,IAAI,oBAAoB,EAAE;gBAChD,4LAAM,6BAAA,AAA0B,wLAC5BA,gCAAsD,CACzD,CAAC;YACL,CAAA;YAED,IAAI,CAAC,EAAE,GAAG,oBAAoB,CAAC;YAC/B,IAAI,CAAC,MAAM,0KAAG,wBAAqB,CAAC,uBAAuB,CAAC;QAC/D,CAAA,MAAM,IAAI,sBAAsB,EAAE;YAC/B,IAAI,oBAAoB,IAAI,oBAAoB,EAAE;gBAC9C,MAAM,mNAAA,AAA0B,yLAC5BA,+BAAsD,CACzD,CAAC;YACL,CAAA;YAED,IAAI,CAAC,EAAE,GAAG,sBAAsB,CAAC;YACjC,IAAI,CAAC,MAAM,0KAAG,wBAAqB,CAAC,yBAAyB,CAAC;QACjE,CAAA,MAAM,IAAI,oBAAoB,EAAE;YAC7B,IAAI,oBAAoB,IAAI,sBAAsB,EAAE;gBAChD,4LAAM,6BAAA,AAA0B,yLAC5BA,+BAAsD,CACzD,CAAC;YACL,CAAA;YAED,IAAI,CAAC,EAAE,GAAG,oBAAoB,CAAC;YAC/B,IAAI,CAAC,MAAM,0KAAG,wBAAqB,CAAC,uBAAuB,CAAC;QAC/D,CAAA,MAAM;YACH,IAAI,CAAC,EAAE,0KAAG,8BAA2B,CAAC;YACtC,IAAI,CAAC,MAAM,0KAAG,wBAAqB,CAAC,eAAe,CAAC;QACvD,CAAA;KACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 990, "column": 0}, "map": {"version":3,"file":"NodeAuthError.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/error/NodeAuthError.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { AuthError } from \"@azure/msal-common/node\";\n\n/**\n * NodeAuthErrorMessage class containing string constants used by error codes and messages.\n */\nexport const NodeAuthErrorMessage = {\n    invalidLoopbackAddressType: {\n        code: \"invalid_loopback_server_address_type\",\n        desc: \"Loopback server address is not type string. This is unexpected.\",\n    },\n    unableToLoadRedirectUri: {\n        code: \"unable_to_load_redirectUrl\",\n        desc: \"Loopback server callback was invoked without a url. This is unexpected.\",\n    },\n    noAuthCodeInResponse: {\n        code: \"no_auth_code_in_response\",\n        desc: \"No auth code found in the server response. Please check your network trace to determine what happened.\",\n    },\n    noLoopbackServerExists: {\n        code: \"no_loopback_server_exists\",\n        desc: \"No loopback server exists yet.\",\n    },\n    loopbackServerAlreadyExists: {\n        code: \"loopback_server_already_exists\",\n        desc: \"Loopback server already exists. Cannot create another.\",\n    },\n    loopbackServerTimeout: {\n        code: \"loopback_server_timeout\",\n        desc: \"Timed out waiting for auth code listener to be registered.\",\n    },\n    stateNotFoundError: {\n        code: \"state_not_found\",\n        desc: \"State not found. Please verify that the request originated from msal.\",\n    },\n    thumbprintMissing: {\n        code: \"thumbprint_missing_from_client_certificate\",\n        desc: \"Client certificate does not contain a SHA-1 or SHA-256 thumbprint.\",\n    },\n};\n\nexport class NodeAuthError extends AuthError {\n    constructor(errorCode: string, errorMessage?: string) {\n        super(errorCode, errorMessage);\n        this.name = \"NodeAuthError\";\n    }\n\n    /**\n     * Creates an error thrown if loopback server address is of type string.\n     */\n    static createInvalidLoopbackAddressTypeError(): NodeAuthError {\n        return new NodeAuthError(\n            NodeAuthErrorMessage.invalidLoopbackAddressType.code,\n            `${NodeAuthErrorMessage.invalidLoopbackAddressType.desc}`\n        );\n    }\n\n    /**\n     * Creates an error thrown if the loopback server is unable to get a url.\n     */\n    static createUnableToLoadRedirectUrlError(): NodeAuthError {\n        return new NodeAuthError(\n            NodeAuthErrorMessage.unableToLoadRedirectUri.code,\n            `${NodeAuthErrorMessage.unableToLoadRedirectUri.desc}`\n        );\n    }\n\n    /**\n     * Creates an error thrown if the server response does not contain an auth code.\n     */\n    static createNoAuthCodeInResponseError(): NodeAuthError {\n        return new NodeAuthError(\n            NodeAuthErrorMessage.noAuthCodeInResponse.code,\n            `${NodeAuthErrorMessage.noAuthCodeInResponse.desc}`\n        );\n    }\n\n    /**\n     * Creates an error thrown if the loopback server has not been spun up yet.\n     */\n    static createNoLoopbackServerExistsError(): NodeAuthError {\n        return new NodeAuthError(\n            NodeAuthErrorMessage.noLoopbackServerExists.code,\n            `${NodeAuthErrorMessage.noLoopbackServerExists.desc}`\n        );\n    }\n\n    /**\n     * Creates an error thrown if a loopback server already exists when attempting to create another one.\n     */\n    static createLoopbackServerAlreadyExistsError(): NodeAuthError {\n        return new NodeAuthError(\n            NodeAuthErrorMessage.loopbackServerAlreadyExists.code,\n            `${NodeAuthErrorMessage.loopbackServerAlreadyExists.desc}`\n        );\n    }\n\n    /**\n     * Creates an error thrown if the loopback server times out registering the auth code listener.\n     */\n    static createLoopbackServerTimeoutError(): NodeAuthError {\n        return new NodeAuthError(\n            NodeAuthErrorMessage.loopbackServerTimeout.code,\n            `${NodeAuthErrorMessage.loopbackServerTimeout.desc}`\n        );\n    }\n\n    /**\n     * Creates an error thrown when the state is not present.\n     */\n    static createStateNotFoundError(): NodeAuthError {\n        return new NodeAuthError(\n            NodeAuthErrorMessage.stateNotFoundError.code,\n            NodeAuthErrorMessage.stateNotFoundError.desc\n        );\n    }\n\n    /**\n     * Creates an error thrown when client certificate was provided, but neither the SHA-1 or SHA-256 thumbprints were provided\n     */\n    static createThumbprintMissingError(): NodeAuthError {\n        return new NodeAuthError(\n            NodeAuthErrorMessage.thumbprintMissing.code,\n            NodeAuthErrorMessage.thumbprintMissing.desc\n        );\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1090, "column": 0}, "map": {"version":3,"file":"Configuration.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/config/Configuration.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    LoggerOptions,\n    INetworkModule,\n    LogLevel,\n    ProtocolMode,\n    ICachePlugin,\n    Constants,\n    AzureCloudInstance,\n    AzureCloudOptions,\n    ApplicationTelemetry,\n    INativeBrokerPlugin,\n    ClientAssertionCallback,\n} from \"@azure/msal-common/node\";\nimport { HttpClient } from \"../network/HttpClient.js\";\nimport http from \"http\";\nimport https from \"https\";\nimport { ManagedIdentityId } from \"./ManagedIdentityId.js\";\nimport { NodeAuthError } from \"../error/NodeAuthError.js\";\n\n/**\n * - clientId               - Client id of the application.\n * - authority              - Url of the authority. If no value is set, defaults to https://login.microsoftonline.com/common.\n * - knownAuthorities       - Needed for Azure B2C and ADFS. All authorities that will be used in the client application. Only the host of the authority should be passed in.\n * - clientSecret           - Secret string that the application uses when requesting a token. Only used in confidential client applications. Can be created in the Azure app registration portal.\n * - clientAssertion        - A ClientAssertion object containing an assertion string or a callback function that returns an assertion string that the application uses when requesting a token, as well as the assertion's type (urn:ietf:params:oauth:client-assertion-type:jwt-bearer). Only used in confidential client applications.\n * - clientCertificate      - Certificate that the application uses when requesting a token. Only used in confidential client applications. Requires hex encoded X.509 SHA-1 or SHA-256 thumbprint of the certificate, and the PEM encoded private key (string should contain -----BEGIN PRIVATE KEY----- ... -----END PRIVATE KEY----- )\n * - protocolMode           - Enum that represents the protocol that msal follows. Used for configuring proper endpoints.\n * - skipAuthorityMetadataCache - A flag to choose whether to use or not use the local metadata cache during authority initialization. Defaults to false.\n * - encodeExtraQueryParams - A flag to choose whether to encode extra query parameters in the request URL. Defaults to false.\n * @public\n */\nexport type NodeAuthOptions = {\n    clientId: string;\n    authority?: string;\n    clientSecret?: string;\n    clientAssertion?: string | ClientAssertionCallback;\n    clientCertificate?: {\n        /**\n         * @deprecated Use thumbprintSha2 property instead. Thumbprint needs to be computed with SHA-256 algorithm.\n         * SHA-1 is only needed for backwards compatibility with older versions of ADFS.\n         */\n        thumbprint?: string;\n        thumbprintSha256?: string;\n        privateKey: string;\n        x5c?: string;\n    };\n    knownAuthorities?: Array<string>;\n    cloudDiscoveryMetadata?: string;\n    authorityMetadata?: string;\n    clientCapabilities?: Array<string>;\n    protocolMode?: ProtocolMode;\n    azureCloudOptions?: AzureCloudOptions;\n    skipAuthorityMetadataCache?: boolean;\n    /**\n     * @deprecated This flag is deprecated and will be removed in the next major version where all extra query params will be encoded by default.\n     */\n    encodeExtraQueryParams?: boolean;\n};\n\n/**\n * Use this to configure the below cache configuration options:\n *\n * - cachePlugin   - Plugin for reading and writing token cache to disk.\n * @public\n */\nexport type CacheOptions = {\n    cachePlugin?: ICachePlugin;\n    /**\n     * @deprecated claims-based-caching functionality will be removed in the next version of MSALJS\n     */\n    claimsBasedCachingEnabled?: boolean;\n};\n\n/**\n * Use this to configure the below broker options:\n * - nativeBrokerPlugin - Native broker implementation (should be imported from msal-node-extensions)\n *\n * Note: These options are only available for PublicClientApplications using the Authorization Code Flow\n * @public\n */\nexport type BrokerOptions = {\n    nativeBrokerPlugin?: INativeBrokerPlugin;\n};\n\n/**\n * Type for configuring logger and http client options\n *\n * - logger                       - Used to initialize the Logger object; TODO: Expand on logger details or link to the documentation on logger\n * - networkClient                - Http client used for all http get and post calls. Defaults to using MSAL's default http client.\n * @public\n */\nexport type NodeSystemOptions = {\n    loggerOptions?: LoggerOptions;\n    networkClient?: INetworkModule;\n    proxyUrl?: string;\n    customAgentOptions?: http.AgentOptions | https.AgentOptions;\n    disableInternalRetries?: boolean;\n};\n\n/** @public */\nexport type NodeTelemetryOptions = {\n    application?: ApplicationTelemetry;\n};\n\n/**\n * Use the configuration object to configure MSAL and initialize the client application object\n *\n * - auth: this is where you configure auth elements like clientID, authority used for authenticating against the Microsoft Identity Platform\n * - broker: this is where you configure broker options\n * - cache: this is where you configure cache location\n * - system: this is where you can configure the network client, logger\n * - telemetry: this is where you can configure telemetry options\n * @public\n */\nexport type Configuration = {\n    auth: NodeAuthOptions;\n    broker?: BrokerOptions;\n    cache?: CacheOptions;\n    system?: NodeSystemOptions;\n    telemetry?: NodeTelemetryOptions;\n};\n\n/** @public */\nexport type ManagedIdentityIdParams = {\n    userAssignedClientId?: string;\n    userAssignedResourceId?: string;\n    userAssignedObjectId?: string;\n};\n\n/** @public */\nexport type ManagedIdentityConfiguration = {\n    clientCapabilities?: Array<string>;\n    managedIdentityIdParams?: ManagedIdentityIdParams;\n    system?: NodeSystemOptions;\n};\n\nconst DEFAULT_AUTH_OPTIONS: Required<NodeAuthOptions> = {\n    clientId: Constants.EMPTY_STRING,\n    authority: Constants.DEFAULT_AUTHORITY,\n    clientSecret: Constants.EMPTY_STRING,\n    clientAssertion: Constants.EMPTY_STRING,\n    clientCertificate: {\n        thumbprint: Constants.EMPTY_STRING,\n        thumbprintSha256: Constants.EMPTY_STRING,\n        privateKey: Constants.EMPTY_STRING,\n        x5c: Constants.EMPTY_STRING,\n    },\n    knownAuthorities: [],\n    cloudDiscoveryMetadata: Constants.EMPTY_STRING,\n    authorityMetadata: Constants.EMPTY_STRING,\n    clientCapabilities: [],\n    protocolMode: ProtocolMode.AAD,\n    azureCloudOptions: {\n        azureCloudInstance: AzureCloudInstance.None,\n        tenant: Constants.EMPTY_STRING,\n    },\n    skipAuthorityMetadataCache: false,\n    encodeExtraQueryParams: false,\n};\n\nconst DEFAULT_CACHE_OPTIONS: CacheOptions = {\n    claimsBasedCachingEnabled: false,\n};\n\nconst DEFAULT_LOGGER_OPTIONS: LoggerOptions = {\n    loggerCallback: (): void => {\n        // allow users to not set logger call back\n    },\n    piiLoggingEnabled: false,\n    logLevel: LogLevel.Info,\n};\n\nconst DEFAULT_SYSTEM_OPTIONS: Required<NodeSystemOptions> = {\n    loggerOptions: DEFAULT_LOGGER_OPTIONS,\n    networkClient: new HttpClient(),\n    proxyUrl: Constants.EMPTY_STRING,\n    customAgentOptions: {} as http.AgentOptions | https.AgentOptions,\n    disableInternalRetries: false,\n};\n\nconst DEFAULT_TELEMETRY_OPTIONS: Required<NodeTelemetryOptions> = {\n    application: {\n        appName: Constants.EMPTY_STRING,\n        appVersion: Constants.EMPTY_STRING,\n    },\n};\n\n/** @internal */\nexport type NodeConfiguration = {\n    auth: Required<NodeAuthOptions>;\n    broker: BrokerOptions;\n    cache: CacheOptions;\n    system: Required<NodeSystemOptions>;\n    telemetry: Required<NodeTelemetryOptions>;\n};\n\n/**\n * Sets the default options when not explicitly configured from app developer\n *\n * @param auth - Authentication options\n * @param cache - Cache options\n * @param system - System options\n * @param telemetry - Telemetry options\n *\n * @returns Configuration\n * @internal\n */\nexport function buildAppConfiguration({\n    auth,\n    broker,\n    cache,\n    system,\n    telemetry,\n}: Configuration): NodeConfiguration {\n    const systemOptions: Required<NodeSystemOptions> = {\n        ...DEFAULT_SYSTEM_OPTIONS,\n        networkClient: new HttpClient(\n            system?.proxyUrl,\n            system?.customAgentOptions as http.AgentOptions | https.AgentOptions\n        ),\n        loggerOptions: system?.loggerOptions || DEFAULT_LOGGER_OPTIONS,\n        disableInternalRetries: system?.disableInternalRetries || false,\n    };\n\n    // if client certificate was provided, ensure that at least one of the SHA-1 or SHA-256 thumbprints were provided\n    if (\n        !!auth.clientCertificate &&\n        !!!auth.clientCertificate.thumbprint &&\n        !!!auth.clientCertificate.thumbprintSha256\n    ) {\n        throw NodeAuthError.createStateNotFoundError();\n    }\n\n    return {\n        auth: { ...DEFAULT_AUTH_OPTIONS, ...auth },\n        broker: { ...broker },\n        cache: { ...DEFAULT_CACHE_OPTIONS, ...cache },\n        system: { ...systemOptions, ...system },\n        telemetry: { ...DEFAULT_TELEMETRY_OPTIONS, ...telemetry },\n    };\n}\n\n/** @internal */\nexport type ManagedIdentityNodeConfiguration = {\n    clientCapabilities?: Array<string>;\n    disableInternalRetries: boolean;\n    managedIdentityId: ManagedIdentityId;\n    system: Required<\n        Pick<NodeSystemOptions, \"loggerOptions\" | \"networkClient\">\n    >;\n};\n\nexport function buildManagedIdentityConfiguration({\n    clientCapabilities,\n    managedIdentityIdParams,\n    system,\n}: ManagedIdentityConfiguration): ManagedIdentityNodeConfiguration {\n    const managedIdentityId: ManagedIdentityId = new ManagedIdentityId(\n        managedIdentityIdParams\n    );\n\n    const loggerOptions: LoggerOptions =\n        system?.loggerOptions || DEFAULT_LOGGER_OPTIONS;\n\n    let networkClient: INetworkModule;\n    // use developer provided network client if passed in\n    if (system?.networkClient) {\n        networkClient = system.networkClient;\n        // otherwise, create a new one\n    } else {\n        networkClient = new HttpClient(\n            system?.proxyUrl,\n            system?.customAgentOptions as http.AgentOptions | https.AgentOptions\n        );\n    }\n\n    return {\n        clientCapabilities: clientCapabilities || [],\n        managedIdentityId: managedIdentityId,\n        system: {\n            loggerOptions,\n            networkClient,\n        },\n        disableInternalRetries: system?.disableInternalRetries || false,\n    };\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1227, "column": 0}, "map": {"version":3,"file":"GuidGenerator.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/crypto/GuidGenerator.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { IGuidGenerator } from \"@azure/msal-common/node\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nexport class GuidGenerator implements IGuidGenerator {\n    /**\n     *\n     * RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or pseudo-random numbers.\n     * uuidv4 generates guids from cryprtographically-string random\n     */\n    generateGuid(): string {\n        return uuidv4();\n    }\n\n    /**\n     * verifies if a string is  GUID\n     * @param guid\n     */\n    isGuid(guid: string): boolean {\n        const regexGuid =\n            /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n        return regexGuid.test(guid);\n    }\n}\n"],"names":["uuidv4"],"mappings":";;;;;;AAAA;;;CAGG,SAKU,aAAa,CAAA;IACtB;;;;KAIG,GACH,YAAY,GAAA;QACR,yOAAOA,KAAAA,AAAM,EAAE,CAAC;KACnB;IAED;;;KAGG,GACH,MAAM,CAAC,IAAY,EAAA;QACf,MAAM,SAAS,GACX,4EAA4E,CAAC;QACjF,OAAO,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;KAC/B;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1260, "column": 0}, "map": {"version":3,"file":"EncodingUtils.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/utils/EncodingUtils.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Constants, EncodingTypes } from \"@azure/msal-common/node\";\n\nexport class EncodingUtils {\n    /**\n     * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.\n     * 'base64': Base64 encoding.\n     *\n     * @param str text\n     */\n    static base64Encode(str: string, encoding?: BufferEncoding): string {\n        return Buffer.from(str, encoding).toString(EncodingTypes.BASE64);\n    }\n\n    /**\n     * encode a URL\n     * @param str\n     */\n    static base64EncodeUrl(str: string, encoding?: BufferEncoding): string {\n        return EncodingUtils.base64Encode(str, encoding)\n            .replace(/=/g, Constants.EMPTY_STRING)\n            .replace(/\\+/g, \"-\")\n            .replace(/\\//g, \"_\");\n    }\n\n    /**\n     * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.\n     * 'base64': Base64 encoding.\n     *\n     * @param base64Str Base64 encoded text\n     */\n    static base64Decode(base64Str: string): string {\n        return Buffer.from(base64Str, EncodingTypes.BASE64).toString(\"utf8\");\n    }\n\n    /**\n     * @param base64Str Base64 encoded Url\n     */\n    static base64DecodeUrl(base64Str: string): string {\n        let str = base64Str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n        while (str.length % 4) {\n            str += \"=\";\n        }\n        return EncodingUtils.base64Decode(str);\n    }\n}\n"],"names":[],"mappings":";;;;;;AAAA;;;CAGG,SAIU,aAAa,CAAA;IACtB;;;;;KAKG,GACH,OAAO,YAAY,CAAC,GAAW,EAAE,QAAyB,EAAA;QACtD,OAAO,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC,QAAQ,0KAAC,gBAAa,CAAC,MAAM,CAAC,CAAC;KACpE;IAED;;;KAGG,GACH,OAAO,eAAe,CAAC,GAAW,EAAE,QAAyB,EAAA;QACzD,OAAO,aAAa,CAAC,YAAY,CAAC,GAAG,EAAE,QAAQ,CAAC,CAC3C,OAAO,CAAC,IAAI,2KAAE,YAAS,CAAC,YAAY,CAAC,CACrC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CACnB,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;KAC5B;IAED;;;;;KAKG,GACH,OAAO,YAAY,CAAC,SAAiB,EAAA;QACjC,OAAO,MAAM,CAAC,IAAI,CAAC,SAAS,2KAAE,gBAAa,CAAC,MAAM,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;KACxE;IAED;;KAEG,GACH,OAAO,eAAe,CAAC,SAAiB,EAAA;QACpC,IAAI,GAAG,GAAG,SAAS,CAAC,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;QAC1D,MAAO,GAAG,CAAC,MAAM,GAAG,CAAC,CAAE;YACnB,GAAG,IAAI,GAAG,CAAC;QACd,CAAA;QACD,OAAO,aAAa,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC;KAC1C;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1310, "column": 0}, "map": {"version":3,"file":"HashUtils.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/crypto/HashUtils.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Hash } from \"../utils/Constants.js\";\nimport crypto from \"crypto\";\n\nexport class HashUtils {\n    /**\n     * generate 'SHA256' hash\n     * @param buffer\n     */\n    sha256(buffer: string): Buffer {\n        return crypto.createHash(Hash.SHA256).update(buffer).digest();\n    }\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;;;CAGG,SAKU,SAAS,CAAA;IAClB;;;KAGG,GACH,MAAM,CAAC,MAAc,EAAA;QACjB,6GAAO,UAAM,CAAC,UAAU,wKAAC,OAAI,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,MAAM,EAAE,CAAC;KACjE;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1337, "column": 0}, "map": {"version":3,"file":"PkceGenerator.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/crypto/PkceGenerator.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Constants, EncodingTypes, PkceCodes } from \"@azure/msal-common/node\";\nimport { CharSet, RANDOM_OCTET_SIZE } from \"../utils/Constants.js\";\nimport { EncodingUtils } from \"../utils/EncodingUtils.js\";\nimport { HashUtils } from \"./HashUtils.js\";\nimport crypto from \"crypto\";\n\n/**\n * https://tools.ietf.org/html/rfc7636#page-8\n */\nexport class PkceGenerator {\n    private hashUtils: HashUtils;\n\n    constructor() {\n        this.hashUtils = new HashUtils();\n    }\n    /**\n     * generates the codeVerfier and the challenge from the codeVerfier\n     * reference: https://tools.ietf.org/html/rfc7636#section-4.1 and https://tools.ietf.org/html/rfc7636#section-4.2\n     */\n    async generatePkceCodes(): Promise<PkceCodes> {\n        const verifier = this.generateCodeVerifier();\n        const challenge = this.generateCodeChallengeFromVerifier(verifier);\n        return { verifier, challenge };\n    }\n\n    /**\n     * generates the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.1\n     */\n    private generateCodeVerifier(): string {\n        const charArr = [];\n        const maxNumber = 256 - (256 % CharSet.CV_CHARSET.length);\n        while (charArr.length <= RANDOM_OCTET_SIZE) {\n            const byte = crypto.randomBytes(1)[0];\n            if (byte >= maxNumber) {\n                /*\n                 * Ignore this number to maintain randomness.\n                 * Including it would result in an unequal distribution of characters after doing the modulo\n                 */\n                continue;\n            }\n            const index = byte % CharSet.CV_CHARSET.length;\n            charArr.push(CharSet.CV_CHARSET[index]);\n        }\n        const verifier: string = charArr.join(Constants.EMPTY_STRING);\n        return EncodingUtils.base64EncodeUrl(verifier);\n    }\n\n    /**\n     * generate the challenge from the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.2\n     * @param codeVerifier\n     */\n    private generateCodeChallengeFromVerifier(codeVerifier: string): string {\n        return EncodingUtils.base64EncodeUrl(\n            this.hashUtils.sha256(codeVerifier).toString(EncodingTypes.BASE64),\n            EncodingTypes.BASE64\n        );\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;;;CAGG,GAQH;;CAEG,SACU,aAAa,CAAA;IAGtB,WAAA,EAAA;QACI,IAAI,CAAC,SAAS,GAAG,4KAAI,YAAS,EAAE,CAAC;KACpC;IACD;;;KAGG,GACH,MAAM,iBAAiB,GAAA;QACnB,MAAM,QAAQ,GAAG,IAAI,CAAC,oBAAoB,EAAE,CAAC;QAC7C,MAAM,SAAS,GAAG,IAAI,CAAC,iCAAiC,CAAC,QAAQ,CAAC,CAAC;QACnE,OAAO;YAAE,QAAQ;YAAE,SAAS;QAAA,CAAE,CAAC;KAClC;IAED;;KAEG,GACK,oBAAoB,GAAA;QACxB,MAAM,OAAO,GAAG,EAAE,CAAC;QACnB,MAAM,SAAS,GAAG,GAAG,GAAI,GAAG,0KAAG,UAAO,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;QAC1D,MAAO,OAAO,CAAC,MAAM,IAAI,2LAAiB,CAAE;YACxC,MAAM,IAAI,yGAAG,UAAM,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACtC,IAAI,IAAI,IAAI,SAAS,EAAE;gBAKnB,SAAS;YACZ,CAAA;YACD,MAAM,KAAK,GAAG,IAAI,0KAAG,UAAO,CAAC,UAAU,CAAC,MAAM,CAAC;YAC/C,OAAO,CAAC,IAAI,wKAAC,UAAO,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC;QAC3C,CAAA;QACD,MAAM,QAAQ,GAAW,OAAO,CAAC,IAAI,0KAAC,YAAS,CAAC,YAAY,CAAC,CAAC;QAC9D,kLAAO,gBAAa,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;KAClD;IAED;;;KAGG,GACK,iCAAiC,CAAC,YAAoB,EAAA;QAC1D,kLAAO,gBAAa,CAAC,eAAe,CAChC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,QAAQ,0KAAC,gBAAa,CAAC,MAAM,CAAC,2KAClE,gBAAa,CAAC,MAAM,CACvB,CAAC;KACL;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1402, "column": 0}, "map": {"version":3,"file":"CryptoProvider.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/crypto/CryptoProvider.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { EncodingTypes, ICrypto, PkceCodes } from \"@azure/msal-common/node\";\nimport { GuidGenerator } from \"./GuidGenerator.js\";\nimport { EncodingUtils } from \"../utils/EncodingUtils.js\";\nimport { PkceGenerator } from \"./PkceGenerator.js\";\nimport { HashUtils } from \"./HashUtils.js\";\n\n/**\n * This class implements MSAL node's crypto interface, which allows it to perform base64 encoding and decoding, generating cryptographically random GUIDs and\n * implementing Proof Key for Code Exchange specs for the OAuth Authorization Code Flow using PKCE (rfc here: https://tools.ietf.org/html/rfc7636).\n * @public\n */\nexport class CryptoProvider implements ICrypto {\n    private pkceGenerator: PkceGenerator;\n    private guidGenerator: GuidGenerator;\n    private hashUtils: HashUtils;\n\n    constructor() {\n        // Browser crypto needs to be validated first before any other classes can be set.\n        this.pkceGenerator = new PkceGenerator();\n        this.guidGenerator = new GuidGenerator();\n        this.hashUtils = new HashUtils();\n    }\n\n    /**\n     * base64 URL safe encoded string\n     */\n    base64UrlEncode(): string {\n        throw new Error(\"Method not implemented.\");\n    }\n    /**\n     * Stringifies and base64Url encodes input public key\n     * @param inputKid - public key id\n     * @returns Base64Url encoded public key\n     */\n    encodeKid(): string {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    /**\n     * Creates a new random GUID - used to populate state and nonce.\n     * @returns string (GUID)\n     */\n    createNewGuid(): string {\n        return this.guidGenerator.generateGuid();\n    }\n\n    /**\n     * Encodes input string to base64.\n     * @param input - string to be encoded\n     */\n    base64Encode(input: string): string {\n        return EncodingUtils.base64Encode(input);\n    }\n\n    /**\n     * Decodes input string from base64.\n     * @param input - string to be decoded\n     */\n    base64Decode(input: string): string {\n        return EncodingUtils.base64Decode(input);\n    }\n\n    /**\n     * Generates PKCE codes used in Authorization Code Flow.\n     */\n    generatePkceCodes(): Promise<PkceCodes> {\n        return this.pkceGenerator.generatePkceCodes();\n    }\n\n    /**\n     * Generates a keypair, stores it and returns a thumbprint - not yet implemented for node\n     */\n    getPublicKeyThumbprint(): Promise<string> {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    /**\n     * Removes cryptographic keypair from key store matching the keyId passed in\n     * @param kid - public key id\n     */\n    removeTokenBindingKey(): Promise<void> {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    /**\n     * Removes all cryptographic keys from Keystore\n     */\n    clearKeystore(): Promise<boolean> {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    /**\n     * Signs the given object as a jwt payload with private key retrieved by given kid - currently not implemented for node\n     */\n    signJwt(): Promise<string> {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    /**\n     * Returns the SHA-256 hash of an input string\n     */\n    async hashString(plainText: string): Promise<string> {\n        return EncodingUtils.base64EncodeUrl(\n            this.hashUtils.sha256(plainText).toString(EncodingTypes.BASE64),\n            EncodingTypes.BASE64\n        );\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;;;CAGG,GAQH;;;;CAIG,SACU,cAAc,CAAA;IAKvB,WAAA,EAAA;;QAEI,IAAI,CAAC,aAAa,GAAG,gLAAI,gBAAa,EAAE,CAAC;QACzC,IAAI,CAAC,aAAa,GAAG,IAAI,4LAAa,EAAE,CAAC;QACzC,IAAI,CAAC,SAAS,GAAG,4KAAI,YAAS,EAAE,CAAC;KACpC;IAED;;KAEG,GACH,eAAe,GAAA;QACX,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;KAC9C;IACD;;;;KAIG,GACH,SAAS,GAAA;QACL,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;KAC9C;IAED;;;KAGG,GACH,aAAa,GAAA;QACT,OAAO,IAAI,CAAC,aAAa,CAAC,YAAY,EAAE,CAAC;KAC5C;IAED;;;KAGG,GACH,YAAY,CAAC,KAAa,EAAA;QACtB,iLAAO,iBAAa,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;KAC5C;IAED;;;KAGG,GACH,YAAY,CAAC,KAAa,EAAA;QACtB,kLAAO,gBAAa,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;KAC5C;IAED;;KAEG,GACH,iBAAiB,GAAA;QACb,OAAO,IAAI,CAAC,aAAa,CAAC,iBAAiB,EAAE,CAAC;KACjD;IAED;;KAEG,GACH,sBAAsB,GAAA;QAClB,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;KAC9C;IAED;;;KAGG,GACH,qBAAqB,GAAA;QACjB,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;KAC9C;IAED;;KAEG,GACH,aAAa,GAAA;QACT,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;KAC9C;IAED;;KAEG,GACH,OAAO,GAAA;QACH,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;KAC9C;IAED;;KAEG,GACH,MAAM,UAAU,CAAC,SAAiB,EAAA;QAC9B,kLAAO,gBAAa,CAAC,eAAe,CAChC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,QAAQ,0KAAC,gBAAa,CAAC,MAAM,CAAC,2KAC/D,gBAAa,CAAC,MAAM,CACvB,CAAC;KACL;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1500, "column": 0}, "map": {"version":3,"file":"NodeStorage.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/cache/NodeStorage.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    TokenKeys,\n    AccountEntity,\n    IdTokenEntity,\n    AccessTokenEntity,\n    RefreshTokenEntity,\n    AppMetadataEntity,\n    ServerTelemetryEntity,\n    ThrottlingEntity,\n    CacheManager,\n    Logger,\n    ValidCacheType,\n    ICrypto,\n    AuthorityMetadataEntity,\n    ValidCredentialType,\n    StaticAuthorityOptions,\n    CacheHelpers,\n} from \"@azure/msal-common/node\";\n\nimport { Deserializer } from \"./serializer/Deserializer.js\";\nimport { Serializer } from \"./serializer/Serializer.js\";\nimport {\n    InMemoryCache,\n    JsonCache,\n    CacheKVStore,\n} from \"./serializer/SerializerTypes.js\";\nimport { StubPerformanceClient } from \"@azure/msal-common\";\n\n/**\n * This class implements Storage for node, reading cache from user specified storage location or an  extension library\n * @public\n */\nexport class NodeStorage extends CacheManager {\n    // Cache configuration, either set by user or default values.\n    private logger: Logger;\n    private cache: CacheKVStore = {};\n    private changeEmitters: Array<Function> = [];\n\n    constructor(\n        logger: Logger,\n        clientId: string,\n        cryptoImpl: ICrypto,\n        staticAuthorityOptions?: StaticAuthorityOptions\n    ) {\n        super(\n            clientId,\n            cryptoImpl,\n            logger,\n            new StubPerformanceClient(),\n            staticAuthorityOptions\n        );\n        this.logger = logger;\n    }\n\n    /**\n     * Queue up callbacks\n     * @param func - a callback function for cache change indication\n     */\n    registerChangeEmitter(func: () => void): void {\n        this.changeEmitters.push(func);\n    }\n\n    /**\n     * Invoke the callback when cache changes\n     */\n    emitChange(): void {\n        this.changeEmitters.forEach((func) => func.call(null));\n    }\n\n    /**\n     * Converts cacheKVStore to InMemoryCache\n     * @param cache - key value store\n     */\n    cacheToInMemoryCache(cache: CacheKVStore): InMemoryCache {\n        const inMemoryCache: InMemoryCache = {\n            accounts: {},\n            idTokens: {},\n            accessTokens: {},\n            refreshTokens: {},\n            appMetadata: {},\n        };\n\n        for (const key in cache) {\n            const value = cache[key];\n            if (typeof value !== \"object\") {\n                continue;\n            }\n            if (value instanceof AccountEntity) {\n                inMemoryCache.accounts[key] = value as AccountEntity;\n            } else if (CacheHelpers.isIdTokenEntity(value)) {\n                inMemoryCache.idTokens[key] = value as IdTokenEntity;\n            } else if (CacheHelpers.isAccessTokenEntity(value)) {\n                inMemoryCache.accessTokens[key] = value as AccessTokenEntity;\n            } else if (CacheHelpers.isRefreshTokenEntity(value)) {\n                inMemoryCache.refreshTokens[key] = value as RefreshTokenEntity;\n            } else if (CacheHelpers.isAppMetadataEntity(key, value)) {\n                inMemoryCache.appMetadata[key] = value as AppMetadataEntity;\n            } else {\n                continue;\n            }\n        }\n\n        return inMemoryCache;\n    }\n\n    /**\n     * converts inMemoryCache to CacheKVStore\n     * @param inMemoryCache - kvstore map for inmemory\n     */\n    inMemoryCacheToCache(inMemoryCache: InMemoryCache): CacheKVStore {\n        // convert in memory cache to a flat Key-Value map\n        let cache = this.getCache();\n\n        cache = {\n            ...cache,\n            ...inMemoryCache.accounts,\n            ...inMemoryCache.idTokens,\n            ...inMemoryCache.accessTokens,\n            ...inMemoryCache.refreshTokens,\n            ...inMemoryCache.appMetadata,\n        };\n\n        // convert in memory cache to a flat Key-Value map\n        return cache;\n    }\n\n    /**\n     * gets the current in memory cache for the client\n     */\n    getInMemoryCache(): InMemoryCache {\n        this.logger.trace(\"Getting in-memory cache\");\n\n        // convert the cache key value store to inMemoryCache\n        const inMemoryCache = this.cacheToInMemoryCache(this.getCache());\n        return inMemoryCache;\n    }\n\n    /**\n     * sets the current in memory cache for the client\n     * @param inMemoryCache - key value map in memory\n     */\n    setInMemoryCache(inMemoryCache: InMemoryCache): void {\n        this.logger.trace(\"Setting in-memory cache\");\n\n        // convert and append the inMemoryCache to cacheKVStore\n        const cache = this.inMemoryCacheToCache(inMemoryCache);\n        this.setCache(cache);\n\n        this.emitChange();\n    }\n\n    /**\n     * get the current cache key-value store\n     */\n    getCache(): CacheKVStore {\n        this.logger.trace(\"Getting cache key-value store\");\n        return this.cache;\n    }\n\n    /**\n     * sets the current cache (key value store)\n     * @param cacheMap - key value map\n     */\n    setCache(cache: CacheKVStore): void {\n        this.logger.trace(\"Setting cache key value store\");\n        this.cache = cache;\n\n        // mark change in cache\n        this.emitChange();\n    }\n\n    /**\n     * Gets cache item with given key.\n     * @param key - lookup key for the cache entry\n     */\n    getItem(key: string): ValidCacheType {\n        this.logger.tracePii(`Item key: ${key}`);\n\n        // read cache\n        const cache = this.getCache();\n        return cache[key];\n    }\n\n    /**\n     * Gets cache item with given key-value\n     * @param key - lookup key for the cache entry\n     * @param value - value of the cache entry\n     */\n    setItem(key: string, value: ValidCacheType): void {\n        this.logger.tracePii(`Item key: ${key}`);\n\n        // read cache\n        const cache = this.getCache();\n        cache[key] = value;\n\n        // write to cache\n        this.setCache(cache);\n    }\n\n    getAccountKeys(): string[] {\n        const inMemoryCache = this.getInMemoryCache();\n        const accountKeys = Object.keys(inMemoryCache.accounts);\n\n        return accountKeys;\n    }\n\n    getTokenKeys(): TokenKeys {\n        const inMemoryCache = this.getInMemoryCache();\n        const tokenKeys = {\n            idToken: Object.keys(inMemoryCache.idTokens),\n            accessToken: Object.keys(inMemoryCache.accessTokens),\n            refreshToken: Object.keys(inMemoryCache.refreshTokens),\n        };\n\n        return tokenKeys;\n    }\n\n    /**\n     * Reads account from cache, builds it into an account entity and returns it.\n     * @param accountKey - lookup key to fetch cache type AccountEntity\n     * @returns\n     */\n    getAccount(accountKey: string): AccountEntity | null {\n        const cachedAccount = this.getItem(accountKey);\n        return cachedAccount\n            ? Object.assign(new AccountEntity(), this.getItem(accountKey))\n            : null;\n    }\n\n    /**\n     * set account entity\n     * @param account - cache value to be set of type AccountEntity\n     */\n    async setAccount(account: AccountEntity): Promise<void> {\n        const accountKey = account.generateAccountKey();\n        this.setItem(accountKey, account);\n    }\n\n    /**\n     * fetch the idToken credential\n     * @param idTokenKey - lookup key to fetch cache type IdTokenEntity\n     */\n    getIdTokenCredential(idTokenKey: string): IdTokenEntity | null {\n        const idToken = this.getItem(idTokenKey) as IdTokenEntity;\n        if (CacheHelpers.isIdTokenEntity(idToken)) {\n            return idToken;\n        }\n        return null;\n    }\n\n    /**\n     * set idToken credential\n     * @param idToken - cache value to be set of type IdTokenEntity\n     */\n    async setIdTokenCredential(idToken: IdTokenEntity): Promise<void> {\n        const idTokenKey = CacheHelpers.generateCredentialKey(idToken);\n        this.setItem(idTokenKey, idToken);\n    }\n\n    /**\n     * fetch the accessToken credential\n     * @param accessTokenKey - lookup key to fetch cache type AccessTokenEntity\n     */\n    getAccessTokenCredential(accessTokenKey: string): AccessTokenEntity | null {\n        const accessToken = this.getItem(accessTokenKey) as AccessTokenEntity;\n        if (CacheHelpers.isAccessTokenEntity(accessToken)) {\n            return accessToken;\n        }\n        return null;\n    }\n\n    /**\n     * set accessToken credential\n     * @param accessToken -  cache value to be set of type AccessTokenEntity\n     */\n    async setAccessTokenCredential(\n        accessToken: AccessTokenEntity\n    ): Promise<void> {\n        const accessTokenKey = CacheHelpers.generateCredentialKey(accessToken);\n        this.setItem(accessTokenKey, accessToken);\n    }\n\n    /**\n     * fetch the refreshToken credential\n     * @param refreshTokenKey - lookup key to fetch cache type RefreshTokenEntity\n     */\n    getRefreshTokenCredential(\n        refreshTokenKey: string\n    ): RefreshTokenEntity | null {\n        const refreshToken = this.getItem(\n            refreshTokenKey\n        ) as RefreshTokenEntity;\n        if (CacheHelpers.isRefreshTokenEntity(refreshToken)) {\n            return refreshToken as RefreshTokenEntity;\n        }\n        return null;\n    }\n\n    /**\n     * set refreshToken credential\n     * @param refreshToken - cache value to be set of type RefreshTokenEntity\n     */\n    async setRefreshTokenCredential(\n        refreshToken: RefreshTokenEntity\n    ): Promise<void> {\n        const refreshTokenKey =\n            CacheHelpers.generateCredentialKey(refreshToken);\n        this.setItem(refreshTokenKey, refreshToken);\n    }\n\n    /**\n     * fetch appMetadata entity from the platform cache\n     * @param appMetadataKey - lookup key to fetch cache type AppMetadataEntity\n     */\n    getAppMetadata(appMetadataKey: string): AppMetadataEntity | null {\n        const appMetadata: AppMetadataEntity = this.getItem(\n            appMetadataKey\n        ) as AppMetadataEntity;\n        if (CacheHelpers.isAppMetadataEntity(appMetadataKey, appMetadata)) {\n            return appMetadata;\n        }\n        return null;\n    }\n\n    /**\n     * set appMetadata entity to the platform cache\n     * @param appMetadata - cache value to be set of type AppMetadataEntity\n     */\n    setAppMetadata(appMetadata: AppMetadataEntity): void {\n        const appMetadataKey = CacheHelpers.generateAppMetadataKey(appMetadata);\n        this.setItem(appMetadataKey, appMetadata);\n    }\n\n    /**\n     * fetch server telemetry entity from the platform cache\n     * @param serverTelemetrykey - lookup key to fetch cache type ServerTelemetryEntity\n     */\n    getServerTelemetry(\n        serverTelemetrykey: string\n    ): ServerTelemetryEntity | null {\n        const serverTelemetryEntity: ServerTelemetryEntity = this.getItem(\n            serverTelemetrykey\n        ) as ServerTelemetryEntity;\n        if (\n            serverTelemetryEntity &&\n            CacheHelpers.isServerTelemetryEntity(\n                serverTelemetrykey,\n                serverTelemetryEntity\n            )\n        ) {\n            return serverTelemetryEntity;\n        }\n        return null;\n    }\n\n    /**\n     * set server telemetry entity to the platform cache\n     * @param serverTelemetryKey - lookup key to fetch cache type ServerTelemetryEntity\n     * @param serverTelemetry - cache value to be set of type ServerTelemetryEntity\n     */\n    setServerTelemetry(\n        serverTelemetryKey: string,\n        serverTelemetry: ServerTelemetryEntity\n    ): void {\n        this.setItem(serverTelemetryKey, serverTelemetry);\n    }\n\n    /**\n     * fetch authority metadata entity from the platform cache\n     * @param key - lookup key to fetch cache type AuthorityMetadataEntity\n     */\n    getAuthorityMetadata(key: string): AuthorityMetadataEntity | null {\n        const authorityMetadataEntity: AuthorityMetadataEntity = this.getItem(\n            key\n        ) as AuthorityMetadataEntity;\n        if (\n            authorityMetadataEntity &&\n            CacheHelpers.isAuthorityMetadataEntity(key, authorityMetadataEntity)\n        ) {\n            return authorityMetadataEntity;\n        }\n        return null;\n    }\n\n    /**\n     * Get all authority metadata keys\n     */\n    getAuthorityMetadataKeys(): Array<string> {\n        return this.getKeys().filter((key) => {\n            return this.isAuthorityMetadata(key);\n        });\n    }\n\n    /**\n     * set authority metadata entity to the platform cache\n     * @param key - lookup key to fetch cache type AuthorityMetadataEntity\n     * @param metadata - cache value to be set of type AuthorityMetadataEntity\n     */\n    setAuthorityMetadata(key: string, metadata: AuthorityMetadataEntity): void {\n        this.setItem(key, metadata);\n    }\n\n    /**\n     * fetch throttling entity from the platform cache\n     * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity\n     */\n    getThrottlingCache(throttlingCacheKey: string): ThrottlingEntity | null {\n        const throttlingCache: ThrottlingEntity = this.getItem(\n            throttlingCacheKey\n        ) as ThrottlingEntity;\n        if (\n            throttlingCache &&\n            CacheHelpers.isThrottlingEntity(throttlingCacheKey, throttlingCache)\n        ) {\n            return throttlingCache;\n        }\n        return null;\n    }\n\n    /**\n     * set throttling entity to the platform cache\n     * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity\n     * @param throttlingCache - cache value to be set of type ThrottlingEntity\n     */\n    setThrottlingCache(\n        throttlingCacheKey: string,\n        throttlingCache: ThrottlingEntity\n    ): void {\n        this.setItem(throttlingCacheKey, throttlingCache);\n    }\n\n    /**\n     * Removes the cache item from memory with the given key.\n     * @param key - lookup key to remove a cache entity\n     * @param inMemory - key value map of the cache\n     */\n    removeItem(key: string): boolean {\n        this.logger.tracePii(`Item key: ${key}`);\n\n        // read inMemoryCache\n        let result: boolean = false;\n        const cache = this.getCache();\n\n        if (!!cache[key]) {\n            delete cache[key];\n            result = true;\n        }\n\n        // write to the cache after removal\n        if (result) {\n            this.setCache(cache);\n            this.emitChange();\n        }\n        return result;\n    }\n\n    /**\n     * Remove account entity from the platform cache if it's outdated\n     * @param accountKey - lookup key to fetch cache type AccountEntity\n     */\n    removeOutdatedAccount(accountKey: string): void {\n        this.removeItem(accountKey);\n    }\n\n    /**\n     * Checks whether key is in cache.\n     * @param key - look up key for a cache entity\n     */\n    containsKey(key: string): boolean {\n        return this.getKeys().includes(key);\n    }\n\n    /**\n     * Gets all keys in window.\n     */\n    getKeys(): string[] {\n        this.logger.trace(\"Retrieving all cache keys\");\n\n        // read cache\n        const cache = this.getCache();\n        return [...Object.keys(cache)];\n    }\n\n    /**\n     * Clears all cache entries created by MSAL (except tokens).\n     */\n    clear(): void {\n        this.logger.trace(\"Clearing cache entries created by MSAL\");\n\n        // read inMemoryCache\n        const cacheKeys = this.getKeys();\n\n        // delete each element\n        cacheKeys.forEach((key) => {\n            this.removeItem(key);\n        });\n        this.emitChange();\n    }\n\n    /**\n     * Initialize in memory cache from an exisiting cache vault\n     * @param cache - blob formatted cache (JSON)\n     */\n    static generateInMemoryCache(cache: string): InMemoryCache {\n        return Deserializer.deserializeAllCache(\n            Deserializer.deserializeJSONBlob(cache)\n        );\n    }\n\n    /**\n     * retrieves the final JSON\n     * @param inMemoryCache - itemised cache read from the JSON\n     */\n    static generateJsonCache(inMemoryCache: InMemoryCache): JsonCache {\n        return Serializer.serializeAllCache(inMemoryCache);\n    }\n\n    /**\n     * Updates a credential's cache key if the current cache key is outdated\n     */\n    updateCredentialCacheKey(\n        currentCacheKey: string,\n        credential: ValidCredentialType\n    ): string {\n        const updatedCacheKey = CacheHelpers.generateCredentialKey(credential);\n\n        if (currentCacheKey !== updatedCacheKey) {\n            const cacheItem = this.getItem(currentCacheKey);\n            if (cacheItem) {\n                this.removeItem(currentCacheKey);\n                this.setItem(updatedCacheKey, cacheItem);\n                this.logger.verbose(\n                    `Updated an outdated ${credential.credentialType} cache key`\n                );\n                return updatedCacheKey;\n            } else {\n                this.logger.error(\n                    `Attempted to update an outdated ${credential.credentialType} cache key but no item matching the outdated key was found in storage`\n                );\n            }\n        }\n\n        return currentCacheKey;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1888, "column": 0}, "map": {"version":3,"file":"TokenCache.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/cache/TokenCache.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { NodeStorage } from \"./NodeStorage.js\";\nimport {\n    AccountEntity,\n    AccountInfo,\n    Logger,\n    ISerializableTokenCache,\n    ICachePlugin,\n    TokenCacheContext,\n} from \"@azure/msal-common/node\";\nimport {\n    InMemoryCache,\n    JsonCache,\n    SerializedAccountEntity,\n    SerializedAccessTokenEntity,\n    SerializedRefreshTokenEntity,\n    SerializedIdTokenEntity,\n    SerializedAppMetadataEntity,\n    CacheKVStore,\n} from \"./serializer/SerializerTypes.js\";\nimport { Deserializer } from \"./serializer/Deserializer.js\";\nimport { Serializer } from \"./serializer/Serializer.js\";\nimport { ITokenCache } from \"./ITokenCache.js\";\nimport { GuidGenerator } from \"../crypto/GuidGenerator.js\";\n\nconst defaultSerializedCache: JsonCache = {\n    Account: {},\n    IdToken: {},\n    AccessToken: {},\n    RefreshToken: {},\n    AppMetadata: {},\n};\n\n/**\n * In-memory token cache manager\n * @public\n */\nexport class TokenCache implements ISerializableTokenCache, ITokenCache {\n    private storage: NodeStorage;\n    private cacheHasChanged: boolean;\n    private cacheSnapshot: string;\n    public readonly persistence: ICachePlugin;\n    private logger: Logger;\n\n    constructor(\n        storage: NodeStorage,\n        logger: Logger,\n        cachePlugin?: ICachePlugin\n    ) {\n        this.cacheHasChanged = false;\n        this.storage = storage;\n        this.storage.registerChangeEmitter(this.handleChangeEvent.bind(this));\n        if (cachePlugin) {\n            this.persistence = cachePlugin;\n        }\n        this.logger = logger;\n    }\n\n    /**\n     * Set to true if cache state has changed since last time serialize or writeToPersistence was called\n     */\n    hasChanged(): boolean {\n        return this.cacheHasChanged;\n    }\n\n    /**\n     * Serializes in memory cache to JSON\n     */\n    serialize(): string {\n        this.logger.trace(\"Serializing in-memory cache\");\n        let finalState = Serializer.serializeAllCache(\n            this.storage.getInMemoryCache() as InMemoryCache\n        );\n\n        // if cacheSnapshot not null or empty, merge\n        if (this.cacheSnapshot) {\n            this.logger.trace(\"Reading cache snapshot from disk\");\n            finalState = this.mergeState(\n                JSON.parse(this.cacheSnapshot),\n                finalState\n            );\n        } else {\n            this.logger.trace(\"No cache snapshot to merge\");\n        }\n        this.cacheHasChanged = false;\n\n        return JSON.stringify(finalState);\n    }\n\n    /**\n     * Deserializes JSON to in-memory cache. JSON should be in MSAL cache schema format\n     * @param cache - blob formatted cache\n     */\n    deserialize(cache: string): void {\n        this.logger.trace(\"Deserializing JSON to in-memory cache\");\n        this.cacheSnapshot = cache;\n\n        if (this.cacheSnapshot) {\n            this.logger.trace(\"Reading cache snapshot from disk\");\n            const deserializedCache = Deserializer.deserializeAllCache(\n                this.overlayDefaults(JSON.parse(this.cacheSnapshot))\n            );\n            this.storage.setInMemoryCache(deserializedCache);\n        } else {\n            this.logger.trace(\"No cache snapshot to deserialize\");\n        }\n    }\n\n    /**\n     * Fetches the cache key-value map\n     */\n    getKVStore(): CacheKVStore {\n        return this.storage.getCache();\n    }\n\n    /**\n     * Gets cache snapshot in CacheKVStore format\n     */\n    getCacheSnapshot(): CacheKVStore {\n        const deserializedPersistentStorage = NodeStorage.generateInMemoryCache(\n            this.cacheSnapshot\n        );\n        return this.storage.inMemoryCacheToCache(deserializedPersistentStorage);\n    }\n\n    /**\n     * API that retrieves all accounts currently in cache to the user\n     */\n    async getAllAccounts(): Promise<AccountInfo[]> {\n        this.logger.trace(\"getAllAccounts called\");\n        let cacheContext;\n        try {\n            if (this.persistence) {\n                cacheContext = new TokenCacheContext(this, false);\n                await this.persistence.beforeCacheAccess(cacheContext);\n            }\n            return this.storage.getAllAccounts();\n        } finally {\n            if (this.persistence && cacheContext) {\n                await this.persistence.afterCacheAccess(cacheContext);\n            }\n        }\n    }\n\n    /**\n     * Returns the signed in account matching homeAccountId.\n     * (the account object is created at the time of successful login)\n     * or null when no matching account is found\n     * @param homeAccountId - unique identifier for an account (uid.utid)\n     */\n    async getAccountByHomeId(\n        homeAccountId: string\n    ): Promise<AccountInfo | null> {\n        const allAccounts = await this.getAllAccounts();\n        if (homeAccountId && allAccounts && allAccounts.length) {\n            return (\n                allAccounts.filter(\n                    (accountObj) => accountObj.homeAccountId === homeAccountId\n                )[0] || null\n            );\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the signed in account matching localAccountId.\n     * (the account object is created at the time of successful login)\n     * or null when no matching account is found\n     * @param localAccountId - unique identifier of an account (sub/obj when homeAccountId cannot be populated)\n     */\n    async getAccountByLocalId(\n        localAccountId: string\n    ): Promise<AccountInfo | null> {\n        const allAccounts = await this.getAllAccounts();\n        if (localAccountId && allAccounts && allAccounts.length) {\n            return (\n                allAccounts.filter(\n                    (accountObj) => accountObj.localAccountId === localAccountId\n                )[0] || null\n            );\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * API to remove a specific account and the relevant data from cache\n     * @param account - AccountInfo passed by the user\n     */\n    async removeAccount(\n        account: AccountInfo,\n        correlationId?: string\n    ): Promise<void> {\n        this.logger.trace(\"removeAccount called\");\n        let cacheContext;\n        try {\n            if (this.persistence) {\n                cacheContext = new TokenCacheContext(this, true);\n                await this.persistence.beforeCacheAccess(cacheContext);\n            }\n            this.storage.removeAccount(\n                AccountEntity.generateAccountCacheKey(account),\n                correlationId || new GuidGenerator().generateGuid()\n            );\n        } finally {\n            if (this.persistence && cacheContext) {\n                await this.persistence.afterCacheAccess(cacheContext);\n            }\n        }\n    }\n\n    /**\n     * Overwrites in-memory cache with persistent cache\n     */\n    async overwriteCache(): Promise<void> {\n        if (!this.persistence) {\n            this.logger.info(\n                \"No persistence layer specified, cache cannot be overwritten\"\n            );\n            return;\n        }\n        this.logger.info(\"Overwriting in-memory cache with persistent cache\");\n        this.storage.clear();\n        const cacheContext = new TokenCacheContext(this, false);\n        await this.persistence.beforeCacheAccess(cacheContext);\n        const cacheSnapshot = this.getCacheSnapshot();\n        this.storage.setCache(cacheSnapshot);\n        await this.persistence.afterCacheAccess(cacheContext);\n    }\n\n    /**\n     * Called when the cache has changed state.\n     */\n    private handleChangeEvent() {\n        this.cacheHasChanged = true;\n    }\n\n    /**\n     * Merge in memory cache with the cache snapshot.\n     * @param oldState - cache before changes\n     * @param currentState - current cache state in the library\n     */\n    private mergeState(\n        oldState: JsonCache,\n        currentState: JsonCache\n    ): JsonCache {\n        this.logger.trace(\"Merging in-memory cache with cache snapshot\");\n        const stateAfterRemoval = this.mergeRemovals(oldState, currentState);\n        return this.mergeUpdates(stateAfterRemoval, currentState);\n    }\n\n    /**\n     * Deep update of oldState based on newState values\n     * @param oldState - cache before changes\n     * @param newState - updated cache\n     */\n    private mergeUpdates(oldState: object, newState: object): JsonCache {\n        Object.keys(newState).forEach((newKey: string) => {\n            const newValue = newState[newKey];\n\n            // if oldState does not contain value but newValue does, add it\n            if (!oldState.hasOwnProperty(newKey)) {\n                if (newValue !== null) {\n                    oldState[newKey] = newValue;\n                }\n            } else {\n                // both oldState and newState contain the key, do deep update\n                const newValueNotNull = newValue !== null;\n                const newValueIsObject = typeof newValue === \"object\";\n                const newValueIsNotArray = !Array.isArray(newValue);\n                const oldStateNotUndefinedOrNull =\n                    typeof oldState[newKey] !== \"undefined\" &&\n                    oldState[newKey] !== null;\n\n                if (\n                    newValueNotNull &&\n                    newValueIsObject &&\n                    newValueIsNotArray &&\n                    oldStateNotUndefinedOrNull\n                ) {\n                    this.mergeUpdates(oldState[newKey], newValue);\n                } else {\n                    oldState[newKey] = newValue;\n                }\n            }\n        });\n\n        return oldState as JsonCache;\n    }\n\n    /**\n     * Removes entities in oldState that the were removed from newState. If there are any unknown values in root of\n     * oldState that are not recognized, they are left untouched.\n     * @param oldState - cache before changes\n     * @param newState - updated cache\n     */\n    private mergeRemovals(oldState: JsonCache, newState: JsonCache): JsonCache {\n        this.logger.trace(\"Remove updated entries in cache\");\n        const accounts = oldState.Account\n            ? this.mergeRemovalsDict<SerializedAccountEntity>(\n                  oldState.Account,\n                  newState.Account\n              )\n            : oldState.Account;\n        const accessTokens = oldState.AccessToken\n            ? this.mergeRemovalsDict<SerializedAccessTokenEntity>(\n                  oldState.AccessToken,\n                  newState.AccessToken\n              )\n            : oldState.AccessToken;\n        const refreshTokens = oldState.RefreshToken\n            ? this.mergeRemovalsDict<SerializedRefreshTokenEntity>(\n                  oldState.RefreshToken,\n                  newState.RefreshToken\n              )\n            : oldState.RefreshToken;\n        const idTokens = oldState.IdToken\n            ? this.mergeRemovalsDict<SerializedIdTokenEntity>(\n                  oldState.IdToken,\n                  newState.IdToken\n              )\n            : oldState.IdToken;\n        const appMetadata = oldState.AppMetadata\n            ? this.mergeRemovalsDict<SerializedAppMetadataEntity>(\n                  oldState.AppMetadata,\n                  newState.AppMetadata\n              )\n            : oldState.AppMetadata;\n\n        return {\n            ...oldState,\n            Account: accounts,\n            AccessToken: accessTokens,\n            RefreshToken: refreshTokens,\n            IdToken: idTokens,\n            AppMetadata: appMetadata,\n        };\n    }\n\n    /**\n     * Helper to merge new cache with the old one\n     * @param oldState - cache before changes\n     * @param newState - updated cache\n     */\n    private mergeRemovalsDict<T>(\n        oldState: Record<string, T>,\n        newState?: Record<string, T>\n    ): Record<string, T> {\n        const finalState = { ...oldState };\n        Object.keys(oldState).forEach((oldKey) => {\n            if (!newState || !newState.hasOwnProperty(oldKey)) {\n                delete finalState[oldKey];\n            }\n        });\n        return finalState;\n    }\n\n    /**\n     * Helper to overlay as a part of cache merge\n     * @param passedInCache - cache read from the blob\n     */\n    private overlayDefaults(passedInCache: JsonCache): JsonCache {\n        this.logger.trace(\"Overlaying input cache with the default cache\");\n        return {\n            Account: {\n                ...defaultSerializedCache.Account,\n                ...passedInCache.Account,\n            },\n            IdToken: {\n                ...defaultSerializedCache.IdToken,\n                ...passedInCache.IdToken,\n            },\n            AccessToken: {\n                ...defaultSerializedCache.AccessToken,\n                ...passedInCache.AccessToken,\n            },\n            RefreshToken: {\n                ...defaultSerializedCache.RefreshToken,\n                ...passedInCache.RefreshToken,\n            },\n            AppMetadata: {\n                ...defaultSerializedCache.AppMetadata,\n                ...passedInCache.AppMetadata,\n            },\n        };\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2161, "column": 0}, "map": {"version":3,"file":"ClientAssertion.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/client/ClientAssertion.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport jwt from \"jsonwebtoken\";\nimport {\n    TimeUtils,\n    Constants,\n    createClientAuthError,\n    ClientAuthErrorCodes,\n    EncodingTypes,\n} from \"@azure/msal-common/node\";\nimport { CryptoProvider } from \"../crypto/CryptoProvider.js\";\nimport { EncodingUtils } from \"../utils/EncodingUtils.js\";\nimport { JwtConstants } from \"../utils/Constants.js\";\n\n/**\n * Client assertion of type jwt-bearer used in confidential client flows\n * @public\n */\nexport class ClientAssertion {\n    private jwt: string;\n    private privateKey: string;\n    private thumbprint: string;\n    private useSha256: boolean;\n    private expirationTime: number;\n    private issuer: string;\n    private jwtAudience: string;\n    private publicCertificate: Array<string>;\n\n    /**\n     * Initialize the ClientAssertion class from the clientAssertion passed by the user\n     * @param assertion - refer https://tools.ietf.org/html/rfc7521\n     */\n    public static fromAssertion(assertion: string): ClientAssertion {\n        const clientAssertion = new ClientAssertion();\n        clientAssertion.jwt = assertion;\n        return clientAssertion;\n    }\n\n    /**\n     * @deprecated Use fromCertificateWithSha256Thumbprint instead, with a SHA-256 thumprint\n     * Initialize the ClientAssertion class from the certificate passed by the user\n     * @param thumbprint - identifier of a certificate\n     * @param privateKey - secret key\n     * @param publicCertificate - electronic document provided to prove the ownership of the public key\n     */\n    public static fromCertificate(\n        thumbprint: string,\n        privateKey: string,\n        publicCertificate?: string\n    ): ClientAssertion {\n        const clientAssertion = new ClientAssertion();\n        clientAssertion.privateKey = privateKey;\n        clientAssertion.thumbprint = thumbprint;\n        clientAssertion.useSha256 = false;\n        if (publicCertificate) {\n            clientAssertion.publicCertificate =\n                this.parseCertificate(publicCertificate);\n        }\n        return clientAssertion;\n    }\n\n    /**\n     * Initialize the ClientAssertion class from the certificate passed by the user\n     * @param thumbprint - identifier of a certificate\n     * @param privateKey - secret key\n     * @param publicCertificate - electronic document provided to prove the ownership of the public key\n     */\n    public static fromCertificateWithSha256Thumbprint(\n        thumbprint: string,\n        privateKey: string,\n        publicCertificate?: string\n    ): ClientAssertion {\n        const clientAssertion = new ClientAssertion();\n        clientAssertion.privateKey = privateKey;\n        clientAssertion.thumbprint = thumbprint;\n        clientAssertion.useSha256 = true;\n        if (publicCertificate) {\n            clientAssertion.publicCertificate =\n                this.parseCertificate(publicCertificate);\n        }\n        return clientAssertion;\n    }\n\n    /**\n     * Update JWT for certificate based clientAssertion, if passed by the user, uses it as is\n     * @param cryptoProvider - library's crypto helper\n     * @param issuer - iss claim\n     * @param jwtAudience - aud claim\n     */\n    public getJwt(\n        cryptoProvider: CryptoProvider,\n        issuer: string,\n        jwtAudience: string\n    ): string {\n        // if assertion was created from certificate, check if jwt is expired and create new one.\n        if (this.privateKey && this.thumbprint) {\n            if (\n                this.jwt &&\n                !this.isExpired() &&\n                issuer === this.issuer &&\n                jwtAudience === this.jwtAudience\n            ) {\n                return this.jwt;\n            }\n\n            return this.createJwt(cryptoProvider, issuer, jwtAudience);\n        }\n\n        /*\n         * if assertion was created by caller, then we just append it. It is up to the caller to\n         * ensure that it contains necessary claims and that it is not expired.\n         */\n        if (this.jwt) {\n            return this.jwt;\n        }\n\n        throw createClientAuthError(ClientAuthErrorCodes.invalidAssertion);\n    }\n\n    /**\n     * JWT format and required claims specified: https://tools.ietf.org/html/rfc7523#section-3\n     */\n    private createJwt(\n        cryptoProvider: CryptoProvider,\n        issuer: string,\n        jwtAudience: string\n    ): string {\n        this.issuer = issuer;\n        this.jwtAudience = jwtAudience;\n        const issuedAt = TimeUtils.nowSeconds();\n        this.expirationTime = issuedAt + 600;\n\n        const algorithm = this.useSha256\n            ? JwtConstants.PSS_256\n            : JwtConstants.RSA_256;\n        const header: jwt.JwtHeader = {\n            alg: algorithm,\n        };\n\n        const thumbprintHeader = this.useSha256\n            ? JwtConstants.X5T_256\n            : JwtConstants.X5T;\n        Object.assign(header, {\n            [thumbprintHeader]: EncodingUtils.base64EncodeUrl(\n                this.thumbprint,\n                EncodingTypes.HEX\n            ),\n        } as Partial<jwt.JwtHeader>);\n\n        if (this.publicCertificate) {\n            Object.assign(header, {\n                [JwtConstants.X5C]: this.publicCertificate,\n            } as Partial<jwt.JwtHeader>);\n        }\n\n        const payload = {\n            [JwtConstants.AUDIENCE]: this.jwtAudience,\n            [JwtConstants.EXPIRATION_TIME]: this.expirationTime,\n            [JwtConstants.ISSUER]: this.issuer,\n            [JwtConstants.SUBJECT]: this.issuer,\n            [JwtConstants.NOT_BEFORE]: issuedAt,\n            [JwtConstants.JWT_ID]: cryptoProvider.createNewGuid(),\n        };\n\n        this.jwt = jwt.sign(payload, this.privateKey, { header });\n        return this.jwt;\n    }\n\n    /**\n     * Utility API to check expiration\n     */\n    private isExpired(): boolean {\n        return this.expirationTime < TimeUtils.nowSeconds();\n    }\n\n    /**\n     * Extracts the raw certs from a given certificate string and returns them in an array.\n     * @param publicCertificate - electronic document provided to prove the ownership of the public key\n     */\n    public static parseCertificate(publicCertificate: string): Array<string> {\n        /**\n         * This is regex to identify the certs in a given certificate string.\n         * We want to look for the contents between the BEGIN and END certificate strings, without the associated newlines.\n         * The information in parens \"(.+?)\" is the capture group to represent the cert we want isolated.\n         * \".\" means any string character, \"+\" means match 1 or more times, and \"?\" means the shortest match.\n         * The \"g\" at the end of the regex means search the string globally, and the \"s\" enables the \".\" to match newlines.\n         */\n        const regexToFindCerts =\n            /-----BEGIN CERTIFICATE-----\\r*\\n(.+?)\\r*\\n-----END CERTIFICATE-----/gs;\n        const certs: string[] = [];\n\n        let matches;\n        while ((matches = regexToFindCerts.exec(publicCertificate)) !== null) {\n            // matches[1] represents the first parens capture group in the regex.\n            certs.push(matches[1].replace(/\\r*\\n/g, Constants.EMPTY_STRING));\n        }\n\n        return certs;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA;;;CAGG,GAcH;;;CAGG,SACU,eAAe,CAAA;IAUxB;;;KAGG,GACI,OAAO,aAAa,CAAC,SAAiB,EAAA;QACzC,MAAM,eAAe,GAAG,IAAI,eAAe,EAAE,CAAC;QAC9C,eAAe,CAAC,GAAG,GAAG,SAAS,CAAC;QAChC,OAAO,eAAe,CAAC;KAC1B;IAED;;;;;;KAMG,GACI,OAAO,eAAe,CACzB,UAAkB,EAClB,UAAkB,EAClB,iBAA0B,EAAA;QAE1B,MAAM,eAAe,GAAG,IAAI,eAAe,EAAE,CAAC;QAC9C,eAAe,CAAC,UAAU,GAAG,UAAU,CAAC;QACxC,eAAe,CAAC,UAAU,GAAG,UAAU,CAAC;QACxC,eAAe,CAAC,SAAS,GAAG,KAAK,CAAC;QAClC,IAAI,iBAAiB,EAAE;YACnB,eAAe,CAAC,iBAAiB,GAC7B,IAAI,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,CAAC;QAChD,CAAA;QACD,OAAO,eAAe,CAAC;KAC1B;IAED;;;;;KAKG,GACI,OAAO,mCAAmC,CAC7C,UAAkB,EAClB,UAAkB,EAClB,iBAA0B,EAAA;QAE1B,MAAM,eAAe,GAAG,IAAI,eAAe,EAAE,CAAC;QAC9C,eAAe,CAAC,UAAU,GAAG,UAAU,CAAC;QACxC,eAAe,CAAC,UAAU,GAAG,UAAU,CAAC;QACxC,eAAe,CAAC,SAAS,GAAG,IAAI,CAAC;QACjC,IAAI,iBAAiB,EAAE;YACnB,eAAe,CAAC,iBAAiB,GAC7B,IAAI,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,CAAC;QAChD,CAAA;QACD,OAAO,eAAe,CAAC;KAC1B;IAED;;;;;KAKG,GACI,MAAM,CACT,cAA8B,EAC9B,MAAc,EACd,WAAmB,EAAA;;QAGnB,IAAI,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,UAAU,EAAE;YACpC,IACI,IAAI,CAAC,GAAG,IACR,CAAC,IAAI,CAAC,SAAS,EAAE,IACjB,MAAM,KAAK,IAAI,CAAC,MAAM,IACtB,WAAW,KAAK,IAAI,CAAC,WAAW,EAClC;gBACE,OAAO,IAAI,CAAC,GAAG,CAAC;YACnB,CAAA;YAED,OAAO,IAAI,CAAC,SAAS,CAAC,cAAc,EAAE,MAAM,EAAE,WAAW,CAAC,CAAC;QAC9D,CAAA;QAED;;;SAGG,GACH,IAAI,IAAI,CAAC,GAAG,EAAE;YACV,OAAO,IAAI,CAAC,GAAG,CAAC;QACnB,CAAA;QAED,UAAM,uNAAA,AAAqB,sOAAC,uBAAoB,CAAC,gBAAgB,CAAC,CAAC;KACtE;IAED;;KAEG,GACK,SAAS,CACb,cAA8B,EAC9B,MAAc,EACd,WAAmB,EAAA;QAEnB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,MAAM,QAAQ,iNAAG,YAAS,CAAC,UAAU,EAAE,CAAC;QACxC,IAAI,CAAC,cAAc,GAAG,QAAQ,GAAG,GAAG,CAAC;QAErC,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,yKAC1B,gBAAY,CAAC,OAAO,0KACpB,eAAY,CAAC,OAAO,CAAC;QAC3B,MAAM,MAAM,GAAkB;YAC1B,GAAG,EAAE,SAAS;SACjB,CAAC;QAEF,MAAM,gBAAgB,GAAG,IAAI,CAAC,SAAS,0KACjC,eAAY,CAAC,OAAO,GACpB,sLAAY,CAAC,GAAG,CAAC;QACvB,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE;YAClB,CAAC,gBAAgB,CAAA,6KAAG,gBAAa,CAAC,eAAe,CAC7C,IAAI,CAAC,UAAU,2KACf,gBAAa,CAAC,GAAG,CACpB;QACsB,CAAA,CAAC,CAAC;QAE7B,IAAI,IAAI,CAAC,iBAAiB,EAAE;YACxB,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE;gBAClB,wKAAC,eAAY,CAAC,GAAG,CAAA,EAAG,IAAI,CAAC,iBAAiB;YACnB,CAAA,CAAC,CAAC;QAChC,CAAA;QAED,MAAM,OAAO,GAAG;YACZ,wKAAC,eAAY,CAAC,QAAQ,CAAA,EAAG,IAAI,CAAC,WAAW;YACzC,wKAAC,eAAY,CAAC,eAAe,CAAA,EAAG,IAAI,CAAC,cAAc;YACnD,wKAAC,eAAY,CAAC,MAAM,CAAA,EAAG,IAAI,CAAC,MAAM;YAClC,wKAAC,eAAY,CAAC,OAAO,CAAA,EAAG,IAAI,CAAC,MAAM;YACnC,wKAAC,eAAY,CAAC,UAAU,CAAA,EAAG,QAAQ;YACnC,wKAAC,eAAY,CAAC,MAAM,CAAA,EAAG,cAAc,CAAC,aAAa,EAAE;SACxD,CAAC;QAEF,IAAI,CAAC,GAAG,yIAAG,UAAG,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,UAAU,EAAE;YAAE,MAAM;QAAA,CAAE,CAAC,CAAC;QAC1D,OAAO,IAAI,CAAC,GAAG,CAAC;KACnB;IAED;;KAEG,GACK,SAAS,GAAA;QACb,OAAO,IAAI,CAAC,cAAc,iNAAG,YAAS,CAAC,UAAU,EAAE,CAAC;KACvD;IAED;;;KAGG,GACI,OAAO,gBAAgB,CAAC,iBAAyB,EAAA;QACpD;;;;;;SAMG,GACH,MAAM,gBAAgB,GAClB,uEAAuE,CAAC;QAC5E,MAAM,KAAK,GAAa,EAAE,CAAC;QAE3B,IAAI,OAAO,CAAC;QACZ,MAAO,CAAC,OAAO,GAAG,gBAAgB,CAAC,IAAI,CAAC,iBAAiB,CAAC,MAAM,IAAI,CAAE;;YAElE,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,2KAAE,YAAS,CAAC,YAAY,CAAC,CAAC,CAAC;QACpE,CAAA;QAED,OAAO,KAAK,CAAC;KAChB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2309, "column": 0}, "map": {"version":3,"file":"packageMetadata.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/packageMetadata.ts"],"sourcesContent":["/* eslint-disable header/header */\nexport const name = \"@azure/msal-node\";\nexport const version = \"3.6.1\";\n"],"names":[],"mappings":";;;;;AAAA,gCAAA,GACO,MAAM,IAAI,GAAG,mBAAmB;AAChC,MAAM,OAAO,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2324, "column": 0}, "map": {"version":3,"file":"UsernamePasswordClient.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/client/UsernamePasswordClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AuthenticationResult,\n    Authority,\n    BaseClient,\n    CcsCredentialType,\n    ClientAssertion,\n    ClientConfiguration,\n    CommonUsernamePasswordRequest,\n    GrantType,\n    NetworkResponse,\n    OAuthResponseType,\n    RequestParameterBuilder,\n    RequestThumbprint,\n    ResponseHandler,\n    ServerAuthorizationTokenResponse,\n    StringUtils,\n    TimeUtils,\n    UrlString,\n    UrlUtils,\n    getClientAssertion,\n} from \"@azure/msal-common/node\";\n\n/**\n * Oauth2.0 Password grant client\n * Note: We are only supporting public clients for password grant and for purely testing purposes\n * @public\n * @deprecated - Use a more secure flow instead\n */\nexport class UsernamePasswordClient extends BaseClient {\n    constructor(configuration: ClientConfiguration) {\n        super(configuration);\n    }\n\n    /**\n     * API to acquire a token by passing the username and password to the service in exchage of credentials\n     * password_grant\n     * @param request - CommonUsernamePasswordRequest\n     */\n    async acquireToken(\n        request: CommonUsernamePasswordRequest\n    ): Promise<AuthenticationResult | null> {\n        this.logger.info(\"in acquireToken call in username-password client\");\n\n        const reqTimestamp = TimeUtils.nowSeconds();\n        const response = await this.executeTokenRequest(\n            this.authority,\n            request\n        );\n\n        const responseHandler = new ResponseHandler(\n            this.config.authOptions.clientId,\n            this.cacheManager,\n            this.cryptoUtils,\n            this.logger,\n            this.config.serializableCache,\n            this.config.persistencePlugin\n        );\n\n        // Validate response. This function throws a server error if an error is returned by the server.\n        responseHandler.validateTokenResponse(response.body);\n        const tokenResponse = responseHandler.handleServerTokenResponse(\n            response.body,\n            this.authority,\n            reqTimestamp,\n            request\n        );\n\n        return tokenResponse;\n    }\n\n    /**\n     * Executes POST request to token endpoint\n     * @param authority - authority object\n     * @param request - CommonUsernamePasswordRequest provided by the developer\n     */\n    private async executeTokenRequest(\n        authority: Authority,\n        request: CommonUsernamePasswordRequest\n    ): Promise<NetworkResponse<ServerAuthorizationTokenResponse>> {\n        const queryParametersString = this.createTokenQueryParameters(request);\n        const endpoint = UrlString.appendQueryString(\n            authority.tokenEndpoint,\n            queryParametersString\n        );\n        const requestBody = await this.createTokenRequestBody(request);\n        const headers: Record<string, string> = this.createTokenRequestHeaders({\n            credential: request.username,\n            type: CcsCredentialType.UPN,\n        });\n        const thumbprint: RequestThumbprint = {\n            clientId: this.config.authOptions.clientId,\n            authority: authority.canonicalAuthority,\n            scopes: request.scopes,\n            claims: request.claims,\n            authenticationScheme: request.authenticationScheme,\n            resourceRequestMethod: request.resourceRequestMethod,\n            resourceRequestUri: request.resourceRequestUri,\n            shrClaims: request.shrClaims,\n            sshKid: request.sshKid,\n        };\n\n        return this.executePostToTokenEndpoint(\n            endpoint,\n            requestBody,\n            headers,\n            thumbprint,\n            request.correlationId\n        );\n    }\n\n    /**\n     * Generates a map for all the params to be sent to the service\n     * @param request - CommonUsernamePasswordRequest provided by the developer\n     */\n    private async createTokenRequestBody(\n        request: CommonUsernamePasswordRequest\n    ): Promise<string> {\n        const parameters = new Map<string, string>();\n\n        RequestParameterBuilder.addClientId(\n            parameters,\n            this.config.authOptions.clientId\n        );\n        RequestParameterBuilder.addUsername(parameters, request.username);\n        RequestParameterBuilder.addPassword(parameters, request.password);\n\n        RequestParameterBuilder.addScopes(parameters, request.scopes);\n\n        RequestParameterBuilder.addResponseType(\n            parameters,\n            OAuthResponseType.IDTOKEN_TOKEN\n        );\n\n        RequestParameterBuilder.addGrantType(\n            parameters,\n            GrantType.RESOURCE_OWNER_PASSWORD_GRANT\n        );\n        RequestParameterBuilder.addClientInfo(parameters);\n\n        RequestParameterBuilder.addLibraryInfo(\n            parameters,\n            this.config.libraryInfo\n        );\n        RequestParameterBuilder.addApplicationTelemetry(\n            parameters,\n            this.config.telemetry.application\n        );\n        RequestParameterBuilder.addThrottling(parameters);\n\n        if (this.serverTelemetryManager) {\n            RequestParameterBuilder.addServerTelemetry(\n                parameters,\n                this.serverTelemetryManager\n            );\n        }\n\n        const correlationId =\n            request.correlationId ||\n            this.config.cryptoInterface.createNewGuid();\n        RequestParameterBuilder.addCorrelationId(parameters, correlationId);\n\n        if (this.config.clientCredentials.clientSecret) {\n            RequestParameterBuilder.addClientSecret(\n                parameters,\n                this.config.clientCredentials.clientSecret\n            );\n        }\n\n        const clientAssertion: ClientAssertion | undefined =\n            this.config.clientCredentials.clientAssertion;\n\n        if (clientAssertion) {\n            RequestParameterBuilder.addClientAssertion(\n                parameters,\n                await getClientAssertion(\n                    clientAssertion.assertion,\n                    this.config.authOptions.clientId,\n                    request.resourceRequestUri\n                )\n            );\n            RequestParameterBuilder.addClientAssertionType(\n                parameters,\n                clientAssertion.assertionType\n            );\n        }\n\n        if (\n            !StringUtils.isEmptyObj(request.claims) ||\n            (this.config.authOptions.clientCapabilities &&\n                this.config.authOptions.clientCapabilities.length > 0)\n        ) {\n            RequestParameterBuilder.addClaims(\n                parameters,\n                request.claims,\n                this.config.authOptions.clientCapabilities\n            );\n        }\n\n        if (\n            this.config.systemOptions.preventCorsPreflight &&\n            request.username\n        ) {\n            RequestParameterBuilder.addCcsUpn(parameters, request.username);\n        }\n\n        return UrlUtils.mapToQueryString(parameters);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2435, "column": 0}, "map": {"version":3,"file":"Authorize.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/protocol/Authorize.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    Authority,\n    AuthorizeProtocol,\n    CommonAuthorizationUrlRequest,\n    Logger,\n    OAuthResponseType,\n    ProtocolMode,\n    RequestParameterBuilder,\n} from \"@azure/msal-common/node\";\nimport { NodeConfiguration } from \"../config/Configuration.js\";\nimport { Constants as NodeConstants } from \"../utils/Constants.js\";\nimport { version } from \"../packageMetadata.js\";\n\n/**\n * Constructs the full /authorize URL with request parameters\n * @param config\n * @param authority\n * @param request\n * @param logger\n * @returns\n */\nexport function getAuthCodeRequestUrl(\n    config: NodeConfiguration,\n    authority: Authority,\n    request: CommonAuthorizationUrlRequest,\n    logger: Logger\n): string {\n    const parameters = AuthorizeProtocol.getStandardAuthorizeRequestParameters(\n        {\n            ...config.auth,\n            authority: authority,\n            redirectUri: request.redirectUri || \"\",\n        },\n        request,\n        logger\n    );\n    RequestParameterBuilder.addLibraryInfo(parameters, {\n        sku: NodeConstants.MSAL_SKU,\n        version: version,\n        cpu: process.arch || \"\",\n        os: process.platform || \"\",\n    });\n    if (config.auth.protocolMode !== ProtocolMode.OIDC) {\n        RequestParameterBuilder.addApplicationTelemetry(\n            parameters,\n            config.telemetry.application\n        );\n    }\n    RequestParameterBuilder.addResponseType(parameters, OAuthResponseType.CODE);\n    if (request.codeChallenge && request.codeChallengeMethod) {\n        RequestParameterBuilder.addCodeChallengeParams(\n            parameters,\n            request.codeChallenge,\n            request.codeChallengeMethod\n        );\n    }\n\n    RequestParameterBuilder.addExtraQueryParameters(\n        parameters,\n        request.extraQueryParameters || {}\n    );\n\n    return AuthorizeProtocol.getAuthorizeUrl(\n        authority,\n        parameters,\n        config.auth.encodeExtraQueryParams,\n        request.extraQueryParameters\n    );\n}\n"],"names":["NodeConstants"],"mappings":";;;;;;;;;;;;;AAAA;;;CAGG,GAeH;;;;;;;CAOG,GACG,SAAU,qBAAqB,CACjC,MAAyB,EACzB,SAAoB,EACpB,OAAsC,EACtC,MAAc,EAAA;IAEd,MAAM,UAAU,4NAAG,oBAAiB,CAAC,qCAAqC,CACtE;QACI,GAAG,MAAM,CAAC,IAAI;QACd,SAAS,EAAE,SAAS;QACpB,WAAW,EAAE,OAAO,CAAC,WAAW,IAAI,EAAE;IACzC,CAAA,EACD,OAAO,EACP,MAAM,CACT,CAAC;gPACF,0BAAuB,CAAC,cAAc,CAAC,UAAU,EAAE;QAC/C,GAAG,yKAAEA,YAAa,CAAC,QAAQ;QAC3B,OAAO,sKAAE,UAAO;QAChB,GAAG,EAAE,OAAO,CAAC,IAAI,IAAI,EAAE;QACvB,EAAE,EAAE,OAAO,CAAC,QAAQ,IAAI,EAAE;IAC7B,CAAA,CAAC,CAAC;IACH,IAAI,MAAM,CAAC,IAAI,CAAC,YAAY,qLAAK,eAAY,CAAC,IAAI,EAAE;mPAChD,2BAAuB,CAAC,uBAAuB,CAC3C,UAAU,EACV,MAAM,CAAC,SAAS,CAAC,WAAW,CAC/B,CAAC;IACL,CAAA;gPACD,0BAAuB,CAAC,eAAe,CAAC,UAAU,0KAAE,qBAAiB,CAAC,IAAI,CAAC,CAAC;IAC5E,IAAI,OAAO,CAAC,aAAa,IAAI,OAAO,CAAC,mBAAmB,EAAE;oPACtD,0BAAuB,CAAC,sBAAsB,CAC1C,UAAU,EACV,OAAO,CAAC,aAAa,EACrB,OAAO,CAAC,mBAAmB,CAC9B,CAAC;IACL,CAAA;gPAED,0BAAuB,CAAC,uBAAuB,CAC3C,UAAU,EACV,OAAO,CAAC,oBAAoB,IAAI,CAAA,CAAE,CACrC,CAAC;IAEF,gOAAO,oBAAiB,CAAC,eAAe,CACpC,SAAS,EACT,UAAU,EACV,MAAM,CAAC,IAAI,CAAC,sBAAsB,EAClC,OAAO,CAAC,oBAAoB,CAC/B,CAAC;AACN","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2488, "column": 0}, "map": {"version":3,"file":"ClientApplication.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/client/ClientApplication.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AuthorizationCodeClient,\n    ClientConfiguration,\n    RefreshTokenClient,\n    AuthenticationResult,\n    Authority,\n    AuthorityFactory,\n    BaseAuthRequest,\n    SilentFlowClient,\n    Logger,\n    ServerTelemetryManager,\n    ServerTelemetryRequest,\n    CommonSilentFlowRequest,\n    CommonRefreshTokenRequest,\n    CommonAuthorizationCodeRequest,\n    CommonAuthorizationUrlRequest,\n    CommonUsernamePasswordRequest,\n    AuthenticationScheme,\n    ResponseMode,\n    AuthorityOptions,\n    OIDC_DEFAULT_SCOPES,\n    AzureRegionConfiguration,\n    AuthError,\n    AzureCloudOptions,\n    AuthorizationCodePayload,\n    Constants,\n    StringUtils,\n    createClientAuthError,\n    ClientAuthErrorCodes,\n    buildStaticAuthorityOptions,\n    ClientAssertion as ClientAssertionType,\n    getClientAssertion,\n    ClientAssertionCallback,\n    CacheOutcome,\n    ClientAuthError,\n} from \"@azure/msal-common/node\";\nimport {\n    Configuration,\n    buildAppConfiguration,\n    NodeConfiguration,\n} from \"../config/Configuration.js\";\nimport { CryptoProvider } from \"../crypto/CryptoProvider.js\";\nimport { NodeStorage } from \"../cache/NodeStorage.js\";\nimport { Constants as NodeConstants, ApiId } from \"../utils/Constants.js\";\nimport { TokenCache } from \"../cache/TokenCache.js\";\nimport { ClientAssertion } from \"./ClientAssertion.js\";\nimport { AuthorizationUrlRequest } from \"../request/AuthorizationUrlRequest.js\";\nimport { AuthorizationCodeRequest } from \"../request/AuthorizationCodeRequest.js\";\nimport { RefreshTokenRequest } from \"../request/RefreshTokenRequest.js\";\nimport { SilentFlowRequest } from \"../request/SilentFlowRequest.js\";\nimport { version, name } from \"../packageMetadata.js\";\nimport { UsernamePasswordRequest } from \"../request/UsernamePasswordRequest.js\";\nimport { NodeAuthError } from \"../error/NodeAuthError.js\";\nimport { UsernamePasswordClient } from \"./UsernamePasswordClient.js\";\nimport { getAuthCodeRequestUrl } from \"../protocol/Authorize.js\";\n\n/**\n * Base abstract class for all ClientApplications - public and confidential\n * @public\n */\nexport abstract class ClientApplication {\n    protected readonly cryptoProvider: CryptoProvider;\n    private tokenCache: TokenCache;\n\n    /**\n     * Platform storage object\n     */\n    protected storage: NodeStorage;\n    /**\n     * Logger object to log the application flow\n     */\n    protected logger: Logger;\n    /**\n     * Platform configuration initialized by the application\n     */\n    protected config: NodeConfiguration;\n    /**\n     * Client assertion passed by the user for confidential client flows\n     */\n    protected clientAssertion: ClientAssertion;\n    protected developerProvidedClientAssertion:\n        | string\n        | ClientAssertionCallback;\n    /**\n     * Client secret passed by the user for confidential client flows\n     */\n    protected clientSecret: string;\n\n    /**\n     * Constructor for the ClientApplication\n     */\n    protected constructor(configuration: Configuration) {\n        this.config = buildAppConfiguration(configuration);\n        this.cryptoProvider = new CryptoProvider();\n        this.logger = new Logger(\n            this.config.system.loggerOptions,\n            name,\n            version\n        );\n        this.storage = new NodeStorage(\n            this.logger,\n            this.config.auth.clientId,\n            this.cryptoProvider,\n            buildStaticAuthorityOptions(this.config.auth)\n        );\n        this.tokenCache = new TokenCache(\n            this.storage,\n            this.logger,\n            this.config.cache.cachePlugin\n        );\n    }\n\n    /**\n     * Creates the URL of the authorization request, letting the user input credentials and consent to the\n     * application. The URL targets the /authorize endpoint of the authority configured in the\n     * application object.\n     *\n     * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\n     * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\n     * `acquireTokenByCode(AuthorizationCodeRequest)`.\n     */\n    async getAuthCodeUrl(request: AuthorizationUrlRequest): Promise<string> {\n        this.logger.info(\"getAuthCodeUrl called\", request.correlationId);\n        const validRequest: CommonAuthorizationUrlRequest = {\n            ...request,\n            ...(await this.initializeBaseRequest(request)),\n            responseMode: request.responseMode || ResponseMode.QUERY,\n            authenticationScheme: AuthenticationScheme.BEARER,\n            state: request.state || \"\",\n            nonce: request.nonce || \"\",\n        };\n\n        const discoveredAuthority = await this.createAuthority(\n            validRequest.authority,\n            validRequest.correlationId,\n            undefined,\n            request.azureCloudOptions\n        );\n        return getAuthCodeRequestUrl(\n            this.config,\n            discoveredAuthority,\n            validRequest,\n            this.logger\n        );\n    }\n\n    /**\n     * Acquires a token by exchanging the Authorization Code received from the first step of OAuth2.0\n     * Authorization Code flow.\n     *\n     * `getAuthCodeUrl(AuthorizationCodeUrlRequest)` can be used to create the URL for the first step of OAuth2.0\n     * Authorization Code flow. Ensure that values for redirectUri and scopes in AuthorizationCodeUrlRequest and\n     * AuthorizationCodeRequest are the same.\n     */\n    async acquireTokenByCode(\n        request: AuthorizationCodeRequest,\n        authCodePayLoad?: AuthorizationCodePayload\n    ): Promise<AuthenticationResult> {\n        this.logger.info(\"acquireTokenByCode called\");\n        if (request.state && authCodePayLoad) {\n            this.logger.info(\"acquireTokenByCode - validating state\");\n            this.validateState(request.state, authCodePayLoad.state || \"\");\n            // eslint-disable-next-line no-param-reassign\n            authCodePayLoad = { ...authCodePayLoad, state: \"\" };\n        }\n        const validRequest: CommonAuthorizationCodeRequest = {\n            ...request,\n            ...(await this.initializeBaseRequest(request)),\n            authenticationScheme: AuthenticationScheme.BEARER,\n        };\n\n        const serverTelemetryManager = this.initializeServerTelemetryManager(\n            ApiId.acquireTokenByCode,\n            validRequest.correlationId\n        );\n        try {\n            const discoveredAuthority = await this.createAuthority(\n                validRequest.authority,\n                validRequest.correlationId,\n                undefined,\n                request.azureCloudOptions\n            );\n            const authClientConfig = await this.buildOauthClientConfiguration(\n                discoveredAuthority,\n                validRequest.correlationId,\n                validRequest.redirectUri,\n                serverTelemetryManager\n            );\n            const authorizationCodeClient = new AuthorizationCodeClient(\n                authClientConfig\n            );\n            this.logger.verbose(\n                \"Auth code client created\",\n                validRequest.correlationId\n            );\n            return await authorizationCodeClient.acquireToken(\n                validRequest,\n                authCodePayLoad\n            );\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(validRequest.correlationId);\n            }\n            serverTelemetryManager.cacheFailedRequest(e);\n            throw e;\n        }\n    }\n\n    /**\n     * Acquires a token by exchanging the refresh token provided for a new set of tokens.\n     *\n     * This API is provided only for scenarios where you would like to migrate from ADAL to MSAL. Otherwise, it is\n     * recommended that you use `acquireTokenSilent()` for silent scenarios. When using `acquireTokenSilent()`, MSAL will\n     * handle the caching and refreshing of tokens automatically.\n     */\n    async acquireTokenByRefreshToken(\n        request: RefreshTokenRequest\n    ): Promise<AuthenticationResult | null> {\n        this.logger.info(\n            \"acquireTokenByRefreshToken called\",\n            request.correlationId\n        );\n        const validRequest: CommonRefreshTokenRequest = {\n            ...request,\n            ...(await this.initializeBaseRequest(request)),\n            authenticationScheme: AuthenticationScheme.BEARER,\n        };\n\n        const serverTelemetryManager = this.initializeServerTelemetryManager(\n            ApiId.acquireTokenByRefreshToken,\n            validRequest.correlationId\n        );\n        try {\n            const discoveredAuthority = await this.createAuthority(\n                validRequest.authority,\n                validRequest.correlationId,\n                undefined,\n                request.azureCloudOptions\n            );\n            const refreshTokenClientConfig =\n                await this.buildOauthClientConfiguration(\n                    discoveredAuthority,\n                    validRequest.correlationId,\n                    validRequest.redirectUri || \"\",\n                    serverTelemetryManager\n                );\n            const refreshTokenClient = new RefreshTokenClient(\n                refreshTokenClientConfig\n            );\n            this.logger.verbose(\n                \"Refresh token client created\",\n                validRequest.correlationId\n            );\n            return await refreshTokenClient.acquireToken(validRequest);\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(validRequest.correlationId);\n            }\n            serverTelemetryManager.cacheFailedRequest(e);\n            throw e;\n        }\n    }\n\n    /**\n     * Acquires a token silently when a user specifies the account the token is requested for.\n     *\n     * This API expects the user to provide an account object and looks into the cache to retrieve the token if present.\n     * There is also an optional \"forceRefresh\" boolean the user can send to bypass the cache for access_token and id_token.\n     * In case the refresh_token is expired or not found, an error is thrown\n     * and the guidance is for the user to call any interactive token acquisition API (eg: `acquireTokenByCode()`).\n     */\n    async acquireTokenSilent(\n        request: SilentFlowRequest\n    ): Promise<AuthenticationResult> {\n        const validRequest: CommonSilentFlowRequest = {\n            ...request,\n            ...(await this.initializeBaseRequest(request)),\n            forceRefresh: request.forceRefresh || false,\n        };\n\n        const serverTelemetryManager = this.initializeServerTelemetryManager(\n            ApiId.acquireTokenSilent,\n            validRequest.correlationId,\n            validRequest.forceRefresh\n        );\n\n        try {\n            const discoveredAuthority = await this.createAuthority(\n                validRequest.authority,\n                validRequest.correlationId,\n                undefined,\n                request.azureCloudOptions\n            );\n            const clientConfiguration =\n                await this.buildOauthClientConfiguration(\n                    discoveredAuthority,\n                    validRequest.correlationId,\n                    validRequest.redirectUri || \"\",\n                    serverTelemetryManager\n                );\n            const silentFlowClient = new SilentFlowClient(clientConfiguration);\n            this.logger.verbose(\n                \"Silent flow client created\",\n                validRequest.correlationId\n            );\n            try {\n                // always overwrite the in-memory cache with the persistence cache (if it exists) before a cache lookup\n                await this.tokenCache.overwriteCache();\n                return await this.acquireCachedTokenSilent(\n                    validRequest,\n                    silentFlowClient,\n                    clientConfiguration\n                );\n            } catch (error) {\n                if (\n                    error instanceof ClientAuthError &&\n                    error.errorCode ===\n                        ClientAuthErrorCodes.tokenRefreshRequired\n                ) {\n                    const refreshTokenClient = new RefreshTokenClient(\n                        clientConfiguration\n                    );\n                    return refreshTokenClient.acquireTokenByRefreshToken(\n                        validRequest\n                    );\n                }\n                throw error;\n            }\n        } catch (error) {\n            if (error instanceof AuthError) {\n                error.setCorrelationId(validRequest.correlationId);\n            }\n            serverTelemetryManager.cacheFailedRequest(error);\n            throw error;\n        }\n    }\n\n    private async acquireCachedTokenSilent(\n        validRequest: CommonSilentFlowRequest,\n        silentFlowClient: SilentFlowClient,\n        clientConfiguration: ClientConfiguration\n    ): Promise<AuthenticationResult> {\n        const [authResponse, cacheOutcome] =\n            await silentFlowClient.acquireCachedToken({\n                ...validRequest,\n                scopes: validRequest.scopes?.length\n                    ? validRequest.scopes\n                    : [...OIDC_DEFAULT_SCOPES],\n            });\n\n        if (cacheOutcome === CacheOutcome.PROACTIVELY_REFRESHED) {\n            this.logger.info(\n                \"ClientApplication:acquireCachedTokenSilent - Cached access token's refreshOn property has been exceeded'. It's not expired, but must be refreshed.\"\n            );\n            // refresh the access token in the background\n            const refreshTokenClient = new RefreshTokenClient(\n                clientConfiguration\n            );\n\n            try {\n                await refreshTokenClient.acquireTokenByRefreshToken(\n                    validRequest\n                );\n            } catch {\n                // do nothing, this is running in the background and no action is to be taken upon success or failure\n            }\n        }\n\n        // return the cached token\n        return authResponse;\n    }\n\n    /**\n     * Acquires tokens with password grant by exchanging client applications username and password for credentials\n     *\n     * The latest OAuth 2.0 Security Best Current Practice disallows the password grant entirely.\n     * More details on this recommendation at https://tools.ietf.org/html/draft-ietf-oauth-security-topics-13#section-3.4\n     * Microsoft's documentation and recommendations are at:\n     * https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-authentication-flows#usernamepassword\n     *\n     * @param request - UsenamePasswordRequest\n     * @deprecated - Use a more secure flow instead\n     */\n    async acquireTokenByUsernamePassword(\n        request: UsernamePasswordRequest\n    ): Promise<AuthenticationResult | null> {\n        this.logger.info(\n            \"acquireTokenByUsernamePassword called\",\n            request.correlationId\n        );\n        const validRequest: CommonUsernamePasswordRequest = {\n            ...request,\n            ...(await this.initializeBaseRequest(request)),\n        };\n        const serverTelemetryManager = this.initializeServerTelemetryManager(\n            ApiId.acquireTokenByUsernamePassword,\n            validRequest.correlationId\n        );\n        try {\n            const discoveredAuthority = await this.createAuthority(\n                validRequest.authority,\n                validRequest.correlationId,\n                undefined,\n                request.azureCloudOptions\n            );\n            const usernamePasswordClientConfig =\n                await this.buildOauthClientConfiguration(\n                    discoveredAuthority,\n                    validRequest.correlationId,\n                    \"\",\n                    serverTelemetryManager\n                );\n            const usernamePasswordClient = new UsernamePasswordClient(\n                usernamePasswordClientConfig\n            );\n            this.logger.verbose(\n                \"Username password client created\",\n                validRequest.correlationId\n            );\n            return await usernamePasswordClient.acquireToken(validRequest);\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(validRequest.correlationId);\n            }\n            serverTelemetryManager.cacheFailedRequest(e);\n            throw e;\n        }\n    }\n\n    /**\n     * Gets the token cache for the application.\n     */\n    getTokenCache(): TokenCache {\n        this.logger.info(\"getTokenCache called\");\n        return this.tokenCache;\n    }\n\n    /**\n     * Validates OIDC state by comparing the user cached state with the state received from the server.\n     *\n     * This API is provided for scenarios where you would use OAuth2.0 state parameter to mitigate against\n     * CSRF attacks.\n     * For more information about state, visit https://datatracker.ietf.org/doc/html/rfc6819#section-3.6.\n     * @param state - Unique GUID generated by the user that is cached by the user and sent to the server during the first leg of the flow\n     * @param cachedState - This string is sent back by the server with the authorization code\n     */\n    protected validateState(state: string, cachedState: string): void {\n        if (!state) {\n            throw NodeAuthError.createStateNotFoundError();\n        }\n\n        if (state !== cachedState) {\n            throw createClientAuthError(ClientAuthErrorCodes.stateMismatch);\n        }\n    }\n\n    /**\n     * Returns the logger instance\n     */\n    getLogger(): Logger {\n        return this.logger;\n    }\n\n    /**\n     * Replaces the default logger set in configurations with new Logger with new configurations\n     * @param logger - Logger instance\n     */\n    setLogger(logger: Logger): void {\n        this.logger = logger;\n    }\n\n    /**\n     * Builds the common configuration to be passed to the common component based on the platform configurarion\n     * @param authority - user passed authority in configuration\n     * @param serverTelemetryManager - initializes servertelemetry if passed\n     */\n    protected async buildOauthClientConfiguration(\n        discoveredAuthority: Authority,\n        requestCorrelationId: string,\n        redirectUri: string,\n        serverTelemetryManager?: ServerTelemetryManager\n    ): Promise<ClientConfiguration> {\n        this.logger.verbose(\n            \"buildOauthClientConfiguration called\",\n            requestCorrelationId\n        );\n\n        this.logger.info(\n            `Building oauth client configuration with the following authority: ${discoveredAuthority.tokenEndpoint}.`,\n            requestCorrelationId\n        );\n\n        serverTelemetryManager?.updateRegionDiscoveryMetadata(\n            discoveredAuthority.regionDiscoveryMetadata\n        );\n\n        const clientConfiguration: ClientConfiguration = {\n            authOptions: {\n                clientId: this.config.auth.clientId,\n                authority: discoveredAuthority,\n                clientCapabilities: this.config.auth.clientCapabilities,\n                redirectUri,\n            },\n            loggerOptions: {\n                logLevel: this.config.system.loggerOptions.logLevel,\n                loggerCallback: this.config.system.loggerOptions.loggerCallback,\n                piiLoggingEnabled:\n                    this.config.system.loggerOptions.piiLoggingEnabled,\n                correlationId: requestCorrelationId,\n            },\n            cacheOptions: {\n                claimsBasedCachingEnabled:\n                    this.config.cache.claimsBasedCachingEnabled,\n            },\n            cryptoInterface: this.cryptoProvider,\n            networkInterface: this.config.system.networkClient,\n            storageInterface: this.storage,\n            serverTelemetryManager: serverTelemetryManager,\n            clientCredentials: {\n                clientSecret: this.clientSecret,\n                clientAssertion: await this.getClientAssertion(\n                    discoveredAuthority\n                ),\n            },\n            libraryInfo: {\n                sku: NodeConstants.MSAL_SKU,\n                version: version,\n                cpu: process.arch || Constants.EMPTY_STRING,\n                os: process.platform || Constants.EMPTY_STRING,\n            },\n            telemetry: this.config.telemetry,\n            persistencePlugin: this.config.cache.cachePlugin,\n            serializableCache: this.tokenCache,\n        };\n\n        return clientConfiguration;\n    }\n\n    private async getClientAssertion(\n        authority: Authority\n    ): Promise<ClientAssertionType> {\n        if (this.developerProvidedClientAssertion) {\n            this.clientAssertion = ClientAssertion.fromAssertion(\n                await getClientAssertion(\n                    this.developerProvidedClientAssertion,\n                    this.config.auth.clientId,\n                    authority.tokenEndpoint\n                )\n            );\n        }\n\n        return (\n            this.clientAssertion && {\n                assertion: this.clientAssertion.getJwt(\n                    this.cryptoProvider,\n                    this.config.auth.clientId,\n                    authority.tokenEndpoint\n                ),\n                assertionType: NodeConstants.JWT_BEARER_ASSERTION_TYPE,\n            }\n        );\n    }\n\n    /**\n     * Generates a request with the default scopes & generates a correlationId.\n     * @param authRequest - BaseAuthRequest for initialization\n     */\n    protected async initializeBaseRequest(\n        authRequest: Partial<BaseAuthRequest>\n    ): Promise<BaseAuthRequest> {\n        this.logger.verbose(\n            \"initializeRequestScopes called\",\n            authRequest.correlationId\n        );\n        // Default authenticationScheme to Bearer, log that POP isn't supported yet\n        if (\n            authRequest.authenticationScheme &&\n            authRequest.authenticationScheme === AuthenticationScheme.POP\n        ) {\n            this.logger.verbose(\n                \"Authentication Scheme 'pop' is not supported yet, setting Authentication Scheme to 'Bearer' for request\",\n                authRequest.correlationId\n            );\n        }\n\n        authRequest.authenticationScheme = AuthenticationScheme.BEARER;\n\n        // Set requested claims hash if claims-based caching is enabled and claims were requested\n        if (\n            this.config.cache.claimsBasedCachingEnabled &&\n            authRequest.claims &&\n            // Checks for empty stringified object \"{}\" which doesn't qualify as requested claims\n            !StringUtils.isEmptyObj(authRequest.claims)\n        ) {\n            authRequest.requestedClaimsHash =\n                await this.cryptoProvider.hashString(authRequest.claims);\n        }\n\n        return {\n            ...authRequest,\n            scopes: [\n                ...((authRequest && authRequest.scopes) || []),\n                ...OIDC_DEFAULT_SCOPES,\n            ],\n            correlationId:\n                (authRequest && authRequest.correlationId) ||\n                this.cryptoProvider.createNewGuid(),\n            authority: authRequest.authority || this.config.auth.authority,\n        };\n    }\n\n    /**\n     * Initializes the server telemetry payload\n     * @param apiId - Id for a specific request\n     * @param correlationId - GUID\n     * @param forceRefresh - boolean to indicate network call\n     */\n    protected initializeServerTelemetryManager(\n        apiId: number,\n        correlationId: string,\n        forceRefresh?: boolean\n    ): ServerTelemetryManager {\n        const telemetryPayload: ServerTelemetryRequest = {\n            clientId: this.config.auth.clientId,\n            correlationId: correlationId,\n            apiId: apiId,\n            forceRefresh: forceRefresh || false,\n        };\n\n        return new ServerTelemetryManager(telemetryPayload, this.storage);\n    }\n\n    /**\n     * Create authority instance. If authority not passed in request, default to authority set on the application\n     * object. If no authority set in application object, then default to common authority.\n     * @param authorityString - authority from user configuration\n     */\n    protected async createAuthority(\n        authorityString: string,\n        requestCorrelationId: string,\n        azureRegionConfiguration?: AzureRegionConfiguration,\n        azureCloudOptions?: AzureCloudOptions\n    ): Promise<Authority> {\n        this.logger.verbose(\"createAuthority called\", requestCorrelationId);\n\n        // build authority string based on auth params - azureCloudInstance is prioritized if provided\n        const authorityUrl = Authority.generateAuthority(\n            authorityString,\n            azureCloudOptions || this.config.auth.azureCloudOptions\n        );\n\n        const authorityOptions: AuthorityOptions = {\n            protocolMode: this.config.auth.protocolMode,\n            knownAuthorities: this.config.auth.knownAuthorities,\n            cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,\n            authorityMetadata: this.config.auth.authorityMetadata,\n            azureRegionConfiguration,\n            skipAuthorityMetadataCache:\n                this.config.auth.skipAuthorityMetadataCache,\n        };\n\n        return AuthorityFactory.createDiscoveredInstance(\n            authorityUrl,\n            this.config.system.networkClient,\n            this.storage,\n            authorityOptions,\n            this.logger,\n            requestCorrelationId\n        );\n    }\n\n    /**\n     * Clear the cache\n     */\n    clearCache(): void {\n        this.storage.clear();\n    }\n}\n"],"names":["NodeConstants","Constants"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2875, "column": 0}, "map": {"version":3,"file":"LoopbackClient.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/network/LoopbackClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    Constants as CommonConstants,\n    AuthorizeResponse,\n    HttpStatus,\n    UrlUtils,\n} from \"@azure/msal-common/node\";\nimport http from \"http\";\nimport { NodeAuthError } from \"../error/NodeAuthError.js\";\nimport { Constants } from \"../utils/Constants.js\";\nimport { ILoopbackClient } from \"./ILoopbackClient.js\";\n\nexport class LoopbackClient implements ILoopbackClient {\n    private server: http.Server | undefined;\n\n    /**\n     * Spins up a loopback server which returns the server response when the localhost redirectUri is hit\n     * @param successTemplate\n     * @param errorTemplate\n     * @returns\n     */\n    async listenForAuthCode(\n        successTemplate?: string,\n        errorTemplate?: string\n    ): Promise<AuthorizeResponse> {\n        if (this.server) {\n            throw NodeAuthError.createLoopbackServerAlreadyExistsError();\n        }\n\n        return new Promise<AuthorizeResponse>((resolve, reject) => {\n            this.server = http.createServer(\n                (req: http.IncomingMessage, res: http.ServerResponse) => {\n                    const url = req.url;\n                    if (!url) {\n                        res.end(\n                            errorTemplate ||\n                                \"Error occurred loading redirectUrl\"\n                        );\n                        reject(\n                            NodeAuthError.createUnableToLoadRedirectUrlError()\n                        );\n                        return;\n                    } else if (url === CommonConstants.FORWARD_SLASH) {\n                        res.end(\n                            successTemplate ||\n                                \"Auth code was successfully acquired. You can close this window now.\"\n                        );\n                        return;\n                    }\n\n                    const redirectUri = this.getRedirectUri();\n                    const parsedUrl = new URL(url, redirectUri);\n                    const authCodeResponse =\n                        UrlUtils.getDeserializedResponse(parsedUrl.search) ||\n                        {};\n                    if (authCodeResponse.code) {\n                        res.writeHead(HttpStatus.REDIRECT, {\n                            location: redirectUri,\n                        }); // Prevent auth code from being saved in the browser history\n                        res.end();\n                    }\n                    if (authCodeResponse.error) {\n                        res.end(\n                            errorTemplate ||\n                                `Error occurred: ${authCodeResponse.error}`\n                        );\n                    }\n                    resolve(authCodeResponse);\n                }\n            );\n            this.server.listen(0, \"127.0.0.1\"); // Listen on any available port\n        });\n    }\n\n    /**\n     * Get the port that the loopback server is running on\n     * @returns\n     */\n    getRedirectUri(): string {\n        if (!this.server || !this.server.listening) {\n            throw NodeAuthError.createNoLoopbackServerExistsError();\n        }\n\n        const address = this.server.address();\n        if (!address || typeof address === \"string\" || !address.port) {\n            this.closeServer();\n            throw NodeAuthError.createInvalidLoopbackAddressTypeError();\n        }\n\n        const port = address && address.port;\n\n        return `${Constants.HTTP_PROTOCOL}${Constants.LOCALHOST}:${port}`;\n    }\n\n    /**\n     * Close the loopback server\n     */\n    closeServer(): void {\n        if (this.server) {\n            // Only stops accepting new connections, server will close once open/idle connections are closed.\n            this.server.close();\n\n            if (typeof this.server.closeAllConnections === \"function\") {\n                /*\n                 * Close open/idle connections. This API is available in Node versions 18.2 and higher\n                 */\n                this.server.closeAllConnections();\n            }\n            this.server.unref();\n            this.server = undefined;\n        }\n    }\n}\n"],"names":["CommonConstants","Constants"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2968, "column": 0}, "map": {"version":3,"file":"DeviceCodeClient.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/client/DeviceCodeClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AuthErrorCodes,\n    AuthenticationResult,\n    BaseClient,\n    ClientAuthErrorCodes,\n    ClientConfiguration,\n    CommonDeviceCodeRequest,\n    Constants,\n    DeviceCodeResponse,\n    GrantType,\n    RequestParameterBuilder,\n    RequestThumbprint,\n    ResponseHandler,\n    ServerAuthorizationTokenResponse,\n    ServerDeviceCodeResponse,\n    StringUtils,\n    TimeUtils,\n    UrlString,\n    UrlUtils,\n    createAuthError,\n    createClientAuthError,\n} from \"@azure/msal-common/node\";\n\n/**\n * OAuth2.0 Device code client\n * @public\n */\nexport class DeviceCodeClient extends BaseClient {\n    constructor(configuration: ClientConfiguration) {\n        super(configuration);\n    }\n\n    /**\n     * Gets device code from device code endpoint, calls back to with device code response, and\n     * polls token endpoint to exchange device code for tokens\n     * @param request - developer provided CommonDeviceCodeRequest\n     */\n    public async acquireToken(\n        request: CommonDeviceCodeRequest\n    ): Promise<AuthenticationResult | null> {\n        const deviceCodeResponse: DeviceCodeResponse = await this.getDeviceCode(\n            request\n        );\n        request.deviceCodeCallback(deviceCodeResponse);\n        const reqTimestamp = TimeUtils.nowSeconds();\n        const response: ServerAuthorizationTokenResponse =\n            await this.acquireTokenWithDeviceCode(request, deviceCodeResponse);\n\n        const responseHandler = new ResponseHandler(\n            this.config.authOptions.clientId,\n            this.cacheManager,\n            this.cryptoUtils,\n            this.logger,\n            this.config.serializableCache,\n            this.config.persistencePlugin\n        );\n\n        // Validate response. This function throws a server error if an error is returned by the server.\n        responseHandler.validateTokenResponse(response);\n        return responseHandler.handleServerTokenResponse(\n            response,\n            this.authority,\n            reqTimestamp,\n            request\n        );\n    }\n\n    /**\n     * Creates device code request and executes http GET\n     * @param request - developer provided CommonDeviceCodeRequest\n     */\n    private async getDeviceCode(\n        request: CommonDeviceCodeRequest\n    ): Promise<DeviceCodeResponse> {\n        const queryParametersString = this.createExtraQueryParameters(request);\n        const endpoint = UrlString.appendQueryString(\n            this.authority.deviceCodeEndpoint,\n            queryParametersString\n        );\n        const queryString = this.createQueryString(request);\n        const headers = this.createTokenRequestHeaders();\n        const thumbprint: RequestThumbprint = {\n            clientId: this.config.authOptions.clientId,\n            authority: request.authority,\n            scopes: request.scopes,\n            claims: request.claims,\n            authenticationScheme: request.authenticationScheme,\n            resourceRequestMethod: request.resourceRequestMethod,\n            resourceRequestUri: request.resourceRequestUri,\n            shrClaims: request.shrClaims,\n            sshKid: request.sshKid,\n        };\n\n        return this.executePostRequestToDeviceCodeEndpoint(\n            endpoint,\n            queryString,\n            headers,\n            thumbprint,\n            request.correlationId\n        );\n    }\n\n    /**\n     * Creates query string for the device code request\n     * @param request - developer provided CommonDeviceCodeRequest\n     */\n    public createExtraQueryParameters(\n        request: CommonDeviceCodeRequest\n    ): string {\n        const parameters = new Map<string, string>();\n\n        if (request.extraQueryParameters) {\n            RequestParameterBuilder.addExtraQueryParameters(\n                parameters,\n                request.extraQueryParameters\n            );\n        }\n\n        return UrlUtils.mapToQueryString(parameters);\n    }\n\n    /**\n     * Executes POST request to device code endpoint\n     * @param deviceCodeEndpoint - token endpoint\n     * @param queryString - string to be used in the body of the request\n     * @param headers - headers for the request\n     * @param thumbprint - unique request thumbprint\n     * @param correlationId - correlation id to be used in the request\n     */\n    private async executePostRequestToDeviceCodeEndpoint(\n        deviceCodeEndpoint: string,\n        queryString: string,\n        headers: Record<string, string>,\n        thumbprint: RequestThumbprint,\n        correlationId: string\n    ): Promise<DeviceCodeResponse> {\n        const {\n            body: {\n                user_code: userCode,\n                device_code: deviceCode,\n                verification_uri: verificationUri,\n                expires_in: expiresIn,\n                interval,\n                message,\n            },\n        } = await this.sendPostRequest<ServerDeviceCodeResponse>(\n            thumbprint,\n            deviceCodeEndpoint,\n            {\n                body: queryString,\n                headers: headers,\n            },\n            correlationId\n        );\n\n        return {\n            userCode,\n            deviceCode,\n            verificationUri,\n            expiresIn,\n            interval,\n            message,\n        };\n    }\n\n    /**\n     * Create device code endpoint query parameters and returns string\n     * @param request - developer provided CommonDeviceCodeRequest\n     */\n    private createQueryString(request: CommonDeviceCodeRequest): string {\n        const parameters = new Map<string, string>();\n\n        RequestParameterBuilder.addScopes(parameters, request.scopes);\n        RequestParameterBuilder.addClientId(\n            parameters,\n            this.config.authOptions.clientId\n        );\n\n        if (request.extraQueryParameters) {\n            RequestParameterBuilder.addExtraQueryParameters(\n                parameters,\n                request.extraQueryParameters\n            );\n        }\n\n        if (\n            request.claims ||\n            (this.config.authOptions.clientCapabilities &&\n                this.config.authOptions.clientCapabilities.length > 0)\n        ) {\n            RequestParameterBuilder.addClaims(\n                parameters,\n                request.claims,\n                this.config.authOptions.clientCapabilities\n            );\n        }\n\n        return UrlUtils.mapToQueryString(parameters);\n    }\n\n    /**\n     * Breaks the polling with specific conditions\n     * @param deviceCodeExpirationTime - expiration time for the device code request\n     * @param userSpecifiedTimeout - developer provided timeout, to be compared against deviceCodeExpirationTime\n     * @param userSpecifiedCancelFlag - boolean indicating the developer would like to cancel the request\n     */\n    private continuePolling(\n        deviceCodeExpirationTime: number,\n        userSpecifiedTimeout?: number,\n        userSpecifiedCancelFlag?: boolean\n    ): boolean {\n        if (userSpecifiedCancelFlag) {\n            this.logger.error(\n                \"Token request cancelled by setting DeviceCodeRequest.cancel = true\"\n            );\n            throw createClientAuthError(\n                ClientAuthErrorCodes.deviceCodePollingCancelled\n            );\n        } else if (\n            userSpecifiedTimeout &&\n            userSpecifiedTimeout < deviceCodeExpirationTime &&\n            TimeUtils.nowSeconds() > userSpecifiedTimeout\n        ) {\n            this.logger.error(\n                `User defined timeout for device code polling reached. The timeout was set for ${userSpecifiedTimeout}`\n            );\n            throw createClientAuthError(\n                ClientAuthErrorCodes.userTimeoutReached\n            );\n        } else if (TimeUtils.nowSeconds() > deviceCodeExpirationTime) {\n            if (userSpecifiedTimeout) {\n                this.logger.verbose(\n                    `User specified timeout ignored as the device code has expired before the timeout elapsed. The user specified timeout was set for ${userSpecifiedTimeout}`\n                );\n            }\n            this.logger.error(\n                `Device code expired. Expiration time of device code was ${deviceCodeExpirationTime}`\n            );\n            throw createClientAuthError(ClientAuthErrorCodes.deviceCodeExpired);\n        }\n        return true;\n    }\n\n    /**\n     * Creates token request with device code response and polls token endpoint at interval set by the device code response\n     * @param request - developer provided CommonDeviceCodeRequest\n     * @param deviceCodeResponse - DeviceCodeResponse returned by the security token service device code endpoint\n     */\n    private async acquireTokenWithDeviceCode(\n        request: CommonDeviceCodeRequest,\n        deviceCodeResponse: DeviceCodeResponse\n    ): Promise<ServerAuthorizationTokenResponse> {\n        const queryParametersString = this.createTokenQueryParameters(request);\n        const endpoint = UrlString.appendQueryString(\n            this.authority.tokenEndpoint,\n            queryParametersString\n        );\n        const requestBody = this.createTokenRequestBody(\n            request,\n            deviceCodeResponse\n        );\n        const headers: Record<string, string> =\n            this.createTokenRequestHeaders();\n\n        const userSpecifiedTimeout = request.timeout\n            ? TimeUtils.nowSeconds() + request.timeout\n            : undefined;\n        const deviceCodeExpirationTime =\n            TimeUtils.nowSeconds() + deviceCodeResponse.expiresIn;\n        const pollingIntervalMilli = deviceCodeResponse.interval * 1000;\n\n        /*\n         * Poll token endpoint while (device code is not expired AND operation has not been cancelled by\n         * setting CancellationToken.cancel = true). POST request is sent at interval set by pollingIntervalMilli\n         */\n        while (\n            this.continuePolling(\n                deviceCodeExpirationTime,\n                userSpecifiedTimeout,\n                request.cancel\n            )\n        ) {\n            const thumbprint: RequestThumbprint = {\n                clientId: this.config.authOptions.clientId,\n                authority: request.authority,\n                scopes: request.scopes,\n                claims: request.claims,\n                authenticationScheme: request.authenticationScheme,\n                resourceRequestMethod: request.resourceRequestMethod,\n                resourceRequestUri: request.resourceRequestUri,\n                shrClaims: request.shrClaims,\n                sshKid: request.sshKid,\n            };\n            const response = await this.executePostToTokenEndpoint(\n                endpoint,\n                requestBody,\n                headers,\n                thumbprint,\n                request.correlationId\n            );\n\n            if (response.body && response.body.error) {\n                // user authorization is pending. Sleep for polling interval and try again\n                if (response.body.error === Constants.AUTHORIZATION_PENDING) {\n                    this.logger.info(\n                        \"Authorization pending. Continue polling.\"\n                    );\n                    await TimeUtils.delay(pollingIntervalMilli);\n                } else {\n                    // for any other error, throw\n                    this.logger.info(\n                        \"Unexpected error in polling from the server\"\n                    );\n                    throw createAuthError(\n                        AuthErrorCodes.postRequestFailed,\n                        response.body.error\n                    );\n                }\n            } else {\n                this.logger.verbose(\n                    \"Authorization completed successfully. Polling stopped.\"\n                );\n                return response.body;\n            }\n        }\n\n        /*\n         * The above code should've thrown by this point, but to satisfy TypeScript,\n         * and in the rare case the conditionals in continuePolling() may not catch everything...\n         */\n        this.logger.error(\"Polling stopped for unknown reasons.\");\n        throw createClientAuthError(\n            ClientAuthErrorCodes.deviceCodeUnknownError\n        );\n    }\n\n    /**\n     * Creates query parameters and converts to string.\n     * @param request - developer provided CommonDeviceCodeRequest\n     * @param deviceCodeResponse - DeviceCodeResponse returned by the security token service device code endpoint\n     */\n    private createTokenRequestBody(\n        request: CommonDeviceCodeRequest,\n        deviceCodeResponse: DeviceCodeResponse\n    ): string {\n        const parameters = new Map<string, string>();\n\n        RequestParameterBuilder.addScopes(parameters, request.scopes);\n        RequestParameterBuilder.addClientId(\n            parameters,\n            this.config.authOptions.clientId\n        );\n        RequestParameterBuilder.addGrantType(\n            parameters,\n            GrantType.DEVICE_CODE_GRANT\n        );\n        RequestParameterBuilder.addDeviceCode(\n            parameters,\n            deviceCodeResponse.deviceCode\n        );\n        const correlationId =\n            request.correlationId ||\n            this.config.cryptoInterface.createNewGuid();\n        RequestParameterBuilder.addCorrelationId(parameters, correlationId);\n        RequestParameterBuilder.addClientInfo(parameters);\n        RequestParameterBuilder.addLibraryInfo(\n            parameters,\n            this.config.libraryInfo\n        );\n        RequestParameterBuilder.addApplicationTelemetry(\n            parameters,\n            this.config.telemetry.application\n        );\n        RequestParameterBuilder.addThrottling(parameters);\n        if (this.serverTelemetryManager) {\n            RequestParameterBuilder.addServerTelemetry(\n                parameters,\n                this.serverTelemetryManager\n            );\n        }\n\n        if (\n            !StringUtils.isEmptyObj(request.claims) ||\n            (this.config.authOptions.clientCapabilities &&\n                this.config.authOptions.clientCapabilities.length > 0)\n        ) {\n            RequestParameterBuilder.addClaims(\n                parameters,\n                request.claims,\n                this.config.authOptions.clientCapabilities\n            );\n        }\n        return UrlUtils.mapToQueryString(parameters);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3179, "column": 0}, "map": {"version":3,"file":"PublicClientApplication.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/client/PublicClientApplication.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    ApiId,\n    Constants,\n    LOOPBACK_SERVER_CONSTANTS,\n} from \"../utils/Constants.js\";\nimport {\n    AuthenticationResult,\n    CommonDeviceCodeRequest,\n    AuthError,\n    ResponseMode,\n    OIDC_DEFAULT_SCOPES,\n    CodeChallengeMethodValues,\n    Constants as CommonConstants,\n    ServerError,\n    NativeRequest,\n    NativeSignOutRequest,\n    AccountInfo,\n    INativeBrokerPlugin,\n    AuthorizeResponse,\n    AADServerParamKeys,\n    ServerTelemetryManager,\n} from \"@azure/msal-common/node\";\nimport { Configuration } from \"../config/Configuration.js\";\nimport { ClientApplication } from \"./ClientApplication.js\";\nimport { IPublicClientApplication } from \"./IPublicClientApplication.js\";\nimport { DeviceCodeRequest } from \"../request/DeviceCodeRequest.js\";\nimport { AuthorizationUrlRequest } from \"../request/AuthorizationUrlRequest.js\";\nimport { AuthorizationCodeRequest } from \"../request/AuthorizationCodeRequest.js\";\nimport { InteractiveRequest } from \"../request/InteractiveRequest.js\";\nimport { NodeAuthError, NodeAuthErrorMessage } from \"../error/NodeAuthError.js\";\nimport { LoopbackClient } from \"../network/LoopbackClient.js\";\nimport { SilentFlowRequest } from \"../request/SilentFlowRequest.js\";\nimport { SignOutRequest } from \"../request/SignOutRequest.js\";\nimport { ILoopbackClient } from \"../network/ILoopbackClient.js\";\nimport { DeviceCodeClient } from \"./DeviceCodeClient.js\";\nimport { version } from \"../packageMetadata.js\";\n\n/**\n * This class is to be used to acquire tokens for public client applications (desktop, mobile). Public client applications\n * are not trusted to safely store application secrets, and therefore can only request tokens in the name of an user.\n * @public\n */\nexport class PublicClientApplication\n    extends ClientApplication\n    implements IPublicClientApplication\n{\n    private nativeBrokerPlugin?: INativeBrokerPlugin;\n    private readonly skus: string;\n    /**\n     * Important attributes in the Configuration object for auth are:\n     * - clientID: the application ID of your application. You can obtain one by registering your application with our Application registration portal.\n     * - authority: the authority URL for your application.\n     *\n     * AAD authorities are of the form https://login.microsoftonline.com/\\{Enter_the_Tenant_Info_Here\\}.\n     * - If your application supports Accounts in one organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).\n     * - If your application supports Accounts in any organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with organizations.\n     * - If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace \"Enter_the_Tenant_Info_Here\" value with common.\n     * - To restrict support to Personal Microsoft accounts only, replace \"Enter_the_Tenant_Info_Here\" value with consumers.\n     *\n     * Azure B2C authorities are of the form https://\\{instance\\}/\\{tenant\\}/\\{policy\\}. Each policy is considered\n     * its own authority. You will have to set the all of the knownAuthorities at the time of the client application\n     * construction.\n     *\n     * ADFS authorities are of the form https://\\{instance\\}/adfs.\n     */\n    constructor(configuration: Configuration) {\n        super(configuration);\n        if (this.config.broker.nativeBrokerPlugin) {\n            if (this.config.broker.nativeBrokerPlugin.isBrokerAvailable) {\n                this.nativeBrokerPlugin = this.config.broker.nativeBrokerPlugin;\n                this.nativeBrokerPlugin.setLogger(\n                    this.config.system.loggerOptions\n                );\n            } else {\n                this.logger.warning(\n                    \"NativeBroker implementation was provided but the broker is unavailable.\"\n                );\n            }\n        }\n        this.skus = ServerTelemetryManager.makeExtraSkuString({\n            libraryName: Constants.MSAL_SKU,\n            libraryVersion: version,\n        });\n    }\n\n    /**\n     * Acquires a token from the authority using OAuth2.0 device code flow.\n     * This flow is designed for devices that do not have access to a browser or have input constraints.\n     * The authorization server issues a DeviceCode object with a verification code, an end-user code,\n     * and the end-user verification URI. The DeviceCode object is provided through a callback, and the end-user should be\n     * instructed to use another device to navigate to the verification URI to input credentials.\n     * Since the client cannot receive incoming requests, it polls the authorization server repeatedly\n     * until the end-user completes input of credentials.\n     */\n    public async acquireTokenByDeviceCode(\n        request: DeviceCodeRequest\n    ): Promise<AuthenticationResult | null> {\n        this.logger.info(\n            \"acquireTokenByDeviceCode called\",\n            request.correlationId\n        );\n        const validRequest: CommonDeviceCodeRequest = Object.assign(\n            request,\n            await this.initializeBaseRequest(request)\n        );\n        const serverTelemetryManager = this.initializeServerTelemetryManager(\n            ApiId.acquireTokenByDeviceCode,\n            validRequest.correlationId\n        );\n        try {\n            const discoveredAuthority = await this.createAuthority(\n                validRequest.authority,\n                validRequest.correlationId,\n                undefined,\n                request.azureCloudOptions\n            );\n            const deviceCodeConfig = await this.buildOauthClientConfiguration(\n                discoveredAuthority,\n                validRequest.correlationId,\n                \"\",\n                serverTelemetryManager\n            );\n            const deviceCodeClient = new DeviceCodeClient(deviceCodeConfig);\n            this.logger.verbose(\n                \"Device code client created\",\n                validRequest.correlationId\n            );\n            return await deviceCodeClient.acquireToken(validRequest);\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(validRequest.correlationId);\n            }\n            serverTelemetryManager.cacheFailedRequest(e as AuthError);\n            throw e;\n        }\n    }\n\n    /**\n     * Acquires a token interactively via the browser by requesting an authorization code then exchanging it for a token.\n     */\n    async acquireTokenInteractive(\n        request: InteractiveRequest\n    ): Promise<AuthenticationResult> {\n        const correlationId =\n            request.correlationId || this.cryptoProvider.createNewGuid();\n        this.logger.trace(\"acquireTokenInteractive called\", correlationId);\n        const {\n            openBrowser,\n            successTemplate,\n            errorTemplate,\n            windowHandle,\n            loopbackClient: customLoopbackClient,\n            ...remainingProperties\n        } = request;\n\n        if (this.nativeBrokerPlugin) {\n            const brokerRequest: NativeRequest = {\n                ...remainingProperties,\n                clientId: this.config.auth.clientId,\n                scopes: request.scopes || OIDC_DEFAULT_SCOPES,\n                redirectUri: `${Constants.HTTP_PROTOCOL}${Constants.LOCALHOST}`,\n                authority: request.authority || this.config.auth.authority,\n                correlationId: correlationId,\n                extraParameters: {\n                    ...remainingProperties.extraQueryParameters,\n                    ...remainingProperties.tokenQueryParameters,\n                    [AADServerParamKeys.X_CLIENT_EXTRA_SKU]: this.skus,\n                },\n                accountId: remainingProperties.account?.nativeAccountId,\n            };\n            return this.nativeBrokerPlugin.acquireTokenInteractive(\n                brokerRequest,\n                windowHandle\n            );\n        }\n\n        const { verifier, challenge } =\n            await this.cryptoProvider.generatePkceCodes();\n\n        const loopbackClient: ILoopbackClient =\n            customLoopbackClient || new LoopbackClient();\n\n        let authCodeResponse: AuthorizeResponse = {};\n        let authCodeListenerError: AuthError | null = null;\n        try {\n            const authCodeListener = loopbackClient\n                .listenForAuthCode(successTemplate, errorTemplate)\n                .then((response) => {\n                    authCodeResponse = response;\n                })\n                .catch((e) => {\n                    // Store the promise instead of throwing so we can control when its thrown\n                    authCodeListenerError = e;\n                });\n\n            // Wait for server to be listening\n            const redirectUri = await this.waitForRedirectUri(loopbackClient);\n\n            const validRequest: AuthorizationUrlRequest = {\n                ...remainingProperties,\n                correlationId: correlationId,\n                scopes: request.scopes || OIDC_DEFAULT_SCOPES,\n                redirectUri: redirectUri,\n                responseMode: ResponseMode.QUERY,\n                codeChallenge: challenge,\n                codeChallengeMethod: CodeChallengeMethodValues.S256,\n            };\n\n            const authCodeUrl = await this.getAuthCodeUrl(validRequest);\n            await openBrowser(authCodeUrl);\n            await authCodeListener;\n            if (authCodeListenerError) {\n                throw authCodeListenerError;\n            }\n\n            if (authCodeResponse.error) {\n                throw new ServerError(\n                    authCodeResponse.error,\n                    authCodeResponse.error_description,\n                    authCodeResponse.suberror\n                );\n            } else if (!authCodeResponse.code) {\n                throw NodeAuthError.createNoAuthCodeInResponseError();\n            }\n\n            const clientInfo = authCodeResponse.client_info;\n            const tokenRequest: AuthorizationCodeRequest = {\n                code: authCodeResponse.code,\n                codeVerifier: verifier,\n                clientInfo: clientInfo || CommonConstants.EMPTY_STRING,\n                ...validRequest,\n            };\n            return await this.acquireTokenByCode(tokenRequest); // Await this so the server doesn't close prematurely\n        } finally {\n            loopbackClient.closeServer();\n        }\n    }\n\n    /**\n     * Returns a token retrieved either from the cache or by exchanging the refresh token for a fresh access token. If brokering is enabled the token request will be serviced by the broker.\n     * @param request - developer provided SilentFlowRequest\n     * @returns\n     */\n    async acquireTokenSilent(\n        request: SilentFlowRequest\n    ): Promise<AuthenticationResult> {\n        const correlationId =\n            request.correlationId || this.cryptoProvider.createNewGuid();\n        this.logger.trace(\"acquireTokenSilent called\", correlationId);\n\n        if (this.nativeBrokerPlugin) {\n            const brokerRequest: NativeRequest = {\n                ...request,\n                clientId: this.config.auth.clientId,\n                scopes: request.scopes || OIDC_DEFAULT_SCOPES,\n                redirectUri: `${Constants.HTTP_PROTOCOL}${Constants.LOCALHOST}`,\n                authority: request.authority || this.config.auth.authority,\n                correlationId: correlationId,\n                extraParameters: {\n                    ...request.tokenQueryParameters,\n                    [AADServerParamKeys.X_CLIENT_EXTRA_SKU]: this.skus,\n                },\n                accountId: request.account.nativeAccountId,\n                forceRefresh: request.forceRefresh || false,\n            };\n            return this.nativeBrokerPlugin.acquireTokenSilent(brokerRequest);\n        }\n\n        return super.acquireTokenSilent(request);\n    }\n\n    /**\n     * Removes cache artifacts associated with the given account\n     * @param request - developer provided SignOutRequest\n     * @returns\n     */\n    async signOut(request: SignOutRequest): Promise<void> {\n        if (this.nativeBrokerPlugin && request.account.nativeAccountId) {\n            const signoutRequest: NativeSignOutRequest = {\n                clientId: this.config.auth.clientId,\n                accountId: request.account.nativeAccountId,\n                correlationId:\n                    request.correlationId ||\n                    this.cryptoProvider.createNewGuid(),\n            };\n            await this.nativeBrokerPlugin.signOut(signoutRequest);\n        }\n\n        await this.getTokenCache().removeAccount(\n            request.account,\n            request.correlationId\n        );\n    }\n\n    /**\n     * Returns all cached accounts for this application. If brokering is enabled this request will be serviced by the broker.\n     * @returns\n     */\n    async getAllAccounts(): Promise<AccountInfo[]> {\n        if (this.nativeBrokerPlugin) {\n            const correlationId = this.cryptoProvider.createNewGuid();\n            return this.nativeBrokerPlugin.getAllAccounts(\n                this.config.auth.clientId,\n                correlationId\n            );\n        }\n\n        return this.getTokenCache().getAllAccounts();\n    }\n\n    /**\n     * Attempts to retrieve the redirectUri from the loopback server. If the loopback server does not start listening for requests within the timeout this will throw.\n     * @param loopbackClient - developer provided custom loopback server implementation\n     * @returns\n     */\n    private async waitForRedirectUri(\n        loopbackClient: ILoopbackClient\n    ): Promise<string> {\n        return new Promise<string>((resolve, reject) => {\n            let ticks = 0;\n            const id = setInterval(() => {\n                if (\n                    LOOPBACK_SERVER_CONSTANTS.TIMEOUT_MS /\n                        LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS <\n                    ticks\n                ) {\n                    clearInterval(id);\n                    reject(NodeAuthError.createLoopbackServerTimeoutError());\n                    return;\n                }\n\n                try {\n                    const r = loopbackClient.getRedirectUri();\n                    clearInterval(id);\n                    resolve(r);\n                    return;\n                } catch (e) {\n                    if (\n                        e instanceof AuthError &&\n                        e.errorCode ===\n                            NodeAuthErrorMessage.noLoopbackServerExists.code\n                    ) {\n                        // Loopback server is not listening yet\n                        ticks++;\n                        return;\n                    }\n                    clearInterval(id);\n                    reject(e);\n                    return;\n                }\n            }, LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS);\n        });\n    }\n}\n"],"names":["CommonConstants"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3425, "column": 0}, "map": {"version":3,"file":"ClientCredentialClient.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/client/ClientCredentialClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AccessTokenEntity,\n    AuthenticationResult,\n    AuthenticationScheme,\n    Authority,\n    BaseClient,\n    CacheManager,\n    CacheOutcome,\n    ClientAuthErrorCodes,\n    ClientConfiguration,\n    CommonClientCredentialRequest,\n    Constants,\n    CredentialFilter,\n    CredentialType,\n    DEFAULT_TOKEN_RENEWAL_OFFSET_SEC,\n    GrantType,\n    IAppTokenProvider,\n    ICrypto,\n    RequestParameterBuilder,\n    RequestThumbprint,\n    ResponseHandler,\n    ScopeSet,\n    ServerAuthorizationTokenResponse,\n    ServerTelemetryManager,\n    StringUtils,\n    TimeUtils,\n    TokenCacheContext,\n    UrlString,\n    createClientAuthError,\n    ClientAssertion,\n    getClientAssertion,\n    UrlUtils,\n} from \"@azure/msal-common/node\";\nimport {\n    ManagedIdentityConfiguration,\n    ManagedIdentityNodeConfiguration,\n} from \"../config/Configuration.js\";\n\n/**\n * OAuth2.0 client credential grant\n * @public\n */\nexport class ClientCredentialClient extends BaseClient {\n    private readonly appTokenProvider?: IAppTokenProvider;\n\n    constructor(\n        configuration: ClientConfiguration,\n        appTokenProvider?: IAppTokenProvider\n    ) {\n        super(configuration);\n        this.appTokenProvider = appTokenProvider;\n    }\n\n    /**\n     * Public API to acquire a token with ClientCredential Flow for Confidential clients\n     * @param request - CommonClientCredentialRequest provided by the developer\n     */\n    public async acquireToken(\n        request: CommonClientCredentialRequest\n    ): Promise<AuthenticationResult | null> {\n        if (request.skipCache || request.claims) {\n            return this.executeTokenRequest(request, this.authority);\n        }\n\n        const [cachedAuthenticationResult, lastCacheOutcome] =\n            await this.getCachedAuthenticationResult(\n                request,\n                this.config,\n                this.cryptoUtils,\n                this.authority,\n                this.cacheManager,\n                this.serverTelemetryManager\n            );\n\n        if (cachedAuthenticationResult) {\n            // if the token is not expired but must be refreshed; get a new one in the background\n            if (lastCacheOutcome === CacheOutcome.PROACTIVELY_REFRESHED) {\n                this.logger.info(\n                    \"ClientCredentialClient:getCachedAuthenticationResult - Cached access token's refreshOn property has been exceeded'. It's not expired, but must be refreshed.\"\n                );\n\n                // refresh the access token in the background\n                const refreshAccessToken = true;\n                await this.executeTokenRequest(\n                    request,\n                    this.authority,\n                    refreshAccessToken\n                );\n            }\n\n            // return the cached token\n            return cachedAuthenticationResult;\n        } else {\n            return this.executeTokenRequest(request, this.authority);\n        }\n    }\n\n    /**\n     * looks up cache if the tokens are cached already\n     */\n    public async getCachedAuthenticationResult(\n        request: CommonClientCredentialRequest,\n        config: ClientConfiguration | ManagedIdentityConfiguration,\n        cryptoUtils: ICrypto,\n        authority: Authority,\n        cacheManager: CacheManager,\n        serverTelemetryManager?: ServerTelemetryManager | null\n    ): Promise<[AuthenticationResult | null, CacheOutcome]> {\n        const clientConfiguration = config as ClientConfiguration;\n        const managedIdentityConfiguration =\n            config as ManagedIdentityNodeConfiguration;\n\n        let lastCacheOutcome: CacheOutcome = CacheOutcome.NOT_APPLICABLE;\n\n        // read the user-supplied cache into memory, if applicable\n        let cacheContext;\n        if (\n            clientConfiguration.serializableCache &&\n            clientConfiguration.persistencePlugin\n        ) {\n            cacheContext = new TokenCacheContext(\n                clientConfiguration.serializableCache,\n                false\n            );\n            await clientConfiguration.persistencePlugin.beforeCacheAccess(\n                cacheContext\n            );\n        }\n\n        const cachedAccessToken = this.readAccessTokenFromCache(\n            authority,\n            managedIdentityConfiguration.managedIdentityId?.id ||\n                clientConfiguration.authOptions.clientId,\n            new ScopeSet(request.scopes || []),\n            cacheManager\n        );\n\n        if (\n            clientConfiguration.serializableCache &&\n            clientConfiguration.persistencePlugin &&\n            cacheContext\n        ) {\n            await clientConfiguration.persistencePlugin.afterCacheAccess(\n                cacheContext\n            );\n        }\n\n        // must refresh due to non-existent access_token\n        if (!cachedAccessToken) {\n            serverTelemetryManager?.setCacheOutcome(\n                CacheOutcome.NO_CACHED_ACCESS_TOKEN\n            );\n            return [null, CacheOutcome.NO_CACHED_ACCESS_TOKEN];\n        }\n\n        // must refresh due to the expires_in value\n        if (\n            TimeUtils.isTokenExpired(\n                cachedAccessToken.expiresOn,\n                clientConfiguration.systemOptions?.tokenRenewalOffsetSeconds ||\n                    DEFAULT_TOKEN_RENEWAL_OFFSET_SEC\n            )\n        ) {\n            serverTelemetryManager?.setCacheOutcome(\n                CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED\n            );\n            return [null, CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED];\n        }\n\n        // must refresh (in the background) due to the refresh_in value\n        if (\n            cachedAccessToken.refreshOn &&\n            TimeUtils.isTokenExpired(cachedAccessToken.refreshOn.toString(), 0)\n        ) {\n            lastCacheOutcome = CacheOutcome.PROACTIVELY_REFRESHED;\n            serverTelemetryManager?.setCacheOutcome(\n                CacheOutcome.PROACTIVELY_REFRESHED\n            );\n        }\n\n        return [\n            await ResponseHandler.generateAuthenticationResult(\n                cryptoUtils,\n                authority,\n                {\n                    account: null,\n                    idToken: null,\n                    accessToken: cachedAccessToken,\n                    refreshToken: null,\n                    appMetadata: null,\n                },\n                true,\n                request\n            ),\n            lastCacheOutcome,\n        ];\n    }\n\n    /**\n     * Reads access token from the cache\n     */\n    private readAccessTokenFromCache(\n        authority: Authority,\n        id: string,\n        scopeSet: ScopeSet,\n        cacheManager: CacheManager\n    ): AccessTokenEntity | null {\n        const accessTokenFilter: CredentialFilter = {\n            homeAccountId: Constants.EMPTY_STRING,\n            environment:\n                authority.canonicalAuthorityUrlComponents.HostNameAndPort,\n            credentialType: CredentialType.ACCESS_TOKEN,\n            clientId: id,\n            realm: authority.tenant,\n            target: ScopeSet.createSearchScopes(scopeSet.asArray()),\n        };\n\n        const accessTokens =\n            cacheManager.getAccessTokensByFilter(accessTokenFilter);\n        if (accessTokens.length < 1) {\n            return null;\n        } else if (accessTokens.length > 1) {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.multipleMatchingTokens\n            );\n        }\n        return accessTokens[0] as AccessTokenEntity;\n    }\n\n    /**\n     * Makes a network call to request the token from the service\n     * @param request - CommonClientCredentialRequest provided by the developer\n     * @param authority - authority object\n     */\n    private async executeTokenRequest(\n        request: CommonClientCredentialRequest,\n        authority: Authority,\n        refreshAccessToken?: boolean\n    ): Promise<AuthenticationResult | null> {\n        let serverTokenResponse: ServerAuthorizationTokenResponse;\n        let reqTimestamp: number;\n\n        if (this.appTokenProvider) {\n            this.logger.info(\"Using appTokenProvider extensibility.\");\n\n            const appTokenPropviderParameters = {\n                correlationId: request.correlationId,\n                tenantId: this.config.authOptions.authority.tenant,\n                scopes: request.scopes,\n                claims: request.claims,\n            };\n\n            reqTimestamp = TimeUtils.nowSeconds();\n            const appTokenProviderResult = await this.appTokenProvider(\n                appTokenPropviderParameters\n            );\n\n            serverTokenResponse = {\n                access_token: appTokenProviderResult.accessToken,\n                expires_in: appTokenProviderResult.expiresInSeconds,\n                refresh_in: appTokenProviderResult.refreshInSeconds,\n                token_type: AuthenticationScheme.BEARER,\n            };\n        } else {\n            const queryParametersString =\n                this.createTokenQueryParameters(request);\n            const endpoint = UrlString.appendQueryString(\n                authority.tokenEndpoint,\n                queryParametersString\n            );\n\n            const requestBody = await this.createTokenRequestBody(request);\n            const headers: Record<string, string> =\n                this.createTokenRequestHeaders();\n            const thumbprint: RequestThumbprint = {\n                clientId: this.config.authOptions.clientId,\n                authority: request.authority,\n                scopes: request.scopes,\n                claims: request.claims,\n                authenticationScheme: request.authenticationScheme,\n                resourceRequestMethod: request.resourceRequestMethod,\n                resourceRequestUri: request.resourceRequestUri,\n                shrClaims: request.shrClaims,\n                sshKid: request.sshKid,\n            };\n\n            this.logger.info(\n                \"Sending token request to endpoint: \" + authority.tokenEndpoint\n            );\n\n            reqTimestamp = TimeUtils.nowSeconds();\n            const response = await this.executePostToTokenEndpoint(\n                endpoint,\n                requestBody,\n                headers,\n                thumbprint,\n                request.correlationId\n            );\n\n            serverTokenResponse = response.body;\n            serverTokenResponse.status = response.status;\n        }\n\n        const responseHandler = new ResponseHandler(\n            this.config.authOptions.clientId,\n            this.cacheManager,\n            this.cryptoUtils,\n            this.logger,\n            this.config.serializableCache,\n            this.config.persistencePlugin\n        );\n\n        responseHandler.validateTokenResponse(\n            serverTokenResponse,\n            refreshAccessToken\n        );\n\n        const tokenResponse = await responseHandler.handleServerTokenResponse(\n            serverTokenResponse,\n            this.authority,\n            reqTimestamp,\n            request\n        );\n\n        return tokenResponse;\n    }\n\n    /**\n     * generate the request to the server in the acceptable format\n     * @param request - CommonClientCredentialRequest provided by the developer\n     */\n    private async createTokenRequestBody(\n        request: CommonClientCredentialRequest\n    ): Promise<string> {\n        const parameters = new Map<string, string>();\n\n        RequestParameterBuilder.addClientId(\n            parameters,\n            this.config.authOptions.clientId\n        );\n\n        RequestParameterBuilder.addScopes(parameters, request.scopes, false);\n\n        RequestParameterBuilder.addGrantType(\n            parameters,\n            GrantType.CLIENT_CREDENTIALS_GRANT\n        );\n\n        RequestParameterBuilder.addLibraryInfo(\n            parameters,\n            this.config.libraryInfo\n        );\n        RequestParameterBuilder.addApplicationTelemetry(\n            parameters,\n            this.config.telemetry.application\n        );\n\n        RequestParameterBuilder.addThrottling(parameters);\n\n        if (this.serverTelemetryManager) {\n            RequestParameterBuilder.addServerTelemetry(\n                parameters,\n                this.serverTelemetryManager\n            );\n        }\n\n        const correlationId =\n            request.correlationId ||\n            this.config.cryptoInterface.createNewGuid();\n        RequestParameterBuilder.addCorrelationId(parameters, correlationId);\n\n        if (this.config.clientCredentials.clientSecret) {\n            RequestParameterBuilder.addClientSecret(\n                parameters,\n                this.config.clientCredentials.clientSecret\n            );\n        }\n\n        // Use clientAssertion from request, fallback to client assertion in base configuration\n        const clientAssertion: ClientAssertion | undefined =\n            request.clientAssertion ||\n            this.config.clientCredentials.clientAssertion;\n\n        if (clientAssertion) {\n            RequestParameterBuilder.addClientAssertion(\n                parameters,\n                await getClientAssertion(\n                    clientAssertion.assertion,\n                    this.config.authOptions.clientId,\n                    request.resourceRequestUri\n                )\n            );\n            RequestParameterBuilder.addClientAssertionType(\n                parameters,\n                clientAssertion.assertionType\n            );\n        }\n\n        if (\n            !StringUtils.isEmptyObj(request.claims) ||\n            (this.config.authOptions.clientCapabilities &&\n                this.config.authOptions.clientCapabilities.length > 0)\n        ) {\n            RequestParameterBuilder.addClaims(\n                parameters,\n                request.claims,\n                this.config.authOptions.clientCapabilities\n            );\n        }\n\n        return UrlUtils.mapToQueryString(parameters);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3632, "column": 0}, "map": {"version":3,"file":"OnBehalfOfClient.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/client/OnBehalfOfClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AADServerParamKeys,\n    AccessTokenEntity,\n    AccountEntity,\n    AccountInfo,\n    AuthenticationResult,\n    AuthenticationScheme,\n    Authority,\n    AuthToken,\n    BaseClient,\n    CacheOutcome,\n    ClientAuthErrorCodes,\n    ClientConfiguration,\n    CommonOnBehalfOfRequest,\n    Constants,\n    createClientAuthError,\n    CredentialFilter,\n    CredentialType,\n    GrantType,\n    IdTokenEntity,\n    RequestParameterBuilder,\n    RequestThumbprint,\n    ResponseHandler,\n    ScopeSet,\n    TimeUtils,\n    TokenClaims,\n    UrlString,\n    ClientAssertion,\n    getClientAssertion,\n    UrlUtils,\n} from \"@azure/msal-common/node\";\nimport { EncodingUtils } from \"../utils/EncodingUtils.js\";\n\n/**\n * On-Behalf-Of client\n * @public\n */\nexport class OnBehalfOfClient extends BaseClient {\n    private scopeSet: ScopeSet;\n    private userAssertionHash: string;\n\n    constructor(configuration: ClientConfiguration) {\n        super(configuration);\n    }\n\n    /**\n     * Public API to acquire tokens with on behalf of flow\n     * @param request - developer provided CommonOnBehalfOfRequest\n     */\n    public async acquireToken(\n        request: CommonOnBehalfOfRequest\n    ): Promise<AuthenticationResult | null> {\n        this.scopeSet = new ScopeSet(request.scopes || []);\n\n        // generate the user_assertion_hash for OBOAssertion\n        this.userAssertionHash = await this.cryptoUtils.hashString(\n            request.oboAssertion\n        );\n\n        if (request.skipCache || request.claims) {\n            return this.executeTokenRequest(\n                request,\n                this.authority,\n                this.userAssertionHash\n            );\n        }\n\n        try {\n            return await this.getCachedAuthenticationResult(request);\n        } catch (e) {\n            // Any failure falls back to interactive request, once we implement distributed cache, we plan to handle `createRefreshRequiredError` to refresh using the RT\n            return await this.executeTokenRequest(\n                request,\n                this.authority,\n                this.userAssertionHash\n            );\n        }\n    }\n\n    /**\n     * look up cache for tokens\n     * Find idtoken in the cache\n     * Find accessToken based on user assertion and account info in the cache\n     * Please note we are not yet supported OBO tokens refreshed with long lived RT. User will have to send a new assertion if the current access token expires\n     * This is to prevent security issues when the assertion changes over time, however, longlived RT helps retaining the session\n     * @param request - developer provided CommonOnBehalfOfRequest\n     */\n    private async getCachedAuthenticationResult(\n        request: CommonOnBehalfOfRequest\n    ): Promise<AuthenticationResult | null> {\n        // look in the cache for the access_token which matches the incoming_assertion\n        const cachedAccessToken = this.readAccessTokenFromCacheForOBO(\n            this.config.authOptions.clientId,\n            request\n        );\n        if (!cachedAccessToken) {\n            // Must refresh due to non-existent access_token.\n            this.serverTelemetryManager?.setCacheOutcome(\n                CacheOutcome.NO_CACHED_ACCESS_TOKEN\n            );\n            this.logger.info(\n                \"SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.\"\n            );\n            throw createClientAuthError(\n                ClientAuthErrorCodes.tokenRefreshRequired\n            );\n        } else if (\n            TimeUtils.isTokenExpired(\n                cachedAccessToken.expiresOn,\n                this.config.systemOptions.tokenRenewalOffsetSeconds\n            )\n        ) {\n            // Access token expired, will need to renewed\n            this.serverTelemetryManager?.setCacheOutcome(\n                CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED\n            );\n            this.logger.info(\n                `OnbehalfofFlow:getCachedAuthenticationResult - Cached access token is expired or will expire within ${this.config.systemOptions.tokenRenewalOffsetSeconds} seconds.`\n            );\n            throw createClientAuthError(\n                ClientAuthErrorCodes.tokenRefreshRequired\n            );\n        }\n\n        // fetch the idToken from cache\n        const cachedIdToken = this.readIdTokenFromCacheForOBO(\n            cachedAccessToken.homeAccountId\n        );\n        let idTokenClaims: TokenClaims | undefined;\n        let cachedAccount: AccountEntity | null = null;\n        if (cachedIdToken) {\n            idTokenClaims = AuthToken.extractTokenClaims(\n                cachedIdToken.secret,\n                EncodingUtils.base64Decode\n            );\n            const localAccountId = idTokenClaims.oid || idTokenClaims.sub;\n            const accountInfo: AccountInfo = {\n                homeAccountId: cachedIdToken.homeAccountId,\n                environment: cachedIdToken.environment,\n                tenantId: cachedIdToken.realm,\n                username: Constants.EMPTY_STRING,\n                localAccountId: localAccountId || Constants.EMPTY_STRING,\n            };\n\n            cachedAccount = this.cacheManager.readAccountFromCache(accountInfo);\n        }\n\n        // increment telemetry cache hit counter\n        if (this.config.serverTelemetryManager) {\n            this.config.serverTelemetryManager.incrementCacheHits();\n        }\n\n        return ResponseHandler.generateAuthenticationResult(\n            this.cryptoUtils,\n            this.authority,\n            {\n                account: cachedAccount,\n                accessToken: cachedAccessToken,\n                idToken: cachedIdToken,\n                refreshToken: null,\n                appMetadata: null,\n            },\n            true,\n            request,\n            idTokenClaims\n        );\n    }\n\n    /**\n     * read idtoken from cache, this is a specific implementation for OBO as the requirements differ from a generic lookup in the cacheManager\n     * Certain use cases of OBO flow do not expect an idToken in the cache/or from the service\n     * @param atHomeAccountId - account id\n     */\n    private readIdTokenFromCacheForOBO(\n        atHomeAccountId: string\n    ): IdTokenEntity | null {\n        const idTokenFilter: CredentialFilter = {\n            homeAccountId: atHomeAccountId,\n            environment:\n                this.authority.canonicalAuthorityUrlComponents.HostNameAndPort,\n            credentialType: CredentialType.ID_TOKEN,\n            clientId: this.config.authOptions.clientId,\n            realm: this.authority.tenant,\n        };\n\n        const idTokenMap: Map<string, IdTokenEntity> =\n            this.cacheManager.getIdTokensByFilter(idTokenFilter);\n\n        // When acquiring a token on behalf of an application, there might not be an id token in the cache\n        if (Object.values(idTokenMap).length < 1) {\n            return null;\n        }\n        return Object.values(idTokenMap)[0] as IdTokenEntity;\n    }\n\n    /**\n     * Fetches the cached access token based on incoming assertion\n     * @param clientId - client id\n     * @param request - developer provided CommonOnBehalfOfRequest\n     */\n    private readAccessTokenFromCacheForOBO(\n        clientId: string,\n        request: CommonOnBehalfOfRequest\n    ) {\n        const authScheme =\n            request.authenticationScheme || AuthenticationScheme.BEARER;\n        /*\n         * Distinguish between Bearer and PoP/SSH token cache types\n         * Cast to lowercase to handle \"bearer\" from ADFS\n         */\n        const credentialType =\n            authScheme &&\n            authScheme.toLowerCase() !==\n                AuthenticationScheme.BEARER.toLowerCase()\n                ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME\n                : CredentialType.ACCESS_TOKEN;\n\n        const accessTokenFilter: CredentialFilter = {\n            credentialType: credentialType,\n            clientId,\n            target: ScopeSet.createSearchScopes(this.scopeSet.asArray()),\n            tokenType: authScheme,\n            keyId: request.sshKid,\n            requestedClaimsHash: request.requestedClaimsHash,\n            userAssertionHash: this.userAssertionHash,\n        };\n\n        const accessTokens =\n            this.cacheManager.getAccessTokensByFilter(accessTokenFilter);\n\n        const numAccessTokens = accessTokens.length;\n        if (numAccessTokens < 1) {\n            return null;\n        } else if (numAccessTokens > 1) {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.multipleMatchingTokens\n            );\n        }\n\n        return accessTokens[0] as AccessTokenEntity;\n    }\n\n    /**\n     * Make a network call to the server requesting credentials\n     * @param request - developer provided CommonOnBehalfOfRequest\n     * @param authority - authority object\n     */\n    private async executeTokenRequest(\n        request: CommonOnBehalfOfRequest,\n        authority: Authority,\n        userAssertionHash: string\n    ): Promise<AuthenticationResult | null> {\n        const queryParametersString = this.createTokenQueryParameters(request);\n        const endpoint = UrlString.appendQueryString(\n            authority.tokenEndpoint,\n            queryParametersString\n        );\n        const requestBody = await this.createTokenRequestBody(request);\n        const headers: Record<string, string> =\n            this.createTokenRequestHeaders();\n        const thumbprint: RequestThumbprint = {\n            clientId: this.config.authOptions.clientId,\n            authority: request.authority,\n            scopes: request.scopes,\n            claims: request.claims,\n            authenticationScheme: request.authenticationScheme,\n            resourceRequestMethod: request.resourceRequestMethod,\n            resourceRequestUri: request.resourceRequestUri,\n            shrClaims: request.shrClaims,\n            sshKid: request.sshKid,\n        };\n\n        const reqTimestamp = TimeUtils.nowSeconds();\n        const response = await this.executePostToTokenEndpoint(\n            endpoint,\n            requestBody,\n            headers,\n            thumbprint,\n            request.correlationId\n        );\n\n        const responseHandler = new ResponseHandler(\n            this.config.authOptions.clientId,\n            this.cacheManager,\n            this.cryptoUtils,\n            this.logger,\n            this.config.serializableCache,\n            this.config.persistencePlugin\n        );\n\n        responseHandler.validateTokenResponse(response.body);\n        const tokenResponse = await responseHandler.handleServerTokenResponse(\n            response.body,\n            this.authority,\n            reqTimestamp,\n            request,\n            undefined,\n            userAssertionHash\n        );\n\n        return tokenResponse;\n    }\n\n    /**\n     * generate a server request in accepable format\n     * @param request - developer provided CommonOnBehalfOfRequest\n     */\n    private async createTokenRequestBody(\n        request: CommonOnBehalfOfRequest\n    ): Promise<string> {\n        const parameters = new Map<string, string>();\n\n        RequestParameterBuilder.addClientId(\n            parameters,\n            this.config.authOptions.clientId\n        );\n\n        RequestParameterBuilder.addScopes(parameters, request.scopes);\n\n        RequestParameterBuilder.addGrantType(parameters, GrantType.JWT_BEARER);\n\n        RequestParameterBuilder.addClientInfo(parameters);\n\n        RequestParameterBuilder.addLibraryInfo(\n            parameters,\n            this.config.libraryInfo\n        );\n        RequestParameterBuilder.addApplicationTelemetry(\n            parameters,\n            this.config.telemetry.application\n        );\n        RequestParameterBuilder.addThrottling(parameters);\n\n        if (this.serverTelemetryManager) {\n            RequestParameterBuilder.addServerTelemetry(\n                parameters,\n                this.serverTelemetryManager\n            );\n        }\n\n        const correlationId =\n            request.correlationId ||\n            this.config.cryptoInterface.createNewGuid();\n        RequestParameterBuilder.addCorrelationId(parameters, correlationId);\n\n        RequestParameterBuilder.addRequestTokenUse(\n            parameters,\n            AADServerParamKeys.ON_BEHALF_OF\n        );\n\n        RequestParameterBuilder.addOboAssertion(\n            parameters,\n            request.oboAssertion\n        );\n\n        if (this.config.clientCredentials.clientSecret) {\n            RequestParameterBuilder.addClientSecret(\n                parameters,\n                this.config.clientCredentials.clientSecret\n            );\n        }\n\n        const clientAssertion: ClientAssertion | undefined =\n            this.config.clientCredentials.clientAssertion;\n\n        if (clientAssertion) {\n            RequestParameterBuilder.addClientAssertion(\n                parameters,\n                await getClientAssertion(\n                    clientAssertion.assertion,\n                    this.config.authOptions.clientId,\n                    request.resourceRequestUri\n                )\n            );\n            RequestParameterBuilder.addClientAssertionType(\n                parameters,\n                clientAssertion.assertionType\n            );\n        }\n\n        if (\n            request.claims ||\n            (this.config.authOptions.clientCapabilities &&\n                this.config.authOptions.clientCapabilities.length > 0)\n        ) {\n            RequestParameterBuilder.addClaims(\n                parameters,\n                request.claims,\n                this.config.authOptions.clientCapabilities\n            );\n        }\n\n        return UrlUtils.mapToQueryString(parameters);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3843, "column": 0}, "map": {"version":3,"file":"ConfidentialClientApplication.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/client/ConfidentialClientApplication.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\n// AADAuthorityConstants\n\nimport { ClientApplication } from \"./ClientApplication.js\";\nimport { Configuration } from \"../config/Configuration.js\";\nimport { ClientAssertion } from \"./ClientAssertion.js\";\nimport {\n    Constants as NodeConstants,\n    ApiId,\n    REGION_ENVIRONMENT_VARIABLE,\n    MSAL_FORCE_REGION,\n} from \"../utils/Constants.js\";\nimport {\n    CommonClientCredentialRequest,\n    CommonOnBehalfOfRequest,\n    AuthenticationResult,\n    AzureRegionConfiguration,\n    AuthError,\n    IAppTokenProvider,\n    OIDC_DEFAULT_SCOPES,\n    UrlString,\n    AADAuthorityConstants,\n    createClientAuthError,\n    ClientAuthErrorCodes,\n    ClientAssertion as ClientAssertionType,\n    getClientAssertion,\n    AzureRegion,\n} from \"@azure/msal-common/node\";\nimport { IConfidentialClientApplication } from \"./IConfidentialClientApplication.js\";\nimport { OnBehalfOfRequest } from \"../request/OnBehalfOfRequest.js\";\nimport { ClientCredentialRequest } from \"../request/ClientCredentialRequest.js\";\nimport { ClientCredentialClient } from \"./ClientCredentialClient.js\";\nimport { OnBehalfOfClient } from \"./OnBehalfOfClient.js\";\n\n/**\n *  This class is to be used to acquire tokens for confidential client applications (webApp, webAPI). Confidential client applications\n *  will configure application secrets, client certificates/assertions as applicable\n * @public\n */\nexport class ConfidentialClientApplication\n    extends ClientApplication\n    implements IConfidentialClientApplication\n{\n    private appTokenProvider?: IAppTokenProvider;\n\n    /**\n     * Constructor for the ConfidentialClientApplication\n     *\n     * Required attributes in the Configuration object are:\n     * - clientID: the application ID of your application. You can obtain one by registering your application with our application registration portal\n     * - authority: the authority URL for your application.\n     * - client credential: Must set either client secret, certificate, or assertion for confidential clients. You can obtain a client secret from the application registration portal.\n     *\n     * In Azure AD, authority is a URL indicating of the form https://login.microsoftonline.com/\\{Enter_the_Tenant_Info_Here\\}.\n     * If your application supports Accounts in one organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).\n     * If your application supports Accounts in any organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with organizations.\n     * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace \"Enter_the_Tenant_Info_Here\" value with common.\n     * To restrict support to Personal Microsoft accounts only, replace \"Enter_the_Tenant_Info_Here\" value with consumers.\n     *\n     * In Azure B2C, authority is of the form https://\\{instance\\}/tfp/\\{tenant\\}/\\{policyName\\}/\n     * Full B2C functionality will be available in this library in future versions.\n     *\n     * @param Configuration - configuration object for the MSAL ConfidentialClientApplication instance\n     */\n    constructor(configuration: Configuration) {\n        super(configuration);\n\n        const clientSecretNotEmpty = !!this.config.auth.clientSecret;\n        const clientAssertionNotEmpty = !!this.config.auth.clientAssertion;\n        const certificateNotEmpty =\n            (!!this.config.auth.clientCertificate?.thumbprint ||\n                !!this.config.auth.clientCertificate?.thumbprintSha256) &&\n            !!this.config.auth.clientCertificate?.privateKey;\n\n        /*\n         * If app developer configures this callback, they don't need a credential\n         * i.e. AzureSDK can get token from Managed Identity without a cert / secret\n         */\n        if (this.appTokenProvider) {\n            return;\n        }\n\n        // Check that at most one credential is set on the application\n        if (\n            (clientSecretNotEmpty && clientAssertionNotEmpty) ||\n            (clientAssertionNotEmpty && certificateNotEmpty) ||\n            (clientSecretNotEmpty && certificateNotEmpty)\n        ) {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.invalidClientCredential\n            );\n        }\n\n        if (this.config.auth.clientSecret) {\n            this.clientSecret = this.config.auth.clientSecret;\n            return;\n        }\n\n        if (this.config.auth.clientAssertion) {\n            this.developerProvidedClientAssertion =\n                this.config.auth.clientAssertion;\n            return;\n        }\n\n        if (!certificateNotEmpty) {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.invalidClientCredential\n            );\n        } else {\n            this.clientAssertion = !!this.config.auth.clientCertificate\n                .thumbprintSha256\n                ? ClientAssertion.fromCertificateWithSha256Thumbprint(\n                      this.config.auth.clientCertificate.thumbprintSha256,\n                      this.config.auth.clientCertificate.privateKey,\n                      this.config.auth.clientCertificate.x5c\n                  )\n                : ClientAssertion.fromCertificate(\n                      // guaranteed to be a string, due to prior error checking in this function\n                      this.config.auth.clientCertificate.thumbprint as string,\n                      this.config.auth.clientCertificate.privateKey,\n                      this.config.auth.clientCertificate.x5c\n                  );\n        }\n        this.appTokenProvider = undefined;\n    }\n\n    /**\n     * This extensibility point only works for the client_credential flow, i.e. acquireTokenByClientCredential and\n     * is meant for Azure SDK to enhance Managed Identity support.\n     *\n     * @param IAppTokenProvider  - Extensibility interface, which allows the app developer to return a token from a custom source.\n     */\n    SetAppTokenProvider(provider: IAppTokenProvider): void {\n        this.appTokenProvider = provider;\n    }\n\n    /**\n     * Acquires tokens from the authority for the application (not for an end user).\n     */\n    public async acquireTokenByClientCredential(\n        request: ClientCredentialRequest\n    ): Promise<AuthenticationResult | null> {\n        this.logger.info(\n            \"acquireTokenByClientCredential called\",\n            request.correlationId\n        );\n\n        // If there is a client assertion present in the request, it overrides the one present in the client configuration\n        let clientAssertion: ClientAssertionType | undefined;\n        if (request.clientAssertion) {\n            clientAssertion = {\n                assertion: await getClientAssertion(\n                    request.clientAssertion,\n                    this.config.auth.clientId\n                    // tokenEndpoint will be undefined. resourceRequestUri is omitted in ClientCredentialRequest\n                ),\n                assertionType: NodeConstants.JWT_BEARER_ASSERTION_TYPE,\n            };\n        }\n\n        const baseRequest = await this.initializeBaseRequest(request);\n\n        // valid base request should not contain oidc scopes in this grant type\n        const validBaseRequest = {\n            ...baseRequest,\n            scopes: baseRequest.scopes.filter(\n                (scope: string) => !OIDC_DEFAULT_SCOPES.includes(scope)\n            ),\n        };\n\n        const validRequest: CommonClientCredentialRequest = {\n            ...request,\n            ...validBaseRequest,\n            clientAssertion,\n        };\n\n        /*\n         * valid request should not have \"common\" or \"organizations\" in lieu of the tenant_id in the authority in the auth configuration\n         * example authority: \"https://login.microsoftonline.com/TenantId\",\n         */\n        const authority = new UrlString(validRequest.authority);\n        const tenantId = authority.getUrlComponents().PathSegments[0];\n        if (\n            Object.values(AADAuthorityConstants).includes(\n                tenantId as AADAuthorityConstants\n            )\n        ) {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.missingTenantIdError\n            );\n        }\n\n        /*\n         * if this env variable is set, and the developer provided region isn't defined and isn't \"DisableMsalForceRegion\",\n         * MSAL shall opt-in to ESTS-R with the value of this variable\n         */\n        const ENV_MSAL_FORCE_REGION: AzureRegion | undefined =\n            process.env[MSAL_FORCE_REGION];\n\n        let region: AzureRegion | undefined;\n        if (validRequest.azureRegion !== \"DisableMsalForceRegion\") {\n            if (!validRequest.azureRegion && ENV_MSAL_FORCE_REGION) {\n                region = ENV_MSAL_FORCE_REGION;\n            } else {\n                region = validRequest.azureRegion;\n            }\n        }\n\n        const azureRegionConfiguration: AzureRegionConfiguration = {\n            azureRegion: region,\n            environmentRegion: process.env[REGION_ENVIRONMENT_VARIABLE],\n        };\n\n        const serverTelemetryManager = this.initializeServerTelemetryManager(\n            ApiId.acquireTokenByClientCredential,\n            validRequest.correlationId,\n            validRequest.skipCache\n        );\n        try {\n            const discoveredAuthority = await this.createAuthority(\n                validRequest.authority,\n                validRequest.correlationId,\n                azureRegionConfiguration,\n                request.azureCloudOptions\n            );\n            const clientCredentialConfig =\n                await this.buildOauthClientConfiguration(\n                    discoveredAuthority,\n                    validRequest.correlationId,\n                    \"\",\n                    serverTelemetryManager\n                );\n            const clientCredentialClient = new ClientCredentialClient(\n                clientCredentialConfig,\n                this.appTokenProvider\n            );\n            this.logger.verbose(\n                \"Client credential client created\",\n                validRequest.correlationId\n            );\n            return await clientCredentialClient.acquireToken(validRequest);\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(validRequest.correlationId);\n            }\n            serverTelemetryManager.cacheFailedRequest(e);\n            throw e;\n        }\n    }\n\n    /**\n     * Acquires tokens from the authority for the application.\n     *\n     * Used in scenarios where the current app is a middle-tier service which was called with a token\n     * representing an end user. The current app can use the token (oboAssertion) to request another\n     * token to access downstream web API, on behalf of that user.\n     *\n     * The current middle-tier app has no user interaction to obtain consent.\n     * See how to gain consent upfront for your middle-tier app from this article.\n     * https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-on-behalf-of-flow#gaining-consent-for-the-middle-tier-application\n     */\n    public async acquireTokenOnBehalfOf(\n        request: OnBehalfOfRequest\n    ): Promise<AuthenticationResult | null> {\n        this.logger.info(\n            \"acquireTokenOnBehalfOf called\",\n            request.correlationId\n        );\n        const validRequest: CommonOnBehalfOfRequest = {\n            ...request,\n            ...(await this.initializeBaseRequest(request)),\n        };\n        try {\n            const discoveredAuthority = await this.createAuthority(\n                validRequest.authority,\n                validRequest.correlationId,\n                undefined,\n                request.azureCloudOptions\n            );\n            const onBehalfOfConfig = await this.buildOauthClientConfiguration(\n                discoveredAuthority,\n                validRequest.correlationId,\n                \"\",\n                undefined\n            );\n            const oboClient = new OnBehalfOfClient(onBehalfOfConfig);\n            this.logger.verbose(\n                \"On behalf of client created\",\n                validRequest.correlationId\n            );\n            return await oboClient.acquireToken(validRequest);\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(validRequest.correlationId);\n            }\n            throw e;\n        }\n    }\n}\n"],"names":["NodeConstants"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4030, "column": 0}, "map": {"version":3,"file":"TimeUtils.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/utils/TimeUtils.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * @internal\n * Checks if a given date string is in ISO 8601 format.\n *\n * @param dateString - The date string to be checked.\n * @returns boolean - Returns true if the date string is in ISO 8601 format, otherwise false.\n */\nexport function isIso8601(dateString: number | string): boolean {\n    if (typeof dateString !== \"string\") {\n        return false;\n    }\n\n    const date = new Date(dateString);\n    return !isNaN(date.getTime()) && date.toISOString() === dateString;\n}\n"],"names":[],"mappings":";;;;AAAA;;;CAGG,GAEH;;;;;;CAMG,GACG,SAAU,SAAS,CAAC,UAA2B,EAAA;IACjD,IAAI,OAAO,UAAU,KAAK,QAAQ,EAAE;QAChC,OAAO,KAAK,CAAC;IAChB,CAAA;IAED,MAAM,IAAI,GAAG,IAAI,IAAI,CAAC,UAAU,CAAC,CAAC;IAClC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,IAAI,IAAI,CAAC,WAAW,EAAE,KAAK,UAAU,CAAC;AACvE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4058, "column": 0}, "map": {"version":3,"file":"HttpClientWithRetries.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/network/HttpClientWithRetries.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    HeaderNames,\n    INetworkModule,\n    Logger,\n    NetworkRequestOptions,\n    NetworkResponse,\n} from \"@azure/msal-common/node\";\nimport { IHttpRetryPolicy } from \"../retry/IHttpRetryPolicy.js\";\nimport { HttpMethod } from \"../utils/Constants.js\";\n\nexport class HttpClientWithRetries implements INetworkModule {\n    private httpClientNoRetries: INetworkModule;\n    private retryPolicy: IHttpRetryPolicy;\n    private logger: Logger;\n\n    constructor(\n        httpClientNoRetries: INetworkModule,\n        retryPolicy: IHttpRetryPolicy,\n        logger: Logger\n    ) {\n        this.httpClientNoRetries = httpClientNoRetries;\n        this.retryPolicy = retryPolicy;\n        this.logger = logger;\n    }\n\n    private async sendNetworkRequestAsyncHelper<T>(\n        httpMethod: HttpMethod,\n        url: string,\n        options?: NetworkRequestOptions\n    ): Promise<NetworkResponse<T>> {\n        if (httpMethod === HttpMethod.GET) {\n            return this.httpClientNoRetries.sendGetRequestAsync(url, options);\n        } else {\n            return this.httpClientNoRetries.sendPostRequestAsync(url, options);\n        }\n    }\n\n    private async sendNetworkRequestAsync<T>(\n        httpMethod: HttpMethod,\n        url: string,\n        options?: NetworkRequestOptions\n    ): Promise<NetworkResponse<T>> {\n        // the underlying network module (custom or HttpClient) will make the call\n        let response: NetworkResponse<T> =\n            await this.sendNetworkRequestAsyncHelper(httpMethod, url, options);\n\n        if (\"isNewRequest\" in this.retryPolicy) {\n            this.retryPolicy.isNewRequest = true;\n        }\n\n        let currentRetry: number = 0;\n        while (\n            await this.retryPolicy.pauseForRetry(\n                response.status,\n                currentRetry,\n                this.logger,\n                response.headers[HeaderNames.RETRY_AFTER]\n            )\n        ) {\n            response = await this.sendNetworkRequestAsyncHelper(\n                httpMethod,\n                url,\n                options\n            );\n            currentRetry++;\n        }\n\n        return response;\n    }\n\n    public async sendGetRequestAsync<T>(\n        url: string,\n        options?: NetworkRequestOptions\n    ): Promise<NetworkResponse<T>> {\n        return this.sendNetworkRequestAsync(HttpMethod.GET, url, options);\n    }\n\n    public async sendPostRequestAsync<T>(\n        url: string,\n        options?: NetworkRequestOptions\n    ): Promise<NetworkResponse<T>> {\n        return this.sendNetworkRequestAsync(HttpMethod.POST, url, options);\n    }\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;;;CAGG,SAYU,qBAAqB,CAAA;IAK9B,WAAA,CACI,mBAAmC,EACnC,WAA6B,EAC7B,MAAc,CAAA;QAEd,IAAI,CAAC,mBAAmB,GAAG,mBAAmB,CAAC;QAC/C,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;KACxB;IAEO,MAAM,6BAA6B,CACvC,UAAsB,EACtB,GAAW,EACX,OAA+B,EAAA;QAE/B,IAAI,UAAU,4KAAK,aAAU,CAAC,GAAG,EAAE;YAC/B,OAAO,IAAI,CAAC,mBAAmB,CAAC,mBAAmB,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;QACrE,CAAA,MAAM;YACH,OAAO,IAAI,CAAC,mBAAmB,CAAC,oBAAoB,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;QACtE,CAAA;KACJ;IAEO,MAAM,uBAAuB,CACjC,UAAsB,EACtB,GAAW,EACX,OAA+B,EAAA;;QAG/B,IAAI,QAAQ,GACR,MAAM,IAAI,CAAC,6BAA6B,CAAC,UAAU,EAAE,GAAG,EAAE,OAAO,CAAC,CAAC;QAEvE,IAAI,cAAc,IAAI,IAAI,CAAC,WAAW,EAAE;YACpC,IAAI,CAAC,WAAW,CAAC,YAAY,GAAG,IAAI,CAAC;QACxC,CAAA;QAED,IAAI,YAAY,GAAW,CAAC,CAAC;QAC7B,MACI,MAAM,IAAI,CAAC,WAAW,CAAC,aAAa,CAChC,QAAQ,CAAC,MAAM,EACf,YAAY,EACZ,IAAI,CAAC,MAAM,EACX,QAAQ,CAAC,OAAO,0KAAC,cAAW,CAAC,WAAW,CAAC,CAC5C,CACH;YACE,QAAQ,GAAG,MAAM,IAAI,CAAC,6BAA6B,CAC/C,UAAU,EACV,GAAG,EACH,OAAO,CACV,CAAC;YACF,YAAY,EAAE,CAAC;QAClB,CAAA;QAED,OAAO,QAAQ,CAAC;KACnB;IAEM,MAAM,mBAAmB,CAC5B,GAAW,EACX,OAA+B,EAAA;QAE/B,OAAO,IAAI,CAAC,uBAAuB,wKAAC,aAAU,CAAC,GAAG,EAAE,GAAG,EAAE,OAAO,CAAC,CAAC;KACrE;IAEM,MAAM,oBAAoB,CAC7B,GAAW,EACX,OAA+B,EAAA;QAE/B,OAAO,IAAI,CAAC,uBAAuB,wKAAC,aAAU,CAAC,IAAI,EAAE,GAAG,EAAE,OAAO,CAAC,CAAC;KACtE;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4110, "column": 0}, "map": {"version":3,"file":"BaseManagedIdentitySource.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/client/ManagedIdentitySources/BaseManagedIdentitySource.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AuthError,\n    Authority,\n    ClientAuthErrorCodes,\n    Constants,\n    HeaderNames,\n    INetworkModule,\n    Logger,\n    NetworkRequestOptions,\n    NetworkResponse,\n    ResponseHandler,\n    ServerAuthorizationTokenResponse,\n    TimeUtils,\n    createClientAuthError,\n    AuthenticationResult,\n    UrlString,\n} from \"@azure/msal-common/node\";\nimport { ManagedIdentityId } from \"../../config/ManagedIdentityId.js\";\nimport { ManagedIdentityRequestParameters } from \"../../config/ManagedIdentityRequestParameters.js\";\nimport { CryptoProvider } from \"../../crypto/CryptoProvider.js\";\nimport { ManagedIdentityRequest } from \"../../request/ManagedIdentityRequest.js\";\nimport {\n    HttpMethod,\n    ManagedIdentityIdType,\n    ManagedIdentityQueryParameters,\n} from \"../../utils/Constants.js\";\nimport { ManagedIdentityTokenResponse } from \"../../response/ManagedIdentityTokenResponse.js\";\nimport { NodeStorage } from \"../../cache/NodeStorage.js\";\nimport {\n    ManagedIdentityErrorCodes,\n    createManagedIdentityError,\n} from \"../../error/ManagedIdentityError.js\";\nimport { isIso8601 } from \"../../utils/TimeUtils.js\";\nimport { HttpClientWithRetries } from \"../../network/HttpClientWithRetries.js\";\n\n/**\n * Managed Identity User Assigned Id Query Parameter Names\n */\nexport const ManagedIdentityUserAssignedIdQueryParameterNames = {\n    MANAGED_IDENTITY_CLIENT_ID_2017: \"clientid\", // 2017-09-01 API version\n    MANAGED_IDENTITY_CLIENT_ID: \"client_id\", // 2019+ API versions\n    MANAGED_IDENTITY_OBJECT_ID: \"object_id\",\n    MANAGED_IDENTITY_RESOURCE_ID_IMDS: \"msi_res_id\",\n    MANAGED_IDENTITY_RESOURCE_ID_NON_IMDS: \"mi_res_id\",\n} as const;\nexport type ManagedIdentityUserAssignedIdQueryParameterNames =\n    (typeof ManagedIdentityUserAssignedIdQueryParameterNames)[keyof typeof ManagedIdentityUserAssignedIdQueryParameterNames];\n\nexport abstract class BaseManagedIdentitySource {\n    protected logger: Logger;\n    private nodeStorage: NodeStorage;\n    private networkClient: INetworkModule;\n    private cryptoProvider: CryptoProvider;\n    private disableInternalRetries: boolean;\n\n    constructor(\n        logger: Logger,\n        nodeStorage: NodeStorage,\n        networkClient: INetworkModule,\n        cryptoProvider: CryptoProvider,\n        disableInternalRetries: boolean\n    ) {\n        this.logger = logger;\n        this.nodeStorage = nodeStorage;\n        this.networkClient = networkClient;\n        this.cryptoProvider = cryptoProvider;\n        this.disableInternalRetries = disableInternalRetries;\n    }\n\n    abstract createRequest(\n        request: string,\n        managedIdentityId: ManagedIdentityId\n    ): ManagedIdentityRequestParameters;\n\n    public async getServerTokenResponseAsync(\n        response: NetworkResponse<ManagedIdentityTokenResponse>,\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        _networkClient: INetworkModule,\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        _networkRequest: ManagedIdentityRequestParameters,\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        _networkRequestOptions: NetworkRequestOptions\n    ): Promise<ServerAuthorizationTokenResponse> {\n        return this.getServerTokenResponse(response);\n    }\n\n    public getServerTokenResponse(\n        response: NetworkResponse<ManagedIdentityTokenResponse>\n    ): ServerAuthorizationTokenResponse {\n        let refreshIn, expiresIn: number | undefined;\n        if (response.body.expires_on) {\n            // if the expires_on field in the response body is a string and in ISO 8601 format, convert it to a Unix timestamp (seconds since epoch)\n            if (isIso8601(response.body.expires_on)) {\n                response.body.expires_on =\n                    new Date(response.body.expires_on).getTime() / 1000;\n            }\n\n            expiresIn = response.body.expires_on - TimeUtils.nowSeconds();\n\n            // compute refresh_in as 1/2 of expires_in, but only if expires_in > 2h\n            if (expiresIn > 2 * 3600) {\n                refreshIn = expiresIn / 2;\n            }\n        }\n\n        const serverTokenResponse: ServerAuthorizationTokenResponse = {\n            status: response.status,\n\n            // success\n            access_token: response.body.access_token,\n            expires_in: expiresIn,\n            scope: response.body.resource,\n            token_type: response.body.token_type,\n            refresh_in: refreshIn,\n\n            // error\n            correlation_id:\n                response.body.correlation_id || response.body.correlationId,\n            error:\n                typeof response.body.error === \"string\"\n                    ? response.body.error\n                    : response.body.error?.code,\n            error_description:\n                response.body.message ||\n                (typeof response.body.error === \"string\"\n                    ? response.body.error_description\n                    : response.body.error?.message),\n            error_codes: response.body.error_codes,\n            timestamp: response.body.timestamp,\n            trace_id: response.body.trace_id,\n        };\n\n        return serverTokenResponse;\n    }\n\n    public async acquireTokenWithManagedIdentity(\n        managedIdentityRequest: ManagedIdentityRequest,\n        managedIdentityId: ManagedIdentityId,\n        fakeAuthority: Authority,\n        refreshAccessToken?: boolean\n    ): Promise<AuthenticationResult> {\n        const networkRequest: ManagedIdentityRequestParameters =\n            this.createRequest(\n                managedIdentityRequest.resource,\n                managedIdentityId\n            );\n\n        if (managedIdentityRequest.revokedTokenSha256Hash) {\n            this.logger.info(\n                `[Managed Identity] The following claims are present in the request: ${managedIdentityRequest.claims}`\n            );\n\n            networkRequest.queryParameters[\n                ManagedIdentityQueryParameters.SHA256_TOKEN_TO_REFRESH\n            ] = managedIdentityRequest.revokedTokenSha256Hash;\n        }\n\n        if (managedIdentityRequest.clientCapabilities?.length) {\n            const clientCapabilities: string =\n                managedIdentityRequest.clientCapabilities.toString();\n\n            this.logger.info(\n                `[Managed Identity] The following client capabilities are present in the request: ${clientCapabilities}`\n            );\n\n            networkRequest.queryParameters[\n                ManagedIdentityQueryParameters.XMS_CC\n            ] = clientCapabilities;\n        }\n\n        const headers: Record<string, string> = networkRequest.headers;\n        headers[HeaderNames.CONTENT_TYPE] = Constants.URL_FORM_CONTENT_TYPE;\n\n        const networkRequestOptions: NetworkRequestOptions = { headers };\n\n        if (Object.keys(networkRequest.bodyParameters).length) {\n            networkRequestOptions.body =\n                networkRequest.computeParametersBodyString();\n        }\n\n        /**\n         * Initializes the network client helper based on the retry policy configuration.\n         * If internal retries are disabled, it uses the provided network client directly.\n         * Otherwise, it wraps the network client with an HTTP client that supports retries.\n         */\n        const networkClientHelper: INetworkModule = this.disableInternalRetries\n            ? this.networkClient\n            : new HttpClientWithRetries(\n                  this.networkClient,\n                  networkRequest.retryPolicy,\n                  this.logger\n              );\n\n        const reqTimestamp = TimeUtils.nowSeconds();\n        let response: NetworkResponse<ManagedIdentityTokenResponse>;\n        try {\n            // Sources that send POST requests: Cloud Shell\n            if (networkRequest.httpMethod === HttpMethod.POST) {\n                response =\n                    await networkClientHelper.sendPostRequestAsync<ManagedIdentityTokenResponse>(\n                        networkRequest.computeUri(),\n                        networkRequestOptions\n                    );\n                // Sources that send GET requests: App Service, Azure Arc, IMDS, Service Fabric\n            } else {\n                response =\n                    await networkClientHelper.sendGetRequestAsync<ManagedIdentityTokenResponse>(\n                        networkRequest.computeUri(),\n                        networkRequestOptions\n                    );\n            }\n        } catch (error) {\n            if (error instanceof AuthError) {\n                throw error;\n            } else {\n                throw createClientAuthError(ClientAuthErrorCodes.networkError);\n            }\n        }\n\n        const responseHandler = new ResponseHandler(\n            managedIdentityId.id,\n            this.nodeStorage,\n            this.cryptoProvider,\n            this.logger,\n            null,\n            null\n        );\n\n        const serverTokenResponse: ServerAuthorizationTokenResponse =\n            await this.getServerTokenResponseAsync(\n                response,\n                networkClientHelper,\n                networkRequest,\n                networkRequestOptions\n            );\n\n        responseHandler.validateTokenResponse(\n            serverTokenResponse,\n            refreshAccessToken\n        );\n\n        // caches the token\n        return responseHandler.handleServerTokenResponse(\n            serverTokenResponse,\n            fakeAuthority,\n            reqTimestamp,\n            managedIdentityRequest\n        );\n    }\n\n    public getManagedIdentityUserAssignedIdQueryParameterKey(\n        managedIdentityIdType: ManagedIdentityIdType,\n        isImds?: boolean,\n        usesApi2017?: boolean\n    ): string {\n        switch (managedIdentityIdType) {\n            case ManagedIdentityIdType.USER_ASSIGNED_CLIENT_ID:\n                this.logger.info(\n                    `[Managed Identity] [API version ${\n                        usesApi2017 ? \"2017+\" : \"2019+\"\n                    }] Adding user assigned client id to the request.`\n                );\n                // The Machine Learning source uses the 2017-09-01 API version, which uses \"clientid\" instead of \"client_id\"\n                return usesApi2017\n                    ? ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_CLIENT_ID_2017\n                    : ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_CLIENT_ID;\n\n            case ManagedIdentityIdType.USER_ASSIGNED_RESOURCE_ID:\n                this.logger.info(\n                    \"[Managed Identity] Adding user assigned resource id to the request.\"\n                );\n                return isImds\n                    ? ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_RESOURCE_ID_IMDS\n                    : ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_RESOURCE_ID_NON_IMDS;\n\n            case ManagedIdentityIdType.USER_ASSIGNED_OBJECT_ID:\n                this.logger.info(\n                    \"[Managed Identity] Adding user assigned object id to the request.\"\n                );\n                return ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_OBJECT_ID;\n            default:\n                throw createManagedIdentityError(\n                    ManagedIdentityErrorCodes.invalidManagedIdentityIdType\n                );\n        }\n    }\n\n    public static getValidatedEnvVariableUrlString = (\n        envVariableStringName: string,\n        envVariable: string,\n        sourceName: string,\n        logger: Logger\n    ): string => {\n        try {\n            return new UrlString(envVariable).urlString;\n        } catch (error) {\n            logger.info(\n                `[Managed Identity] ${sourceName} managed identity is unavailable because the '${envVariableStringName}' environment variable is malformed.`\n            );\n\n            throw createManagedIdentityError(\n                ManagedIdentityErrorCodes\n                    .MsiEnvironmentVariableUrlMalformedErrorCodes[\n                    envVariableStringName\n                ]\n            );\n        }\n    };\n}\n"],"names":["ManagedIdentityErrorCodes.invalidManagedIdentityIdType","ManagedIdentityErrorCodes\r\n            .MsiEnvironmentVariableUrlMalformedErrorCodes"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4270, "column": 0}, "map": {"version":3,"file":"LinearRetryStrategy.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/retry/LinearRetryStrategy.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { IncomingHttpHeaders } from \"http\";\n\nexport class LinearRetryStrategy {\n    /**\n     * Calculates the number of milliseconds to sleep based on the `retry-after` HTTP header.\n     *\n     * @param retryHeader - The value of the `retry-after` HTTP header. This can be either a number of seconds\n     *                      or an HTTP date string.\n     * @returns The number of milliseconds to sleep before retrying the request. If the `retry-after` header is not\n     *          present or cannot be parsed, returns 0.\n     */\n    public calculateDelay(\n        retryHeader: IncomingHttpHeaders[\"retry-after\"],\n        minimumDelay: number\n    ): number {\n        if (!retryHeader) {\n            return minimumDelay;\n        }\n\n        // retry-after header is in seconds\n        let millisToSleep = Math.round(parseFloat(retryHeader) * 1000);\n\n        /*\n         * retry-after header is in HTTP Date format\n         * <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT\n         */\n        if (isNaN(millisToSleep)) {\n            // .valueOf() is needed to subtract dates in TypeScript\n            millisToSleep =\n                new Date(retryHeader).valueOf() - new Date().valueOf();\n        }\n\n        return Math.max(minimumDelay, millisToSleep);\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;;;CAGG,SAIU,mBAAmB,CAAA;IAC5B;;;;;;;KAOG,GACI,cAAc,CACjB,WAA+C,EAC/C,YAAoB,EAAA;QAEpB,IAAI,CAAC,WAAW,EAAE;YACd,OAAO,YAAY,CAAC;QACvB,CAAA;;QAGD,IAAI,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,WAAW,CAAC,GAAG,IAAI,CAAC,CAAC;QAE/D;;;SAGG,GACH,IAAI,KAAK,CAAC,aAAa,CAAC,EAAE;;YAEtB,aAAa,GACT,IAAI,IAAI,CAAC,WAAW,CAAC,CAAC,OAAO,EAAE,GAAG,IAAI,IAAI,EAAE,CAAC,OAAO,EAAE,CAAC;QAC9D,CAAA;QAED,OAAO,IAAI,CAAC,GAAG,CAAC,YAAY,EAAE,aAAa,CAAC,CAAC;KAChD;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4309, "column": 0}, "map": {"version":3,"file":"DefaultManagedIdentityRetryPolicy.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/retry/DefaultManagedIdentityRetryPolicy.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { IncomingHttpHeaders } from \"http\";\nimport { HttpStatus, Logger } from \"@azure/msal-common\";\nimport { IHttpRetryPolicy } from \"./IHttpRetryPolicy.js\";\nimport { LinearRetryStrategy } from \"./LinearRetryStrategy.js\";\n\nexport const DEFAULT_MANAGED_IDENTITY_MAX_RETRIES: number = 3; // referenced in unit test\nconst DEFAULT_MANAGED_IDENTITY_RETRY_DELAY_MS: number = 1000;\nconst DEFAULT_MANAGED_IDENTITY_HTTP_STATUS_CODES_TO_RETRY_ON: Array<number> = [\n    HttpStatus.NOT_FOUND,\n    HttpStatus.REQUEST_TIMEOUT,\n    HttpStatus.TOO_MANY_REQUESTS,\n    HttpStatus.SERVER_ERROR,\n    HttpStatus.SERVICE_UNAVAILABLE,\n    HttpStatus.GATEWAY_TIMEOUT,\n];\n\nexport class DefaultManagedIdentityRetryPolicy implements IHttpRetryPolicy {\n    /*\n     * this is defined here as a static variable despite being defined as a constant outside of the\n     * class because it needs to be overridden in the unit tests so that the unit tests run faster\n     */\n    static get DEFAULT_MANAGED_IDENTITY_RETRY_DELAY_MS(): number {\n        return DEFAULT_MANAGED_IDENTITY_RETRY_DELAY_MS;\n    }\n\n    private linearRetryStrategy: LinearRetryStrategy =\n        new LinearRetryStrategy();\n\n    async pauseForRetry(\n        httpStatusCode: number,\n        currentRetry: number,\n        logger: Logger,\n        retryAfterHeader: IncomingHttpHeaders[\"retry-after\"]\n    ): Promise<boolean> {\n        if (\n            DEFAULT_MANAGED_IDENTITY_HTTP_STATUS_CODES_TO_RETRY_ON.includes(\n                httpStatusCode\n            ) &&\n            currentRetry < DEFAULT_MANAGED_IDENTITY_MAX_RETRIES\n        ) {\n            const retryAfterDelay: number =\n                this.linearRetryStrategy.calculateDelay(\n                    retryAfterHeader,\n                    DefaultManagedIdentityRetryPolicy.DEFAULT_MANAGED_IDENTITY_RETRY_DELAY_MS\n                );\n\n            logger.verbose(\n                `Retrying request in ${retryAfterDelay}ms (retry attempt: ${\n                    currentRetry + 1\n                })`\n            );\n\n            // pause execution for the calculated delay\n            await new Promise((resolve) => {\n                // retryAfterHeader value of 0 evaluates to false, and DEFAULT_MANAGED_IDENTITY_RETRY_DELAY_MS will be used\n                return setTimeout(resolve, retryAfterDelay);\n            });\n\n            return true;\n        }\n\n        // if the status code is not retriable or max retries have been reached, do not retry\n        return false;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;AAAA;;;CAGG,GAOU,MAAA,oCAAoC,GAAW,EAAE,CAAA,0BAAA;AAC9D,MAAM,uCAAuC,GAAW,IAAI,CAAC;AAC7D,MAAM,sDAAsD,GAAkB;6KAC1E,aAAU,CAAC,SAAS;IACpB,sLAAU,CAAC,eAAe;6KAC1B,aAAU,CAAC,iBAAiB;6KAC5B,aAAU,CAAC,YAAY;6KACvB,aAAU,CAAC,mBAAmB;6KAC9B,aAAU,CAAC,eAAe;CAC7B,CAAC;MAEW,iCAAiC,CAAA;IAA9C,WAAA,EAAA;QASY,IAAA,CAAA,mBAAmB,GACvB,IAAI,uMAAmB,EAAE,CAAC;KAsCjC;IA/CG;;;KAGG,GACH,WAAW,uCAAuC,GAAA;QAC9C,OAAO,uCAAuC,CAAC;KAClD;IAKD,MAAM,aAAa,CACf,cAAsB,EACtB,YAAoB,EACpB,MAAc,EACd,gBAAoD,EAAA;QAEpD,IACI,sDAAsD,CAAC,QAAQ,CAC3D,cAAc,CACjB,IACD,YAAY,GAAG,oCAAoC,EACrD;YACE,MAAM,eAAe,GACjB,IAAI,CAAC,mBAAmB,CAAC,cAAc,CACnC,gBAAgB,EAChB,iCAAiC,CAAC,uCAAuC,CAC5E,CAAC;YAEN,MAAM,CAAC,OAAO,CACV,CAAuB,oBAAA,EAAA,eAAe,CAClC,mBAAA,EAAA,YAAY,GAAG,CACnB,CAAG,CAAA,CAAA,CACN,CAAC;;YAGF,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,KAAI;;gBAE1B,OAAO,UAAU,CAAC,OAAO,EAAE,eAAe,CAAC,CAAC;YAChD,CAAC,CAAC,CAAC;YAEH,OAAO,IAAI,CAAC;QACf,CAAA;;QAGD,OAAO,KAAK,CAAC;KAChB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4364, "column": 0}, "map": {"version":3,"file":"ManagedIdentityRequestParameters.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/config/ManagedIdentityRequestParameters.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    RequestParameterBuilder,\n    UrlString,\n    UrlUtils,\n} from \"@azure/msal-common/node\";\nimport { DefaultManagedIdentityRetryPolicy } from \"../retry/DefaultManagedIdentityRetryPolicy.js\";\nimport { HttpMethod, RetryPolicies } from \"../utils/Constants.js\";\n\nexport class ManagedIdentityRequestParameters {\n    private _baseEndpoint: string;\n    public httpMethod: HttpMethod;\n    public headers: Record<string, string>;\n    public bodyParameters: Record<string, string>;\n    public queryParameters: Record<string, string>;\n    public retryPolicy: RetryPolicies;\n\n    constructor(\n        httpMethod: HttpMethod,\n        endpoint: string,\n        retryPolicy?: RetryPolicies\n    ) {\n        this.httpMethod = httpMethod;\n        this._baseEndpoint = endpoint;\n        this.headers = {} as Record<string, string>;\n        this.bodyParameters = {} as Record<string, string>;\n        this.queryParameters = {} as Record<string, string>;\n\n        this.retryPolicy =\n            retryPolicy || new DefaultManagedIdentityRetryPolicy();\n    }\n\n    public computeUri(): string {\n        const parameters = new Map<string, string>();\n\n        if (this.queryParameters) {\n            RequestParameterBuilder.addExtraQueryParameters(\n                parameters,\n                this.queryParameters\n            );\n        }\n\n        const queryParametersString = UrlUtils.mapToQueryString(parameters);\n\n        return UrlString.appendQueryString(\n            this._baseEndpoint,\n            queryParametersString\n        );\n    }\n\n    public computeParametersBodyString(): string {\n        const parameters = new Map<string, string>();\n\n        if (this.bodyParameters) {\n            RequestParameterBuilder.addExtraQueryParameters(\n                parameters,\n                this.bodyParameters\n            );\n        }\n\n        return UrlUtils.mapToQueryString(parameters);\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;;CAGG,SAUU,gCAAgC,CAAA;IAQzC,WAAA,CACI,UAAsB,EACtB,QAAgB,EAChB,WAA2B,CAAA;QAE3B,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;QAC7B,IAAI,CAAC,aAAa,GAAG,QAAQ,CAAC;QAC9B,IAAI,CAAC,OAAO,GAAG,CAAA,CAA4B,CAAC;QAC5C,IAAI,CAAC,cAAc,GAAG,CAAA,CAA4B,CAAC;QACnD,IAAI,CAAC,eAAe,GAAG,CAAA,CAA4B,CAAC;QAEpD,IAAI,CAAC,WAAW,GACZ,WAAW,IAAI,mMAAI,oCAAiC,EAAE,CAAC;KAC9D;IAEM,UAAU,GAAA;QACb,MAAM,UAAU,GAAG,IAAI,GAAG,EAAkB,CAAC;QAE7C,IAAI,IAAI,CAAC,eAAe,EAAE;wPACtB,0BAAuB,CAAC,uBAAuB,CAC3C,UAAU,EACV,IAAI,CAAC,eAAe,CACvB,CAAC;QACL,CAAA;QAED,MAAM,qBAAqB,+MAAG,WAAQ,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;QAEpE,8KAAO,YAAS,CAAC,iBAAiB,CAC9B,IAAI,CAAC,aAAa,EAClB,qBAAqB,CACxB,CAAC;KACL;IAEM,2BAA2B,GAAA;QAC9B,MAAM,UAAU,GAAG,IAAI,GAAG,EAAkB,CAAC;QAE7C,IAAI,IAAI,CAAC,cAAc,EAAE;wPACrB,0BAAuB,CAAC,uBAAuB,CAC3C,UAAU,EACV,IAAI,CAAC,cAAc,CACtB,CAAC;QACL,CAAA;QAED,mNAAO,WAAQ,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;KAChD;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4410, "column": 0}, "map": {"version":3,"file":"AppService.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/client/ManagedIdentitySources/AppService.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { INetworkModule, Logger } from \"@azure/msal-common/node\";\nimport { BaseManagedIdentitySource } from \"./BaseManagedIdentitySource.js\";\nimport {\n    HttpMethod,\n    ManagedIdentityEnvironmentVariableNames,\n    ManagedIdentitySourceNames,\n    ManagedIdentityIdType,\n    ManagedIdentityQueryParameters,\n    ManagedIdentityHeaders,\n} from \"../../utils/Constants.js\";\nimport { CryptoProvider } from \"../../crypto/CryptoProvider.js\";\nimport { ManagedIdentityRequestParameters } from \"../../config/ManagedIdentityRequestParameters.js\";\nimport { ManagedIdentityId } from \"../../config/ManagedIdentityId.js\";\nimport { NodeStorage } from \"../../cache/NodeStorage.js\";\n\n// MSI Constants. Docs for MSI are available here https://docs.microsoft.com/azure/app-service/overview-managed-identity\nconst APP_SERVICE_MSI_API_VERSION: string = \"2019-08-01\";\n\n/**\n * Original source of code: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/AppServiceManagedIdentitySource.cs\n */\nexport class AppService extends BaseManagedIdentitySource {\n    private identityEndpoint: string;\n    private identityHeader: string;\n\n    constructor(\n        logger: Logger,\n        nodeStorage: NodeStorage,\n        networkClient: INetworkModule,\n        cryptoProvider: CryptoProvider,\n        disableInternalRetries: boolean,\n        identityEndpoint: string,\n        identityHeader: string\n    ) {\n        super(\n            logger,\n            nodeStorage,\n            networkClient,\n            cryptoProvider,\n            disableInternalRetries\n        );\n\n        this.identityEndpoint = identityEndpoint;\n        this.identityHeader = identityHeader;\n    }\n\n    public static getEnvironmentVariables(): Array<string | undefined> {\n        const identityEndpoint: string | undefined =\n            process.env[\n                ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT\n            ];\n        const identityHeader: string | undefined =\n            process.env[\n                ManagedIdentityEnvironmentVariableNames.IDENTITY_HEADER\n            ];\n\n        return [identityEndpoint, identityHeader];\n    }\n\n    public static tryCreate(\n        logger: Logger,\n        nodeStorage: NodeStorage,\n        networkClient: INetworkModule,\n        cryptoProvider: CryptoProvider,\n        disableInternalRetries: boolean\n    ): AppService | null {\n        const [identityEndpoint, identityHeader] =\n            AppService.getEnvironmentVariables();\n\n        // if either of the identity endpoint or identity header variables are undefined, this MSI provider is unavailable.\n        if (!identityEndpoint || !identityHeader) {\n            logger.info(\n                `[Managed Identity] ${ManagedIdentitySourceNames.APP_SERVICE} managed identity is unavailable because one or both of the '${ManagedIdentityEnvironmentVariableNames.IDENTITY_HEADER}' and '${ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT}' environment variables are not defined.`\n            );\n            return null;\n        }\n\n        const validatedIdentityEndpoint: string =\n            AppService.getValidatedEnvVariableUrlString(\n                ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT,\n                identityEndpoint,\n                ManagedIdentitySourceNames.APP_SERVICE,\n                logger\n            );\n\n        logger.info(\n            `[Managed Identity] Environment variables validation passed for ${ManagedIdentitySourceNames.APP_SERVICE} managed identity. Endpoint URI: ${validatedIdentityEndpoint}. Creating ${ManagedIdentitySourceNames.APP_SERVICE} managed identity.`\n        );\n\n        return new AppService(\n            logger,\n            nodeStorage,\n            networkClient,\n            cryptoProvider,\n            disableInternalRetries,\n            identityEndpoint,\n            identityHeader\n        );\n    }\n\n    public createRequest(\n        resource: string,\n        managedIdentityId: ManagedIdentityId\n    ): ManagedIdentityRequestParameters {\n        const request: ManagedIdentityRequestParameters =\n            new ManagedIdentityRequestParameters(\n                HttpMethod.GET,\n                this.identityEndpoint\n            );\n\n        request.headers[ManagedIdentityHeaders.APP_SERVICE_SECRET_HEADER_NAME] =\n            this.identityHeader;\n\n        request.queryParameters[ManagedIdentityQueryParameters.API_VERSION] =\n            APP_SERVICE_MSI_API_VERSION;\n        request.queryParameters[ManagedIdentityQueryParameters.RESOURCE] =\n            resource;\n\n        if (\n            managedIdentityId.idType !== ManagedIdentityIdType.SYSTEM_ASSIGNED\n        ) {\n            request.queryParameters[\n                this.getManagedIdentityUserAssignedIdQueryParameterKey(\n                    managedIdentityId.idType\n                )\n            ] = managedIdentityId.id;\n        }\n\n        // bodyParameters calculated in BaseManagedIdentity.acquireTokenWithManagedIdentity\n\n        return request;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;;CAGG,GAiBH,wHAAA;AACA,MAAM,2BAA2B,GAAW,YAAY,CAAC;AAEzD;;CAEG,GACG,MAAO,UAAW,2NAAQ,4BAAyB,CAAA;IAIrD,WAAA,CACI,MAAc,EACd,WAAwB,EACxB,aAA6B,EAC7B,cAA8B,EAC9B,sBAA+B,EAC/B,gBAAwB,EACxB,cAAsB,CAAA;QAEtB,KAAK,CACD,MAAM,EACN,WAAW,EACX,aAAa,EACb,cAAc,EACd,sBAAsB,CACzB,CAAC;QAEF,IAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;QACzC,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;KACxC;IAEM,OAAO,uBAAuB,GAAA;QACjC,MAAM,gBAAgB,GAClB,OAAO,CAAC,GAAG,wKACP,0CAAuC,CAAC,iBAAiB,CAC5D,CAAC;QACN,MAAM,cAAc,GAChB,OAAO,CAAC,GAAG,wKACP,0CAAuC,CAAC,eAAe,CAC1D,CAAC;QAEN,OAAO;YAAC,gBAAgB;YAAE,cAAc;SAAC,CAAC;KAC7C;IAEM,OAAO,SAAS,CACnB,MAAc,EACd,WAAwB,EACxB,aAA6B,EAC7B,cAA8B,EAC9B,sBAA+B,EAAA;QAE/B,MAAM,CAAC,gBAAgB,EAAE,cAAc,CAAC,GACpC,UAAU,CAAC,uBAAuB,EAAE,CAAC;;QAGzC,IAAI,CAAC,gBAAgB,IAAI,CAAC,cAAc,EAAE;YACtC,MAAM,CAAC,IAAI,CACP,CAAsB,mBAAA,yKAAA,6BAA0B,CAAC,WAAW,CAAA,6DAAA,wKAAgE,2CAAuC,CAAC,eAAe,CAAU,OAAA,yKAAA,0CAAuC,CAAC,iBAAiB,CAAA,wCAAA,CAA0C,CACnS,CAAC;YACF,OAAO,IAAI,CAAC;QACf,CAAA;QAED,MAAM,yBAAyB,GAC3B,UAAU,CAAC,gCAAgC,wKACvC,0CAAuC,CAAC,iBAAiB,EACzD,gBAAgB,EAChB,oMAA0B,CAAC,WAAW,EACtC,MAAM,CACT,CAAC;QAEN,MAAM,CAAC,IAAI,CACP,CAAA,+DAAA,yKAAkE,6BAA0B,CAAC,WAAW,CAAoC,iCAAA,EAAA,yBAAyB,CAAA,WAAA,wKAAc,8BAA0B,CAAC,WAAW,CAAA,kBAAA,CAAoB,CAChP,CAAC;QAEF,OAAO,IAAI,UAAU,CACjB,MAAM,EACN,WAAW,EACX,aAAa,EACb,cAAc,EACd,sBAAsB,EACtB,gBAAgB,EAChB,cAAc,CACjB,CAAC;KACL;IAEM,aAAa,CAChB,QAAgB,EAChB,iBAAoC,EAAA;QAEpC,MAAM,OAAO,GACT,mMAAI,mCAAgC,wKAChC,aAAU,CAAC,GAAG,EACd,IAAI,CAAC,gBAAgB,CACxB,CAAC;QAEN,OAAO,CAAC,OAAO,wKAAC,yBAAsB,CAAC,8BAA8B,CAAC,GAClE,IAAI,CAAC,cAAc,CAAC;QAExB,OAAO,CAAC,eAAe,wKAAC,iCAA8B,CAAC,WAAW,CAAC,GAC/D,2BAA2B,CAAC;QAChC,OAAO,CAAC,eAAe,wKAAC,iCAA8B,CAAC,QAAQ,CAAC,GAC5D,QAAQ,CAAC;QAEb,IACI,iBAAiB,CAAC,MAAM,4KAAK,wBAAqB,CAAC,eAAe,EACpE;YACE,OAAO,CAAC,eAAe,CACnB,IAAI,CAAC,iDAAiD,CAClD,iBAAiB,CAAC,MAAM,CAC3B,CACJ,GAAG,iBAAiB,CAAC,EAAE,CAAC;QAC5B,CAAA;;QAID,OAAO,OAAO,CAAC;KAClB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4472, "column": 0}, "map": {"version":3,"file":"AzureArc.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/client/ManagedIdentitySources/AzureArc.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AuthError,\n    ClientAuthErrorCodes,\n    createClientAuthError,\n    HttpStatus,\n    INetworkModule,\n    NetworkResponse,\n    NetworkRequestOptions,\n    Logger,\n    ServerAuthorizationTokenResponse,\n    EncodingTypes,\n} from \"@azure/msal-common/node\";\nimport { ManagedIdentityRequestParameters } from \"../../config/ManagedIdentityRequestParameters.js\";\nimport { BaseManagedIdentitySource } from \"./BaseManagedIdentitySource.js\";\nimport { CryptoProvider } from \"../../crypto/CryptoProvider.js\";\nimport {\n    ManagedIdentityErrorCodes,\n    createManagedIdentityError,\n} from \"../../error/ManagedIdentityError.js\";\nimport {\n    AZURE_ARC_SECRET_FILE_MAX_SIZE_BYTES,\n    HttpMethod,\n    ManagedIdentityEnvironmentVariableNames,\n    ManagedIdentityHeaders,\n    ManagedIdentityIdType,\n    ManagedIdentityQueryParameters,\n    ManagedIdentitySourceNames,\n} from \"../../utils/Constants.js\";\nimport { NodeStorage } from \"../../cache/NodeStorage.js\";\nimport {\n    accessSync,\n    constants as fsConstants,\n    readFileSync,\n    statSync,\n} from \"fs\";\nimport { ManagedIdentityTokenResponse } from \"../../response/ManagedIdentityTokenResponse.js\";\nimport { ManagedIdentityId } from \"../../config/ManagedIdentityId.js\";\nimport path from \"path\";\n\nexport const ARC_API_VERSION: string = \"2019-11-01\";\nexport const DEFAULT_AZURE_ARC_IDENTITY_ENDPOINT: string =\n    \"http://127.0.0.1:40342/metadata/identity/oauth2/token\";\nconst HIMDS_EXECUTABLE_HELPER_STRING = \"N/A: himds executable exists\";\n\ntype FilePathMap = {\n    win32: string;\n    linux: string;\n};\n\nexport const SUPPORTED_AZURE_ARC_PLATFORMS: FilePathMap = {\n    win32: `${process.env[\"ProgramData\"]}\\\\AzureConnectedMachineAgent\\\\Tokens\\\\`,\n    linux: \"/var/opt/azcmagent/tokens/\",\n};\n\nexport const AZURE_ARC_FILE_DETECTION: FilePathMap = {\n    win32: `${process.env[\"ProgramFiles\"]}\\\\AzureConnectedMachineAgent\\\\himds.exe`,\n    linux: \"/opt/azcmagent/bin/himds\",\n};\n\n/**\n * Original source of code: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/AzureArcManagedIdentitySource.cs\n */\nexport class AzureArc extends BaseManagedIdentitySource {\n    private identityEndpoint: string;\n\n    constructor(\n        logger: Logger,\n        nodeStorage: NodeStorage,\n        networkClient: INetworkModule,\n        cryptoProvider: CryptoProvider,\n        disableInternalRetries: boolean,\n        identityEndpoint: string\n    ) {\n        super(\n            logger,\n            nodeStorage,\n            networkClient,\n            cryptoProvider,\n            disableInternalRetries\n        );\n\n        this.identityEndpoint = identityEndpoint;\n    }\n\n    public static getEnvironmentVariables(): Array<string | undefined> {\n        let identityEndpoint: string | undefined =\n            process.env[\n                ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT\n            ];\n        let imdsEndpoint: string | undefined =\n            process.env[ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT];\n\n        // if either of the identity or imds endpoints are undefined, check if the himds executable exists\n        if (!identityEndpoint || !imdsEndpoint) {\n            // get the expected Windows or Linux file path of the himds executable\n            const fileDetectionPath: string =\n                AZURE_ARC_FILE_DETECTION[process.platform as keyof FilePathMap];\n            try {\n                /*\n                 * check if the himds executable exists and its permissions allow it to be read\n                 * returns undefined if true, throws an error otherwise\n                 */\n                accessSync(\n                    fileDetectionPath,\n                    fsConstants.F_OK | fsConstants.R_OK\n                );\n\n                identityEndpoint = DEFAULT_AZURE_ARC_IDENTITY_ENDPOINT;\n                imdsEndpoint = HIMDS_EXECUTABLE_HELPER_STRING;\n            } catch (err) {\n                /*\n                 * do nothing\n                 * accessSync returns undefined on success, and throws an error on failure\n                 */\n            }\n        }\n\n        return [identityEndpoint, imdsEndpoint];\n    }\n\n    public static tryCreate(\n        logger: Logger,\n        nodeStorage: NodeStorage,\n        networkClient: INetworkModule,\n        cryptoProvider: CryptoProvider,\n        disableInternalRetries: boolean,\n        managedIdentityId: ManagedIdentityId\n    ): AzureArc | null {\n        const [identityEndpoint, imdsEndpoint] =\n            AzureArc.getEnvironmentVariables();\n\n        // if either of the identity or imds endpoints are undefined (even after himds file detection)\n        if (!identityEndpoint || !imdsEndpoint) {\n            logger.info(\n                `[Managed Identity] ${ManagedIdentitySourceNames.AZURE_ARC} managed identity is unavailable through environment variables because one or both of '${ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT}' and '${ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT}' are not defined. ${ManagedIdentitySourceNames.AZURE_ARC} managed identity is also unavailable through file detection.`\n            );\n\n            return null;\n        }\n\n        // check if the imds endpoint is set to the default for file detection\n        if (imdsEndpoint === HIMDS_EXECUTABLE_HELPER_STRING) {\n            logger.info(\n                `[Managed Identity] ${ManagedIdentitySourceNames.AZURE_ARC} managed identity is available through file detection. Defaulting to known ${ManagedIdentitySourceNames.AZURE_ARC} endpoint: ${DEFAULT_AZURE_ARC_IDENTITY_ENDPOINT}. Creating ${ManagedIdentitySourceNames.AZURE_ARC} managed identity.`\n            );\n        } else {\n            // otherwise, both the identity and imds endpoints are defined without file detection; validate them\n\n            const validatedIdentityEndpoint: string =\n                AzureArc.getValidatedEnvVariableUrlString(\n                    ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT,\n                    identityEndpoint,\n                    ManagedIdentitySourceNames.AZURE_ARC,\n                    logger\n                );\n            // remove trailing slash\n            validatedIdentityEndpoint.endsWith(\"/\")\n                ? validatedIdentityEndpoint.slice(0, -1)\n                : validatedIdentityEndpoint;\n\n            AzureArc.getValidatedEnvVariableUrlString(\n                ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT,\n                imdsEndpoint,\n                ManagedIdentitySourceNames.AZURE_ARC,\n                logger\n            );\n\n            logger.info(\n                `[Managed Identity] Environment variables validation passed for ${ManagedIdentitySourceNames.AZURE_ARC} managed identity. Endpoint URI: ${validatedIdentityEndpoint}. Creating ${ManagedIdentitySourceNames.AZURE_ARC} managed identity.`\n            );\n        }\n\n        if (\n            managedIdentityId.idType !== ManagedIdentityIdType.SYSTEM_ASSIGNED\n        ) {\n            throw createManagedIdentityError(\n                ManagedIdentityErrorCodes.unableToCreateAzureArc\n            );\n        }\n\n        return new AzureArc(\n            logger,\n            nodeStorage,\n            networkClient,\n            cryptoProvider,\n            disableInternalRetries,\n            identityEndpoint\n        );\n    }\n\n    public createRequest(resource: string): ManagedIdentityRequestParameters {\n        const request: ManagedIdentityRequestParameters =\n            new ManagedIdentityRequestParameters(\n                HttpMethod.GET,\n                this.identityEndpoint.replace(\"localhost\", \"127.0.0.1\")\n            );\n\n        request.headers[ManagedIdentityHeaders.METADATA_HEADER_NAME] = \"true\";\n\n        request.queryParameters[ManagedIdentityQueryParameters.API_VERSION] =\n            ARC_API_VERSION;\n        request.queryParameters[ManagedIdentityQueryParameters.RESOURCE] =\n            resource;\n\n        // bodyParameters calculated in BaseManagedIdentity.acquireTokenWithManagedIdentity\n\n        return request;\n    }\n\n    public async getServerTokenResponseAsync(\n        originalResponse: NetworkResponse<ManagedIdentityTokenResponse>,\n        networkClient: INetworkModule,\n        networkRequest: ManagedIdentityRequestParameters,\n        networkRequestOptions: NetworkRequestOptions\n    ): Promise<ServerAuthorizationTokenResponse> {\n        let retryResponse:\n            | NetworkResponse<ManagedIdentityTokenResponse>\n            | undefined;\n\n        if (originalResponse.status === HttpStatus.UNAUTHORIZED) {\n            const wwwAuthHeader: string =\n                originalResponse.headers[\"www-authenticate\"];\n            if (!wwwAuthHeader) {\n                throw createManagedIdentityError(\n                    ManagedIdentityErrorCodes.wwwAuthenticateHeaderMissing\n                );\n            }\n            if (!wwwAuthHeader.includes(\"Basic realm=\")) {\n                throw createManagedIdentityError(\n                    ManagedIdentityErrorCodes.wwwAuthenticateHeaderUnsupportedFormat\n                );\n            }\n\n            const secretFilePath = wwwAuthHeader.split(\"Basic realm=\")[1];\n\n            // throw an error if the managed identity application is not being run on Windows or Linux\n            if (\n                !SUPPORTED_AZURE_ARC_PLATFORMS.hasOwnProperty(process.platform)\n            ) {\n                throw createManagedIdentityError(\n                    ManagedIdentityErrorCodes.platformNotSupported\n                );\n            }\n\n            // get the expected Windows or Linux file path\n            const expectedSecretFilePath: string =\n                SUPPORTED_AZURE_ARC_PLATFORMS[\n                    process.platform as keyof FilePathMap\n                ];\n\n            // throw an error if the file in the file path is not a .key file\n            const fileName: string = path.basename(secretFilePath);\n            if (!fileName.endsWith(\".key\")) {\n                throw createManagedIdentityError(\n                    ManagedIdentityErrorCodes.invalidFileExtension\n                );\n            }\n\n            /*\n             * throw an error if the file path from the www-authenticate header does not match the\n             * expected file path for the platform (Windows or Linux) the managed identity application\n             * is running on\n             */\n            if (expectedSecretFilePath + fileName !== secretFilePath) {\n                throw createManagedIdentityError(\n                    ManagedIdentityErrorCodes.invalidFilePath\n                );\n            }\n\n            let secretFileSize;\n            // attempt to get the secret file's size, in bytes\n            try {\n                secretFileSize = await statSync(secretFilePath).size;\n            } catch (e) {\n                throw createManagedIdentityError(\n                    ManagedIdentityErrorCodes.unableToReadSecretFile\n                );\n            }\n            // throw an error if the secret file's size is greater than 4096 bytes\n            if (secretFileSize > AZURE_ARC_SECRET_FILE_MAX_SIZE_BYTES) {\n                throw createManagedIdentityError(\n                    ManagedIdentityErrorCodes.invalidSecret\n                );\n            }\n\n            // attempt to read the contents of the secret file\n            let secret;\n            try {\n                secret = readFileSync(secretFilePath, EncodingTypes.UTF8);\n            } catch (e) {\n                throw createManagedIdentityError(\n                    ManagedIdentityErrorCodes.unableToReadSecretFile\n                );\n            }\n            const authHeaderValue = `Basic ${secret}`;\n\n            this.logger.info(\n                `[Managed Identity] Adding authorization header to the request.`\n            );\n            networkRequest.headers[\n                ManagedIdentityHeaders.AUTHORIZATION_HEADER_NAME\n            ] = authHeaderValue;\n\n            try {\n                retryResponse =\n                    await networkClient.sendGetRequestAsync<ManagedIdentityTokenResponse>(\n                        networkRequest.computeUri(),\n                        networkRequestOptions\n                    );\n            } catch (error) {\n                if (error instanceof AuthError) {\n                    throw error;\n                } else {\n                    throw createClientAuthError(\n                        ClientAuthErrorCodes.networkError\n                    );\n                }\n            }\n        }\n\n        return this.getServerTokenResponse(retryResponse || originalResponse);\n    }\n}\n"],"names":["fsConstants","ManagedIdentityErrorCodes.unableToCreateAzureArc","ManagedIdentityErrorCodes.wwwAuthenticateHeaderMissing","ManagedIdentityErrorCodes.wwwAuthenticateHeaderUnsupportedFormat","ManagedIdentityErrorCodes.platformNotSupported","ManagedIdentityErrorCodes.invalidFileExtension","ManagedIdentityErrorCodes.invalidFilePath","ManagedIdentityErrorCodes.unableToReadSecretFile","ManagedIdentityErrorCodes.invalidSecret"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4647, "column": 0}, "map": {"version":3,"file":"CloudShell.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/client/ManagedIdentitySources/CloudShell.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { INetworkModule, Logger } from \"@azure/msal-common/node\";\nimport { ManagedIdentityRequestParameters } from \"../../config/ManagedIdentityRequestParameters.js\";\nimport { BaseManagedIdentitySource } from \"./BaseManagedIdentitySource.js\";\nimport { NodeStorage } from \"../../cache/NodeStorage.js\";\nimport { CryptoProvider } from \"../../crypto/CryptoProvider.js\";\nimport {\n    HttpMethod,\n    ManagedIdentityEnvironmentVariableNames,\n    ManagedIdentityHeaders,\n    ManagedIdentityIdType,\n    ManagedIdentityQueryParameters,\n    ManagedIdentitySourceNames,\n} from \"../../utils/Constants.js\";\nimport {\n    ManagedIdentityErrorCodes,\n    createManagedIdentityError,\n} from \"../../error/ManagedIdentityError.js\";\nimport { ManagedIdentityId } from \"../../config/ManagedIdentityId.js\";\n\n/**\n * Original source of code: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/CloudShellManagedIdentitySource.cs\n */\nexport class CloudShell extends BaseManagedIdentitySource {\n    private msiEndpoint: string;\n\n    constructor(\n        logger: Logger,\n        nodeStorage: NodeStorage,\n        networkClient: INetworkModule,\n        cryptoProvider: CryptoProvider,\n        disableInternalRetries: boolean,\n        msiEndpoint: string\n    ) {\n        super(\n            logger,\n            nodeStorage,\n            networkClient,\n            cryptoProvider,\n            disableInternalRetries\n        );\n\n        this.msiEndpoint = msiEndpoint;\n    }\n\n    public static getEnvironmentVariables(): Array<string | undefined> {\n        const msiEndpoint: string | undefined =\n            process.env[ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT];\n\n        return [msiEndpoint];\n    }\n\n    public static tryCreate(\n        logger: Logger,\n        nodeStorage: NodeStorage,\n        networkClient: INetworkModule,\n        cryptoProvider: CryptoProvider,\n        disableInternalRetries: boolean,\n        managedIdentityId: ManagedIdentityId\n    ): CloudShell | null {\n        const [msiEndpoint] = CloudShell.getEnvironmentVariables();\n\n        // if the msi endpoint environment variable is undefined, this MSI provider is unavailable.\n        if (!msiEndpoint) {\n            logger.info(\n                `[Managed Identity] ${ManagedIdentitySourceNames.CLOUD_SHELL} managed identity is unavailable because the '${ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT} environment variable is not defined.`\n            );\n            return null;\n        }\n\n        const validatedMsiEndpoint: string =\n            CloudShell.getValidatedEnvVariableUrlString(\n                ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT,\n                msiEndpoint,\n                ManagedIdentitySourceNames.CLOUD_SHELL,\n                logger\n            );\n\n        logger.info(\n            `[Managed Identity] Environment variable validation passed for ${ManagedIdentitySourceNames.CLOUD_SHELL} managed identity. Endpoint URI: ${validatedMsiEndpoint}. Creating ${ManagedIdentitySourceNames.CLOUD_SHELL} managed identity.`\n        );\n\n        if (\n            managedIdentityId.idType !== ManagedIdentityIdType.SYSTEM_ASSIGNED\n        ) {\n            throw createManagedIdentityError(\n                ManagedIdentityErrorCodes.unableToCreateCloudShell\n            );\n        }\n\n        return new CloudShell(\n            logger,\n            nodeStorage,\n            networkClient,\n            cryptoProvider,\n            disableInternalRetries,\n            msiEndpoint\n        );\n    }\n\n    public createRequest(resource: string): ManagedIdentityRequestParameters {\n        const request: ManagedIdentityRequestParameters =\n            new ManagedIdentityRequestParameters(\n                HttpMethod.POST,\n                this.msiEndpoint\n            );\n\n        request.headers[ManagedIdentityHeaders.METADATA_HEADER_NAME] = \"true\";\n\n        request.bodyParameters[ManagedIdentityQueryParameters.RESOURCE] =\n            resource;\n\n        return request;\n    }\n}\n"],"names":["ManagedIdentityErrorCodes.unableToCreateCloudShell"],"mappings":";;;;;;;;;;;;;;AAAA;;;CAGG,GAqBH;;CAEG,GACG,MAAO,UAAW,2NAAQ,4BAAyB,CAAA;IAGrD,WACI,CAAA,MAAc,EACd,WAAwB,EACxB,aAA6B,EAC7B,cAA8B,EAC9B,sBAA+B,EAC/B,WAAmB,CAAA;QAEnB,KAAK,CACD,MAAM,EACN,WAAW,EACX,aAAa,EACb,cAAc,EACd,sBAAsB,CACzB,CAAC;QAEF,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;KAClC;IAEM,OAAO,uBAAuB,GAAA;QACjC,MAAM,WAAW,GACb,OAAO,CAAC,GAAG,wKAAC,0CAAuC,CAAC,YAAY,CAAC,CAAC;QAEtE,OAAO;YAAC,WAAW;SAAC,CAAC;KACxB;IAEM,OAAO,SAAS,CACnB,MAAc,EACd,WAAwB,EACxB,aAA6B,EAC7B,cAA8B,EAC9B,sBAA+B,EAC/B,iBAAoC,EAAA;QAEpC,MAAM,CAAC,WAAW,CAAC,GAAG,UAAU,CAAC,uBAAuB,EAAE,CAAC;;QAG3D,IAAI,CAAC,WAAW,EAAE;YACd,MAAM,CAAC,IAAI,CACP,CAAA,mBAAA,yKAAsB,6BAA0B,CAAC,WAAW,CAAA,8CAAA,yKAAiD,0CAAuC,CAAC,YAAY,CAAA,qCAAA,CAAuC,CAC3M,CAAC;YACF,OAAO,IAAI,CAAC;QACf,CAAA;QAED,MAAM,oBAAoB,GACtB,UAAU,CAAC,gCAAgC,wKACvC,0CAAuC,CAAC,YAAY,EACpD,WAAW,EACX,oMAA0B,CAAC,WAAW,EACtC,MAAM,CACT,CAAC;QAEN,MAAM,CAAC,IAAI,CACP,CAAA,8DAAA,yKAAiE,6BAA0B,CAAC,WAAW,CAAoC,iCAAA,EAAA,oBAAoB,CAAA,WAAA,yKAAc,6BAA0B,CAAC,WAAW,CAAA,kBAAA,CAAoB,CAC1O,CAAC;QAEF,IACI,iBAAiB,CAAC,MAAM,4KAAK,wBAAqB,CAAC,eAAe,EACpE;YACE,4LAAM,6BAAA,AAA0B,yLAC5BA,2BAAkD,CACrD,CAAC;QACL,CAAA;QAED,OAAO,IAAI,UAAU,CACjB,MAAM,EACN,WAAW,EACX,aAAa,EACb,cAAc,EACd,sBAAsB,EACtB,WAAW,CACd,CAAC;KACL;IAEM,aAAa,CAAC,QAAgB,EAAA;QACjC,MAAM,OAAO,GACT,mMAAI,mCAAgC,wKAChC,aAAU,CAAC,IAAI,EACf,IAAI,CAAC,WAAW,CACnB,CAAC;QAEN,OAAO,CAAC,OAAO,wKAAC,yBAAsB,CAAC,oBAAoB,CAAC,GAAG,MAAM,CAAC;QAEtE,OAAO,CAAC,cAAc,wKAAC,iCAA8B,CAAC,QAAQ,CAAC,GAC3D,QAAQ,CAAC;QAEb,OAAO,OAAO,CAAC;KAClB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4706, "column": 0}, "map": {"version":3,"file":"ExponentialRetryStrategy.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/retry/ExponentialRetryStrategy.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nexport class ExponentialRetryStrategy {\n    // Minimum backoff time in milliseconds\n    private minExponentialBackoff: number;\n    // Maximum backoff time in milliseconds\n    private maxExponentialBackoff: number;\n    // Maximum backoff time in milliseconds\n    private exponentialDeltaBackoff: number;\n\n    constructor(\n        minExponentialBackoff: number,\n        maxExponentialBackoff: number,\n        exponentialDeltaBackoff: number\n    ) {\n        this.minExponentialBackoff = minExponentialBackoff;\n        this.maxExponentialBackoff = maxExponentialBackoff;\n        this.exponentialDeltaBackoff = exponentialDeltaBackoff;\n    }\n\n    /**\n     * Calculates the exponential delay based on the current retry attempt.\n     *\n     * @param {number} currentRetry - The current retry attempt number.\n     * @returns {number} - The calculated exponential delay in milliseconds.\n     *\n     * The delay is calculated using the formula:\n     * - If `currentRetry` is 0, it returns the minimum backoff time.\n     * - Otherwise, it calculates the delay as the minimum of:\n     *   - `(2^(currentRetry - 1)) * deltaBackoff`\n     *   - `maxBackoff`\n     *\n     * This ensures that the delay increases exponentially with each retry attempt,\n     * but does not exceed the maximum backoff time.\n     */\n    public calculateDelay(currentRetry: number): number {\n        // Attempt 1\n        if (currentRetry === 0) {\n            return this.minExponentialBackoff;\n        }\n\n        // Attempt 2+\n        const exponentialDelay = Math.min(\n            Math.pow(2, currentRetry - 1) * this.exponentialDeltaBackoff,\n            this.maxExponentialBackoff\n        );\n\n        return exponentialDelay;\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;;;CAGG,SAEU,wBAAwB,CAAA;IAQjC,WAAA,CACI,qBAA6B,EAC7B,qBAA6B,EAC7B,uBAA+B,CAAA;QAE/B,IAAI,CAAC,qBAAqB,GAAG,qBAAqB,CAAC;QACnD,IAAI,CAAC,qBAAqB,GAAG,qBAAqB,CAAC;QACnD,IAAI,CAAC,uBAAuB,GAAG,uBAAuB,CAAC;KAC1D;IAED;;;;;;;;;;;;;;KAcG,GACI,cAAc,CAAC,YAAoB,EAAA;;QAEtC,IAAI,YAAY,KAAK,CAAC,EAAE;YACpB,OAAO,IAAI,CAAC,qBAAqB,CAAC;QACrC,CAAA;;QAGD,MAAM,gBAAgB,GAAG,IAAI,CAAC,GAAG,CAC7B,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,YAAY,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,uBAAuB,EAC5D,IAAI,CAAC,qBAAqB,CAC7B,CAAC;QAEF,OAAO,gBAAgB,CAAC;KAC3B;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4751, "column": 0}, "map": {"version":3,"file":"ImdsRetryPolicy.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/retry/ImdsRetryPolicy.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { HttpStatus, Logger } from \"@azure/msal-common\";\nimport { ExponentialRetryStrategy } from \"./ExponentialRetryStrategy.js\";\nimport { IHttpRetryPolicy } from \"./IHttpRetryPolicy.js\";\n\nconst HTTP_STATUS_400_CODES_FOR_EXPONENTIAL_STRATEGY: Array<number> = [\n    HttpStatus.NOT_FOUND,\n    HttpStatus.REQUEST_TIMEOUT,\n    HttpStatus.GONE,\n    HttpStatus.TOO_MANY_REQUESTS,\n];\n\nconst EXPONENTIAL_STRATEGY_NUM_RETRIES = 3;\nconst LINEAR_STRATEGY_NUM_RETRIES = 7;\n\nconst MIN_EXPONENTIAL_BACKOFF_MS: number = 1000;\nconst MAX_EXPONENTIAL_BACKOFF_MS: number = 4000;\nconst EXPONENTIAL_DELTA_BACKOFF_MS: number = 2000;\n\nconst HTTP_STATUS_GONE_RETRY_AFTER_MS: number = 10 * 1000; // 10 seconds\n\nexport class ImdsRetryPolicy implements IHttpRetryPolicy {\n    /*\n     * these are defined here as static variables despite being defined as constants outside of the\n     * class because they need to be overridden in the unit tests so that the unit tests run faster\n     */\n    static get MIN_EXPONENTIAL_BACKOFF_MS(): number {\n        return MIN_EXPONENTIAL_BACKOFF_MS;\n    }\n    static get MAX_EXPONENTIAL_BACKOFF_MS(): number {\n        return MAX_EXPONENTIAL_BACKOFF_MS;\n    }\n    static get EXPONENTIAL_DELTA_BACKOFF_MS(): number {\n        return EXPONENTIAL_DELTA_BACKOFF_MS;\n    }\n    static get HTTP_STATUS_GONE_RETRY_AFTER_MS(): number {\n        return HTTP_STATUS_GONE_RETRY_AFTER_MS;\n    }\n\n    public _isNewRequest: boolean;\n    set isNewRequest(value: boolean) {\n        this._isNewRequest = value;\n    }\n\n    private maxRetries: number;\n\n    private exponentialRetryStrategy: ExponentialRetryStrategy =\n        new ExponentialRetryStrategy(\n            ImdsRetryPolicy.MIN_EXPONENTIAL_BACKOFF_MS,\n            ImdsRetryPolicy.MAX_EXPONENTIAL_BACKOFF_MS,\n            ImdsRetryPolicy.EXPONENTIAL_DELTA_BACKOFF_MS\n        );\n\n    /**\n     * Pauses execution for a calculated delay before retrying a request.\n     *\n     * @param httpStatusCode - The HTTP status code of the response.\n     * @param currentRetry - The current retry attempt number.\n     * @param retryAfterHeader - The value of the \"retry-after\" header from the response.\n     * @returns A promise that resolves to a boolean indicating whether a retry should be attempted.\n     */\n    async pauseForRetry(\n        httpStatusCode: number,\n        currentRetry: number,\n        logger: Logger\n    ): Promise<boolean> {\n        if (this._isNewRequest) {\n            this._isNewRequest = false;\n\n            // calculate the maxRetries based on the status code, once per request\n            this.maxRetries =\n                httpStatusCode === HttpStatus.GONE\n                    ? LINEAR_STRATEGY_NUM_RETRIES\n                    : EXPONENTIAL_STRATEGY_NUM_RETRIES;\n        }\n\n        /**\n         * (status code is one of the retriable 400 status code\n         * or\n         * status code is >= 500 and <= 599)\n         * and\n         * current count of retries is less than the max number of retries\n         */\n        if (\n            (HTTP_STATUS_400_CODES_FOR_EXPONENTIAL_STRATEGY.includes(\n                httpStatusCode\n            ) ||\n                (httpStatusCode >= HttpStatus.SERVER_ERROR_RANGE_START &&\n                    httpStatusCode <= HttpStatus.SERVER_ERROR_RANGE_END &&\n                    currentRetry < this.maxRetries)) &&\n            currentRetry < this.maxRetries\n        ) {\n            const retryAfterDelay: number =\n                httpStatusCode === HttpStatus.GONE\n                    ? ImdsRetryPolicy.HTTP_STATUS_GONE_RETRY_AFTER_MS\n                    : this.exponentialRetryStrategy.calculateDelay(\n                          currentRetry\n                      );\n\n            logger.verbose(\n                `Retrying request in ${retryAfterDelay}ms (retry attempt: ${\n                    currentRetry + 1\n                })`\n            );\n\n            // pause execution for the calculated delay\n            await new Promise((resolve) => {\n                return setTimeout(resolve, retryAfterDelay);\n            });\n\n            return true;\n        }\n\n        // if the status code is not retriable or max retries have been reached, do not retry\n        return false;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;;;CAGG,GAMH,MAAM,8CAA8C,GAAkB;6KAClE,aAAU,CAAC,SAAS;6KACpB,aAAU,CAAC,eAAe;6KAC1B,aAAU,CAAC,IAAI;6KACf,aAAU,CAAC,iBAAiB;CAC/B,CAAC;AAEF,MAAM,gCAAgC,GAAG,CAAC,CAAC;AAC3C,MAAM,2BAA2B,GAAG,CAAC,CAAC;AAEtC,MAAM,0BAA0B,GAAW,IAAI,CAAC;AAChD,MAAM,0BAA0B,GAAW,IAAI,CAAC;AAChD,MAAM,4BAA4B,GAAW,IAAI,CAAC;AAElD,MAAM,+BAA+B,GAAW,EAAE,GAAG,IAAI,CAAC,CAAA,aAAA;MAE7C,eAAe,CAAA;IAA5B,WAAA,EAAA;QAyBY,IAAA,CAAA,wBAAwB,GAC5B,0LAAI,2BAAwB,CACxB,eAAe,CAAC,0BAA0B,EAC1C,eAAe,CAAC,0BAA0B,EAC1C,eAAe,CAAC,4BAA4B,CAC/C,CAAC;KAiET;IA9FG;;;KAGG,GACH,WAAW,0BAA0B,GAAA;QACjC,OAAO,0BAA0B,CAAC;KACrC;IACD,WAAW,0BAA0B,GAAA;QACjC,OAAO,0BAA0B,CAAC;KACrC;IACD,WAAW,4BAA4B,GAAA;QACnC,OAAO,4BAA4B,CAAC;KACvC;IACD,WAAW,+BAA+B,GAAA;QACtC,OAAO,+BAA+B,CAAC;KAC1C;IAGD,IAAI,YAAY,CAAC,KAAc,EAAA;QAC3B,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;KAC9B;IAWD;;;;;;;KAOG,GACH,MAAM,aAAa,CACf,cAAsB,EACtB,YAAoB,EACpB,MAAc,EAAA;QAEd,IAAI,IAAI,CAAC,aAAa,EAAE;YACpB,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;;YAG3B,IAAI,CAAC,UAAU,GACX,cAAc,8KAAK,aAAU,CAAC,IAAI,GAC5B,2BAA2B,GAC3B,gCAAgC,CAAC;QAC9C,CAAA;QAED;;;;;;SAMG,GACH,IACI,CAAC,8CAA8C,CAAC,QAAQ,CACpD,cAAc,CACjB,IACI,cAAc,IAAI,sLAAU,CAAC,wBAAwB,IAClD,cAAc,6KAAI,aAAU,CAAC,sBAAsB,IACnD,YAAY,GAAG,IAAI,CAAC,UAAU,AAAC,KACvC,YAAY,GAAG,IAAI,CAAC,UAAU,EAChC;YACE,MAAM,eAAe,GACjB,cAAc,8KAAK,aAAU,CAAC,IAAI,GAC5B,eAAe,CAAC,+BAA+B,GAC/C,IAAI,CAAC,wBAAwB,CAAC,cAAc,CACxC,YAAY,CACf,CAAC;YAEZ,MAAM,CAAC,OAAO,CACV,CAAuB,oBAAA,EAAA,eAAe,CAClC,mBAAA,EAAA,YAAY,GAAG,CACnB,CAAG,CAAA,CAAA,CACN,CAAC;;YAGF,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,KAAI;gBAC1B,OAAO,UAAU,CAAC,OAAO,EAAE,eAAe,CAAC,CAAC;YAChD,CAAC,CAAC,CAAC;YAEH,OAAO,IAAI,CAAC;QACf,CAAA;;QAGD,OAAO,KAAK,CAAC;KAChB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4836, "column": 0}, "map": {"version":3,"file":"Imds.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/client/ManagedIdentitySources/Imds.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { INetworkModule, Logger } from \"@azure/msal-common/node\";\nimport { ManagedIdentityId } from \"../../config/ManagedIdentityId.js\";\nimport { ManagedIdentityRequestParameters } from \"../../config/ManagedIdentityRequestParameters.js\";\nimport { BaseManagedIdentitySource } from \"./BaseManagedIdentitySource.js\";\nimport { CryptoProvider } from \"../../crypto/CryptoProvider.js\";\nimport {\n    HttpMethod,\n    ManagedIdentityEnvironmentVariableNames,\n    ManagedIdentityHeaders,\n    ManagedIdentityIdType,\n    ManagedIdentityQueryParameters,\n    ManagedIdentitySourceNames,\n} from \"../../utils/Constants.js\";\nimport { NodeStorage } from \"../../cache/NodeStorage.js\";\nimport { ImdsRetryPolicy } from \"../../retry/ImdsRetryPolicy.js\";\n\n// Documentation for IMDS is available at https://docs.microsoft.com/azure/active-directory/managed-identities-azure-resources/how-to-use-vm-token#get-a-token-using-http\n\nconst IMDS_TOKEN_PATH: string = \"/metadata/identity/oauth2/token\";\nconst DEFAULT_IMDS_ENDPOINT: string = `http://169.254.169.254${IMDS_TOKEN_PATH}`;\nconst IMDS_API_VERSION: string = \"2018-02-01\";\n\n/**\n * Original source of code: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/ImdsManagedIdentitySource.cs\n */\nexport class Imds extends BaseManagedIdentitySource {\n    private identityEndpoint: string;\n\n    /**\n     * Constructs an Imds instance.\n     * @param logger - Logger instance for logging.\n     * @param nodeStorage - NodeStorage instance for caching.\n     * @param networkClient - Network client for HTTP requests.\n     * @param cryptoProvider - CryptoProvider for cryptographic operations.\n     * @param disableInternalRetries - Whether to disable internal retry logic.\n     * @param identityEndpoint - The IMDS endpoint to use.\n     */\n    constructor(\n        logger: Logger,\n        nodeStorage: NodeStorage,\n        networkClient: INetworkModule,\n        cryptoProvider: CryptoProvider,\n        disableInternalRetries: boolean,\n        identityEndpoint: string\n    ) {\n        super(\n            logger,\n            nodeStorage,\n            networkClient,\n            cryptoProvider,\n            disableInternalRetries\n        );\n\n        this.identityEndpoint = identityEndpoint;\n    }\n\n    /**\n     * Attempts to create an Imds instance by determining the correct endpoint.\n     * If the AZURE_POD_IDENTITY_AUTHORITY_HOST environment variable is set, it uses that as the endpoint.\n     * Otherwise, it falls back to the default IMDS endpoint.\n     *\n     * @param logger - Logger instance for logging.\n     * @param nodeStorage - NodeStorage instance for caching.\n     * @param networkClient - Network client for HTTP requests.\n     * @param cryptoProvider - CryptoProvider for cryptographic operations.\n     * @param disableInternalRetries - Whether to disable internal retry logic.\n     * @returns An instance of Imds configured with the appropriate endpoint.\n     */\n    public static tryCreate(\n        logger: Logger,\n        nodeStorage: NodeStorage,\n        networkClient: INetworkModule,\n        cryptoProvider: CryptoProvider,\n        disableInternalRetries: boolean\n    ): Imds {\n        let validatedIdentityEndpoint: string;\n\n        if (\n            process.env[\n                ManagedIdentityEnvironmentVariableNames\n                    .AZURE_POD_IDENTITY_AUTHORITY_HOST\n            ]\n        ) {\n            logger.info(\n                `[Managed Identity] Environment variable ${\n                    ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST\n                } for ${ManagedIdentitySourceNames.IMDS} returned endpoint: ${\n                    process.env[\n                        ManagedIdentityEnvironmentVariableNames\n                            .AZURE_POD_IDENTITY_AUTHORITY_HOST\n                    ]\n                }`\n            );\n            validatedIdentityEndpoint = Imds.getValidatedEnvVariableUrlString(\n                ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST,\n                `${\n                    process.env[\n                        ManagedIdentityEnvironmentVariableNames\n                            .AZURE_POD_IDENTITY_AUTHORITY_HOST\n                    ]\n                }${IMDS_TOKEN_PATH}`,\n                ManagedIdentitySourceNames.IMDS,\n                logger\n            );\n        } else {\n            logger.info(\n                `[Managed Identity] Unable to find ${ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST} environment variable for ${ManagedIdentitySourceNames.IMDS}, using the default endpoint.`\n            );\n            validatedIdentityEndpoint = DEFAULT_IMDS_ENDPOINT;\n        }\n\n        return new Imds(\n            logger,\n            nodeStorage,\n            networkClient,\n            cryptoProvider,\n            disableInternalRetries,\n            validatedIdentityEndpoint\n        );\n    }\n\n    /**\n     * Creates a ManagedIdentityRequestParameters object for acquiring a token from IMDS.\n     * Sets the required headers and query parameters for the IMDS token request.\n     *\n     * @param resource - The resource URI for which the token is requested.\n     * @param managedIdentityId - The managed identity ID (system-assigned or user-assigned).\n     * @returns A ManagedIdentityRequestParameters object configured for IMDS.\n     */\n    public createRequest(\n        resource: string,\n        managedIdentityId: ManagedIdentityId\n    ): ManagedIdentityRequestParameters {\n        const request: ManagedIdentityRequestParameters =\n            new ManagedIdentityRequestParameters(\n                HttpMethod.GET,\n                this.identityEndpoint\n            );\n\n        request.headers[ManagedIdentityHeaders.METADATA_HEADER_NAME] = \"true\";\n\n        request.queryParameters[ManagedIdentityQueryParameters.API_VERSION] =\n            IMDS_API_VERSION;\n        request.queryParameters[ManagedIdentityQueryParameters.RESOURCE] =\n            resource;\n\n        if (\n            managedIdentityId.idType !== ManagedIdentityIdType.SYSTEM_ASSIGNED\n        ) {\n            request.queryParameters[\n                this.getManagedIdentityUserAssignedIdQueryParameterKey(\n                    managedIdentityId.idType,\n                    true // indicates source is IMDS\n                )\n            ] = managedIdentityId.id;\n        }\n\n        // The bodyParameters are calculated in BaseManagedIdentity.acquireTokenWithManagedIdentity.\n\n        request.retryPolicy = new ImdsRetryPolicy();\n\n        return request;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;;CAGG,GAkBH,yKAAA;AAEA,MAAM,eAAe,GAAW,iCAAiC,CAAC;AAClE,MAAM,qBAAqB,GAAW,CAAyB,sBAAA,EAAA,eAAe,EAAE,CAAC;AACjF,MAAM,gBAAgB,GAAW,YAAY,CAAC;AAE9C;;CAEG,GACG,MAAO,IAAK,2NAAQ,4BAAyB,CAAA;IAG/C;;;;;;;;KAQG,GACH,WACI,CAAA,MAAc,EACd,WAAwB,EACxB,aAA6B,EAC7B,cAA8B,EAC9B,sBAA+B,EAC/B,gBAAwB,CAAA;QAExB,KAAK,CACD,MAAM,EACN,WAAW,EACX,aAAa,EACb,cAAc,EACd,sBAAsB,CACzB,CAAC;QAEF,IAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;KAC5C;IAED;;;;;;;;;;;KAWG,GACI,OAAO,SAAS,CACnB,MAAc,EACd,WAAwB,EACxB,aAA6B,EAC7B,cAA8B,EAC9B,sBAA+B,EAAA;QAE/B,IAAI,yBAAiC,CAAC;QAEtC,IACI,OAAO,CAAC,GAAG,wKACP,0CAAuC,CAClC,iCAAiC,CACzC,EACH;YACE,MAAM,CAAC,IAAI,CACP,CACI,wCAAA,yKAAA,0CAAuC,CAAC,iCAC5C,CAAA,KAAA,yKAAQ,6BAA0B,CAAC,IAAI,CACnC,oBAAA,EAAA,OAAO,CAAC,GAAG,wKACP,0CAAuC,CAClC,iCAAiC,CAE9C,CAAE,CAAA,CACL,CAAC;YACF,yBAAyB,GAAG,IAAI,CAAC,gCAAgC,uKAC7D,2CAAuC,CAAC,iCAAiC,EACzE,CACI,EAAA,OAAO,CAAC,GAAG,wKACP,0CAAuC,CAClC,iCAAiC,CAE9C,CAAG,EAAA,eAAe,CAAE,CAAA,yKACpB,6BAA0B,CAAC,IAAI,EAC/B,MAAM,CACT,CAAC;QACL,CAAA,MAAM;YACH,MAAM,CAAC,IAAI,CACP,CAAA,kCAAA,EAAqC,iNAAuC,CAAC,iCAAiC,CAAA,0BAAA,yKAA6B,6BAA0B,CAAC,IAAI,CAAA,6BAAA,CAA+B,CAC5M,CAAC;YACF,yBAAyB,GAAG,qBAAqB,CAAC;QACrD,CAAA;QAED,OAAO,IAAI,IAAI,CACX,MAAM,EACN,WAAW,EACX,aAAa,EACb,cAAc,EACd,sBAAsB,EACtB,yBAAyB,CAC5B,CAAC;KACL;IAED;;;;;;;KAOG,GACI,aAAa,CAChB,QAAgB,EAChB,iBAAoC,EAAA;QAEpC,MAAM,OAAO,GACT,kMAAI,oCAAgC,wKAChC,aAAU,CAAC,GAAG,EACd,IAAI,CAAC,gBAAgB,CACxB,CAAC;QAEN,OAAO,CAAC,OAAO,wKAAC,yBAAsB,CAAC,oBAAoB,CAAC,GAAG,MAAM,CAAC;QAEtE,OAAO,CAAC,eAAe,wKAAC,iCAA8B,CAAC,WAAW,CAAC,GAC/D,gBAAgB,CAAC;QACrB,OAAO,CAAC,eAAe,wKAAC,iCAA8B,CAAC,QAAQ,CAAC,GAC5D,QAAQ,CAAC;QAEb,IACI,iBAAiB,CAAC,MAAM,4KAAK,wBAAqB,CAAC,eAAe,EACpE;YACE,OAAO,CAAC,eAAe,CACnB,IAAI,CAAC,iDAAiD,CAClD,iBAAiB,CAAC,MAAM,EACxB,IAAI,CAAA,2BAAA;cAEX,GAAG,iBAAiB,CAAC,EAAE,CAAC;QAC5B,CAAA;;QAID,OAAO,CAAC,WAAW,GAAG,iLAAI,kBAAe,EAAE,CAAC;QAE5C,OAAO,OAAO,CAAC;KAClB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4921, "column": 0}, "map": {"version":3,"file":"ServiceFabric.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/client/ManagedIdentitySources/ServiceFabric.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { INetworkModule, Logger } from \"@azure/msal-common/node\";\nimport { ManagedIdentityId } from \"../../config/ManagedIdentityId.js\";\nimport { ManagedIdentityRequestParameters } from \"../../config/ManagedIdentityRequestParameters.js\";\nimport { BaseManagedIdentitySource } from \"./BaseManagedIdentitySource.js\";\nimport { NodeStorage } from \"../../cache/NodeStorage.js\";\nimport { CryptoProvider } from \"../../crypto/CryptoProvider.js\";\nimport {\n    HttpMethod,\n    ManagedIdentityEnvironmentVariableNames,\n    ManagedIdentityIdType,\n    ManagedIdentitySourceNames,\n    ManagedIdentityQueryParameters,\n    ManagedIdentityHeaders,\n} from \"../../utils/Constants.js\";\n\nconst SERVICE_FABRIC_MSI_API_VERSION: string = \"2019-07-01-preview\";\n\n/**\n * Original source of code: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/ServiceFabricManagedIdentitySource.cs\n */\nexport class ServiceFabric extends BaseManagedIdentitySource {\n    private identityEndpoint: string;\n    private identityHeader: string;\n\n    /**\n     * Constructs a new ServiceFabric managed identity source.\n     * @param logger Logger instance for logging\n     * @param nodeStorage NodeStorage instance for caching\n     * @param networkClient Network client for HTTP requests\n     * @param cryptoProvider Crypto provider for cryptographic operations\n     * @param disableInternalRetries Whether to disable internal retry logic\n     * @param identityEndpoint The Service Fabric managed identity endpoint\n     * @param identityHeader The Service Fabric managed identity secret header\n     */\n    constructor(\n        logger: Logger,\n        nodeStorage: NodeStorage,\n        networkClient: INetworkModule,\n        cryptoProvider: CryptoProvider,\n        disableInternalRetries: boolean,\n        identityEndpoint: string,\n        identityHeader: string\n    ) {\n        super(\n            logger,\n            nodeStorage,\n            networkClient,\n            cryptoProvider,\n            disableInternalRetries\n        );\n\n        this.identityEndpoint = identityEndpoint;\n        this.identityHeader = identityHeader;\n    }\n\n    /**\n     * Retrieves the environment variables required for Service Fabric managed identity.\n     * @returns An array containing the identity endpoint, identity header, and identity server thumbprint.\n     */\n    public static getEnvironmentVariables(): Array<string | undefined> {\n        const identityEndpoint: string | undefined =\n            process.env[\n                ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT\n            ];\n        const identityHeader: string | undefined =\n            process.env[\n                ManagedIdentityEnvironmentVariableNames.IDENTITY_HEADER\n            ];\n        const identityServerThumbprint: string | undefined =\n            process.env[\n                ManagedIdentityEnvironmentVariableNames\n                    .IDENTITY_SERVER_THUMBPRINT\n            ];\n\n        return [identityEndpoint, identityHeader, identityServerThumbprint];\n    }\n\n    /**\n     * Attempts to create a ServiceFabric managed identity source if all required environment variables are present.\n     * @param logger Logger instance for logging\n     * @param nodeStorage NodeStorage instance for caching\n     * @param networkClient Network client for HTTP requests\n     * @param cryptoProvider Crypto provider for cryptographic operations\n     * @param disableInternalRetries Whether to disable internal retry logic\n     * @param managedIdentityId Managed identity identifier\n     * @returns A ServiceFabric instance if environment variables are set, otherwise null\n     */\n    public static tryCreate(\n        logger: Logger,\n        nodeStorage: NodeStorage,\n        networkClient: INetworkModule,\n        cryptoProvider: CryptoProvider,\n        disableInternalRetries: boolean,\n        managedIdentityId: ManagedIdentityId\n    ): ServiceFabric | null {\n        const [identityEndpoint, identityHeader, identityServerThumbprint] =\n            ServiceFabric.getEnvironmentVariables();\n\n        if (!identityEndpoint || !identityHeader || !identityServerThumbprint) {\n            logger.info(\n                `[Managed Identity] ${ManagedIdentitySourceNames.SERVICE_FABRIC} managed identity is unavailable because one or all of the '${ManagedIdentityEnvironmentVariableNames.IDENTITY_HEADER}', '${ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT}' or '${ManagedIdentityEnvironmentVariableNames.IDENTITY_SERVER_THUMBPRINT}' environment variables are not defined.`\n            );\n            return null;\n        }\n\n        const validatedIdentityEndpoint: string =\n            ServiceFabric.getValidatedEnvVariableUrlString(\n                ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT,\n                identityEndpoint,\n                ManagedIdentitySourceNames.SERVICE_FABRIC,\n                logger\n            );\n\n        logger.info(\n            `[Managed Identity] Environment variables validation passed for ${ManagedIdentitySourceNames.SERVICE_FABRIC} managed identity. Endpoint URI: ${validatedIdentityEndpoint}. Creating ${ManagedIdentitySourceNames.SERVICE_FABRIC} managed identity.`\n        );\n\n        if (\n            managedIdentityId.idType !== ManagedIdentityIdType.SYSTEM_ASSIGNED\n        ) {\n            logger.warning(\n                `[Managed Identity] ${ManagedIdentitySourceNames.SERVICE_FABRIC} user assigned managed identity is configured in the cluster, not during runtime. See also: https://learn.microsoft.com/en-us/azure/service-fabric/configure-existing-cluster-enable-managed-identity-token-service.`\n            );\n        }\n\n        return new ServiceFabric(\n            logger,\n            nodeStorage,\n            networkClient,\n            cryptoProvider,\n            disableInternalRetries,\n            identityEndpoint,\n            identityHeader\n        );\n    }\n\n    /**\n     * Creates the request parameters for acquiring a token from the Service Fabric cluster.\n     * @param resource - The resource URI for which the token is requested.\n     * @param managedIdentityId - The managed identity ID (system-assigned or user-assigned).\n     * @returns A ManagedIdentityRequestParameters object configured for Service Fabric.\n     */\n    public createRequest(\n        resource: string,\n        managedIdentityId: ManagedIdentityId\n    ): ManagedIdentityRequestParameters {\n        const request: ManagedIdentityRequestParameters =\n            new ManagedIdentityRequestParameters(\n                HttpMethod.GET,\n                this.identityEndpoint\n            );\n\n        request.headers[ManagedIdentityHeaders.ML_AND_SF_SECRET_HEADER_NAME] =\n            this.identityHeader;\n\n        request.queryParameters[ManagedIdentityQueryParameters.API_VERSION] =\n            SERVICE_FABRIC_MSI_API_VERSION;\n        request.queryParameters[ManagedIdentityQueryParameters.RESOURCE] =\n            resource;\n\n        if (\n            managedIdentityId.idType !== ManagedIdentityIdType.SYSTEM_ASSIGNED\n        ) {\n            request.queryParameters[\n                this.getManagedIdentityUserAssignedIdQueryParameterKey(\n                    managedIdentityId.idType\n                )\n            ] = managedIdentityId.id;\n        }\n\n        // bodyParameters calculated in BaseManagedIdentity.acquireTokenWithManagedIdentity\n\n        return request;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5012, "column": 0}, "map": {"version":3,"file":"MachineLearning.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/client/ManagedIdentitySources/MachineLearning.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { INetworkModule, Logger } from \"@azure/msal-common/node\";\nimport {\n    BaseManagedIdentitySource,\n    ManagedIdentityUserAssignedIdQueryParameterNames,\n} from \"./BaseManagedIdentitySource.js\";\nimport {\n    HttpMethod,\n    ManagedIdentityEnvironmentVariableNames,\n    ManagedIdentitySourceNames,\n    ManagedIdentityIdType,\n    ManagedIdentityQueryParameters,\n    ManagedIdentityHeaders,\n} from \"../../utils/Constants.js\";\nimport { CryptoProvider } from \"../../crypto/CryptoProvider.js\";\nimport { ManagedIdentityRequestParameters } from \"../../config/ManagedIdentityRequestParameters.js\";\nimport { ManagedIdentityId } from \"../../config/ManagedIdentityId.js\";\nimport { NodeStorage } from \"../../cache/NodeStorage.js\";\n\nconst MACHINE_LEARNING_MSI_API_VERSION: string = \"2017-09-01\";\n\nexport const MANAGED_IDENTITY_MACHINE_LEARNING_UNSUPPORTED_ID_TYPE_ERROR = `Only client id is supported for user-assigned managed identity in ${ManagedIdentitySourceNames.MACHINE_LEARNING}.`; // referenced in unit test\n\nexport class MachineLearning extends BaseManagedIdentitySource {\n    private msiEndpoint: string;\n    private secret: string;\n\n    constructor(\n        logger: Logger,\n        nodeStorage: NodeStorage,\n        networkClient: INetworkModule,\n        cryptoProvider: CryptoProvider,\n        disableInternalRetries: boolean,\n        msiEndpoint: string,\n        secret: string\n    ) {\n        super(\n            logger,\n            nodeStorage,\n            networkClient,\n            cryptoProvider,\n            disableInternalRetries\n        );\n\n        this.msiEndpoint = msiEndpoint;\n        this.secret = secret;\n    }\n\n    public static getEnvironmentVariables(): Array<string | undefined> {\n        const msiEndpoint: string | undefined =\n            process.env[ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT];\n\n        const secret: string | undefined =\n            process.env[ManagedIdentityEnvironmentVariableNames.MSI_SECRET];\n\n        return [msiEndpoint, secret];\n    }\n\n    public static tryCreate(\n        logger: Logger,\n        nodeStorage: NodeStorage,\n        networkClient: INetworkModule,\n        cryptoProvider: CryptoProvider,\n        disableInternalRetries: boolean\n    ): MachineLearning | null {\n        const [msiEndpoint, secret] = MachineLearning.getEnvironmentVariables();\n\n        // if either of the MSI endpoint or MSI secret variables are undefined, this MSI provider is unavailable.\n        if (!msiEndpoint || !secret) {\n            logger.info(\n                `[Managed Identity] ${ManagedIdentitySourceNames.MACHINE_LEARNING} managed identity is unavailable because one or both of the '${ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT}' and '${ManagedIdentityEnvironmentVariableNames.MSI_SECRET}' environment variables are not defined.`\n            );\n            return null;\n        }\n\n        const validatedMsiEndpoint: string =\n            MachineLearning.getValidatedEnvVariableUrlString(\n                ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT,\n                msiEndpoint,\n                ManagedIdentitySourceNames.MACHINE_LEARNING,\n                logger\n            );\n\n        logger.info(\n            `[Managed Identity] Environment variables validation passed for ${ManagedIdentitySourceNames.MACHINE_LEARNING} managed identity. Endpoint URI: ${validatedMsiEndpoint}. Creating ${ManagedIdentitySourceNames.MACHINE_LEARNING} managed identity.`\n        );\n\n        return new MachineLearning(\n            logger,\n            nodeStorage,\n            networkClient,\n            cryptoProvider,\n            disableInternalRetries,\n            msiEndpoint,\n            secret\n        );\n    }\n\n    public createRequest(\n        resource: string,\n        managedIdentityId: ManagedIdentityId\n    ): ManagedIdentityRequestParameters {\n        const request: ManagedIdentityRequestParameters =\n            new ManagedIdentityRequestParameters(\n                HttpMethod.GET,\n                this.msiEndpoint\n            );\n\n        request.headers[ManagedIdentityHeaders.METADATA_HEADER_NAME] = \"true\";\n        request.headers[ManagedIdentityHeaders.ML_AND_SF_SECRET_HEADER_NAME] =\n            this.secret;\n\n        request.queryParameters[ManagedIdentityQueryParameters.API_VERSION] =\n            MACHINE_LEARNING_MSI_API_VERSION;\n        request.queryParameters[ManagedIdentityQueryParameters.RESOURCE] =\n            resource;\n\n        if (\n            managedIdentityId.idType === ManagedIdentityIdType.SYSTEM_ASSIGNED\n        ) {\n            request.queryParameters[\n                ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_CLIENT_ID_2017\n            ] = process.env[\n                ManagedIdentityEnvironmentVariableNames\n                    .DEFAULT_IDENTITY_CLIENT_ID\n            ] as string; // this environment variable is always set in an Azure Machine Learning source\n        } else if (\n            managedIdentityId.idType ===\n            ManagedIdentityIdType.USER_ASSIGNED_CLIENT_ID\n        ) {\n            request.queryParameters[\n                this.getManagedIdentityUserAssignedIdQueryParameterKey(\n                    managedIdentityId.idType,\n                    false, // isIMDS\n                    true // uses2017API\n                )\n            ] = managedIdentityId.id;\n        } else {\n            throw new Error(\n                MANAGED_IDENTITY_MACHINE_LEARNING_UNSUPPORTED_ID_TYPE_ERROR\n            );\n        }\n\n        // bodyParameters calculated in BaseManagedIdentity.acquireTokenWithManagedIdentity\n\n        return request;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5079, "column": 0}, "map": {"version":3,"file":"ManagedIdentityClient.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/client/ManagedIdentityClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    Authority,\n    INetworkModule,\n    Logger,\n    AuthenticationResult,\n} from \"@azure/msal-common/node\";\nimport { AppService } from \"./ManagedIdentitySources/AppService.js\";\nimport { AzureArc } from \"./ManagedIdentitySources/AzureArc.js\";\nimport { CloudShell } from \"./ManagedIdentitySources/CloudShell.js\";\nimport { Imds } from \"./ManagedIdentitySources/Imds.js\";\nimport { ServiceFabric } from \"./ManagedIdentitySources/ServiceFabric.js\";\nimport { CryptoProvider } from \"../crypto/CryptoProvider.js\";\nimport {\n    ManagedIdentityErrorCodes,\n    createManagedIdentityError,\n} from \"../error/ManagedIdentityError.js\";\nimport { ManagedIdentityRequest } from \"../request/ManagedIdentityRequest.js\";\nimport { ManagedIdentityId } from \"../config/ManagedIdentityId.js\";\nimport { NodeStorage } from \"../cache/NodeStorage.js\";\nimport { BaseManagedIdentitySource } from \"./ManagedIdentitySources/BaseManagedIdentitySource.js\";\nimport { ManagedIdentitySourceNames } from \"../utils/Constants.js\";\nimport { MachineLearning } from \"./ManagedIdentitySources/MachineLearning.js\";\n\n/*\n * Class to initialize a managed identity and identify the service.\n * Original source of code: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/ManagedIdentityClient.cs\n */\nexport class ManagedIdentityClient {\n    private logger: Logger;\n    private nodeStorage: NodeStorage;\n    private networkClient: INetworkModule;\n    private cryptoProvider: CryptoProvider;\n    private disableInternalRetries: boolean;\n\n    private static identitySource?: BaseManagedIdentitySource;\n    public static sourceName?: ManagedIdentitySourceNames;\n\n    constructor(\n        logger: Logger,\n        nodeStorage: NodeStorage,\n        networkClient: INetworkModule,\n        cryptoProvider: CryptoProvider,\n        disableInternalRetries: boolean\n    ) {\n        this.logger = logger;\n        this.nodeStorage = nodeStorage;\n        this.networkClient = networkClient;\n        this.cryptoProvider = cryptoProvider;\n        this.disableInternalRetries = disableInternalRetries;\n    }\n\n    public async sendManagedIdentityTokenRequest(\n        managedIdentityRequest: ManagedIdentityRequest,\n        managedIdentityId: ManagedIdentityId,\n        fakeAuthority: Authority,\n        refreshAccessToken?: boolean\n    ): Promise<AuthenticationResult> {\n        if (!ManagedIdentityClient.identitySource) {\n            ManagedIdentityClient.identitySource =\n                this.selectManagedIdentitySource(\n                    this.logger,\n                    this.nodeStorage,\n                    this.networkClient,\n                    this.cryptoProvider,\n                    this.disableInternalRetries,\n                    managedIdentityId\n                );\n        }\n\n        return ManagedIdentityClient.identitySource.acquireTokenWithManagedIdentity(\n            managedIdentityRequest,\n            managedIdentityId,\n            fakeAuthority,\n            refreshAccessToken\n        );\n    }\n\n    private allEnvironmentVariablesAreDefined(\n        environmentVariables: Array<string | undefined>\n    ): boolean {\n        return Object.values(environmentVariables).every(\n            (environmentVariable) => {\n                return environmentVariable !== undefined;\n            }\n        );\n    }\n\n    /**\n     * Determine the Managed Identity Source based on available environment variables. This API is consumed by ManagedIdentityApplication's getManagedIdentitySource.\n     * @returns ManagedIdentitySourceNames - The Managed Identity source's name\n     */\n    public getManagedIdentitySource(): ManagedIdentitySourceNames {\n        ManagedIdentityClient.sourceName =\n            this.allEnvironmentVariablesAreDefined(\n                ServiceFabric.getEnvironmentVariables()\n            )\n                ? ManagedIdentitySourceNames.SERVICE_FABRIC\n                : this.allEnvironmentVariablesAreDefined(\n                      AppService.getEnvironmentVariables()\n                  )\n                ? ManagedIdentitySourceNames.APP_SERVICE\n                : this.allEnvironmentVariablesAreDefined(\n                      MachineLearning.getEnvironmentVariables()\n                  )\n                ? ManagedIdentitySourceNames.MACHINE_LEARNING\n                : this.allEnvironmentVariablesAreDefined(\n                      CloudShell.getEnvironmentVariables()\n                  )\n                ? ManagedIdentitySourceNames.CLOUD_SHELL\n                : this.allEnvironmentVariablesAreDefined(\n                      AzureArc.getEnvironmentVariables()\n                  )\n                ? ManagedIdentitySourceNames.AZURE_ARC\n                : ManagedIdentitySourceNames.DEFAULT_TO_IMDS;\n\n        return ManagedIdentityClient.sourceName;\n    }\n\n    /**\n     * Tries to create a managed identity source for all sources\n     * @returns the managed identity Source\n     */\n    private selectManagedIdentitySource(\n        logger: Logger,\n        nodeStorage: NodeStorage,\n        networkClient: INetworkModule,\n        cryptoProvider: CryptoProvider,\n        disableInternalRetries: boolean,\n        managedIdentityId: ManagedIdentityId\n    ): BaseManagedIdentitySource {\n        const source =\n            ServiceFabric.tryCreate(\n                logger,\n                nodeStorage,\n                networkClient,\n                cryptoProvider,\n                disableInternalRetries,\n                managedIdentityId\n            ) ||\n            AppService.tryCreate(\n                logger,\n                nodeStorage,\n                networkClient,\n                cryptoProvider,\n                disableInternalRetries\n            ) ||\n            MachineLearning.tryCreate(\n                logger,\n                nodeStorage,\n                networkClient,\n                cryptoProvider,\n                disableInternalRetries\n            ) ||\n            CloudShell.tryCreate(\n                logger,\n                nodeStorage,\n                networkClient,\n                cryptoProvider,\n                disableInternalRetries,\n                managedIdentityId\n            ) ||\n            AzureArc.tryCreate(\n                logger,\n                nodeStorage,\n                networkClient,\n                cryptoProvider,\n                disableInternalRetries,\n                managedIdentityId\n            ) ||\n            Imds.tryCreate(\n                logger,\n                nodeStorage,\n                networkClient,\n                cryptoProvider,\n                disableInternalRetries\n            );\n        if (!source) {\n            throw createManagedIdentityError(\n                ManagedIdentityErrorCodes.unableToCreateSource\n            );\n        }\n        return source;\n    }\n}\n"],"names":["ManagedIdentityErrorCodes.unableToCreateSource"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5152, "column": 0}, "map": {"version":3,"file":"ManagedIdentityApplication.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/client/ManagedIdentityApplication.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AuthOptions,\n    Authority,\n    AuthorityOptions,\n    CacheOutcome,\n    ClientConfiguration,\n    Constants,\n    DEFAULT_CRYPTO_IMPLEMENTATION,\n    INetworkModule,\n    Logger,\n    ProtocolMode,\n    StaticAuthorityOptions,\n    AuthenticationResult,\n    createClientConfigurationError,\n    ClientConfigurationErrorCodes,\n    EncodingTypes,\n} from \"@azure/msal-common/node\";\nimport {\n    ManagedIdentityConfiguration,\n    ManagedIdentityNodeConfiguration,\n    buildManagedIdentityConfiguration,\n} from \"../config/Configuration.js\";\nimport { version, name } from \"../packageMetadata.js\";\nimport { ManagedIdentityRequest } from \"../request/ManagedIdentityRequest.js\";\nimport { CryptoProvider } from \"../crypto/CryptoProvider.js\";\nimport { ClientCredentialClient } from \"./ClientCredentialClient.js\";\nimport { ManagedIdentityClient } from \"./ManagedIdentityClient.js\";\nimport { ManagedIdentityRequestParams } from \"../request/ManagedIdentityRequestParams.js\";\nimport { NodeStorage } from \"../cache/NodeStorage.js\";\nimport {\n    DEFAULT_AUTHORITY_FOR_MANAGED_IDENTITY,\n    ManagedIdentitySourceNames,\n} from \"../utils/Constants.js\";\nimport { ManagedIdentityId } from \"../config/ManagedIdentityId.js\";\nimport { HashUtils } from \"../crypto/HashUtils.js\";\n\nconst SOURCES_THAT_SUPPORT_TOKEN_REVOCATION: Array<ManagedIdentitySourceNames> =\n    [ManagedIdentitySourceNames.SERVICE_FABRIC];\n\n/**\n * Class to initialize a managed identity and identify the service\n * @public\n */\nexport class ManagedIdentityApplication {\n    private config: ManagedIdentityNodeConfiguration;\n\n    private logger: Logger;\n    private static nodeStorage?: NodeStorage;\n    private networkClient: INetworkModule;\n    private cryptoProvider: CryptoProvider;\n\n    // authority needs to be faked to re-use existing functionality in msal-common: caching in responseHandler, etc.\n    private fakeAuthority: Authority;\n\n    // the ClientCredentialClient class needs to be faked to call it's getCachedAuthenticationResult method\n    private fakeClientCredentialClient: ClientCredentialClient;\n\n    private managedIdentityClient: ManagedIdentityClient;\n\n    private hashUtils: HashUtils;\n\n    constructor(configuration?: ManagedIdentityConfiguration) {\n        // undefined config means the managed identity is system-assigned\n        this.config = buildManagedIdentityConfiguration(configuration || {});\n\n        this.logger = new Logger(\n            this.config.system.loggerOptions,\n            name,\n            version\n        );\n\n        const fakeStatusAuthorityOptions: StaticAuthorityOptions = {\n            canonicalAuthority: Constants.DEFAULT_AUTHORITY,\n        };\n\n        if (!ManagedIdentityApplication.nodeStorage) {\n            ManagedIdentityApplication.nodeStorage = new NodeStorage(\n                this.logger,\n                this.config.managedIdentityId.id,\n                DEFAULT_CRYPTO_IMPLEMENTATION,\n                fakeStatusAuthorityOptions\n            );\n        }\n\n        this.networkClient = this.config.system.networkClient;\n\n        this.cryptoProvider = new CryptoProvider();\n\n        const fakeAuthorityOptions: AuthorityOptions = {\n            protocolMode: ProtocolMode.AAD,\n            knownAuthorities: [DEFAULT_AUTHORITY_FOR_MANAGED_IDENTITY],\n            cloudDiscoveryMetadata: \"\",\n            authorityMetadata: \"\",\n        };\n        this.fakeAuthority = new Authority(\n            DEFAULT_AUTHORITY_FOR_MANAGED_IDENTITY,\n            this.networkClient,\n            ManagedIdentityApplication.nodeStorage as NodeStorage,\n            fakeAuthorityOptions,\n            this.logger,\n            this.cryptoProvider.createNewGuid(), // correlationID\n            undefined,\n            true\n        );\n\n        this.fakeClientCredentialClient = new ClientCredentialClient({\n            authOptions: {\n                clientId: this.config.managedIdentityId.id,\n                authority: this.fakeAuthority,\n            } as AuthOptions,\n        } as ClientConfiguration);\n\n        this.managedIdentityClient = new ManagedIdentityClient(\n            this.logger,\n            ManagedIdentityApplication.nodeStorage as NodeStorage,\n            this.networkClient,\n            this.cryptoProvider,\n            this.config.disableInternalRetries\n        );\n\n        this.hashUtils = new HashUtils();\n    }\n\n    /**\n     * Acquire an access token from the cache or the managed identity\n     * @param managedIdentityRequest - the ManagedIdentityRequestParams object passed in by the developer\n     * @returns the access token\n     */\n    public async acquireToken(\n        managedIdentityRequestParams: ManagedIdentityRequestParams\n    ): Promise<AuthenticationResult> {\n        if (!managedIdentityRequestParams.resource) {\n            throw createClientConfigurationError(\n                ClientConfigurationErrorCodes.urlEmptyError\n            );\n        }\n\n        const managedIdentityRequest: ManagedIdentityRequest = {\n            forceRefresh: managedIdentityRequestParams.forceRefresh,\n            resource: managedIdentityRequestParams.resource.replace(\n                \"/.default\",\n                \"\"\n            ),\n            scopes: [\n                managedIdentityRequestParams.resource.replace(\"/.default\", \"\"),\n            ],\n            authority: this.fakeAuthority.canonicalAuthority,\n            correlationId: this.cryptoProvider.createNewGuid(),\n            claims: managedIdentityRequestParams.claims,\n            clientCapabilities: this.config.clientCapabilities,\n        };\n\n        if (managedIdentityRequest.forceRefresh) {\n            return this.acquireTokenFromManagedIdentity(\n                managedIdentityRequest,\n                this.config.managedIdentityId,\n                this.fakeAuthority\n            );\n        }\n\n        const [cachedAuthenticationResult, lastCacheOutcome] =\n            await this.fakeClientCredentialClient.getCachedAuthenticationResult(\n                managedIdentityRequest,\n                this.config,\n                this.cryptoProvider,\n                this.fakeAuthority,\n                ManagedIdentityApplication.nodeStorage as NodeStorage\n            );\n\n        /*\n         * Check if claims are present in the managed identity request.\n         * If so, the cached token will not be used.\n         */\n        if (managedIdentityRequest.claims) {\n            const sourceName: ManagedIdentitySourceNames =\n                this.managedIdentityClient.getManagedIdentitySource();\n\n            /*\n             * Check if there is a cached token and if the Managed Identity source supports token revocation.\n             * If so, hash the cached access token and add it to the request.\n             */\n            if (\n                cachedAuthenticationResult &&\n                SOURCES_THAT_SUPPORT_TOKEN_REVOCATION.includes(sourceName)\n            ) {\n                const revokedTokenSha256Hash: string = this.hashUtils\n                    .sha256(cachedAuthenticationResult.accessToken)\n                    .toString(EncodingTypes.HEX);\n                managedIdentityRequest.revokedTokenSha256Hash =\n                    revokedTokenSha256Hash;\n            }\n\n            return this.acquireTokenFromManagedIdentity(\n                managedIdentityRequest,\n                this.config.managedIdentityId,\n                this.fakeAuthority\n            );\n        }\n\n        if (cachedAuthenticationResult) {\n            // if the token is not expired but must be refreshed; get a new one in the background\n            if (lastCacheOutcome === CacheOutcome.PROACTIVELY_REFRESHED) {\n                this.logger.info(\n                    \"ClientCredentialClient:getCachedAuthenticationResult - Cached access token's refreshOn property has been exceeded'. It's not expired, but must be refreshed.\"\n                );\n\n                // force refresh; will run in the background\n                const refreshAccessToken = true;\n                await this.acquireTokenFromManagedIdentity(\n                    managedIdentityRequest,\n                    this.config.managedIdentityId,\n                    this.fakeAuthority,\n                    refreshAccessToken\n                );\n            }\n\n            return cachedAuthenticationResult;\n        } else {\n            return this.acquireTokenFromManagedIdentity(\n                managedIdentityRequest,\n                this.config.managedIdentityId,\n                this.fakeAuthority\n            );\n        }\n    }\n\n    /**\n     * Acquires a token from a managed identity endpoint.\n     *\n     * @param managedIdentityRequest - The request object containing parameters for the managed identity token request.\n     * @param managedIdentityId - The identifier for the managed identity (e.g., client ID or resource ID).\n     * @param fakeAuthority - A placeholder authority used for the token request.\n     * @param refreshAccessToken - Optional flag indicating whether to force a refresh of the access token.\n     * @returns A promise that resolves to an AuthenticationResult containing the acquired token and related information.\n     */\n    private async acquireTokenFromManagedIdentity(\n        managedIdentityRequest: ManagedIdentityRequest,\n        managedIdentityId: ManagedIdentityId,\n        fakeAuthority: Authority,\n        refreshAccessToken?: boolean\n    ): Promise<AuthenticationResult> {\n        // make a network call to the managed identity\n        return this.managedIdentityClient.sendManagedIdentityTokenRequest(\n            managedIdentityRequest,\n            managedIdentityId,\n            fakeAuthority,\n            refreshAccessToken\n        );\n    }\n\n    /**\n     * Determine the Managed Identity Source based on available environment variables. This API is consumed by Azure Identity SDK.\n     * @returns ManagedIdentitySourceNames - The Managed Identity source's name\n     */\n    public getManagedIdentitySource(): ManagedIdentitySourceNames {\n        return (\n            ManagedIdentityClient.sourceName ||\n            this.managedIdentityClient.getManagedIdentitySource()\n        );\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5297, "column": 0}, "map": {"version":3,"file":"DistributedCachePlugin.mjs","sources":["file:///home/user/studio/node_modules/%40azure/msal-node/src/cache/distributed/DistributedCachePlugin.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AccountEntity,\n    ICachePlugin,\n    TokenCacheContext,\n} from \"@azure/msal-common/node\";\nimport { TokenCache } from \"../TokenCache.js\";\nimport { IPartitionManager } from \"./IPartitionManager.js\";\nimport { ICacheClient } from \"./ICacheClient.js\";\n\n/**\n * Cache plugin that serializes data to the cache and deserializes data from the cache\n * @public\n */\nexport class DistributedCachePlugin implements ICachePlugin {\n    private client: ICacheClient;\n    private partitionManager: IPartitionManager;\n\n    constructor(client: ICacheClient, partitionManager: IPartitionManager) {\n        this.client = client;\n        this.partitionManager = partitionManager;\n    }\n\n    /**\n     * Deserializes the cache before accessing it\n     * @param cacheContext - TokenCacheContext\n     */\n    public async beforeCacheAccess(\n        cacheContext: TokenCacheContext\n    ): Promise<void> {\n        const partitionKey = await this.partitionManager.getKey();\n        const cacheData = await this.client.get(partitionKey);\n        cacheContext.tokenCache.deserialize(cacheData);\n    }\n\n    /**\n     * Serializes the cache after accessing it\n     * @param cacheContext - TokenCacheContext\n     */\n    public async afterCacheAccess(\n        cacheContext: TokenCacheContext\n    ): Promise<void> {\n        if (cacheContext.cacheHasChanged) {\n            const kvStore = (\n                cacheContext.tokenCache as TokenCache\n            ).getKVStore();\n            const accountEntities = Object.values(kvStore).filter((value) =>\n                AccountEntity.isAccountEntity(value as object)\n            );\n\n            let partitionKey: string;\n            if (accountEntities.length > 0) {\n                const accountEntity = accountEntities[0] as AccountEntity;\n                partitionKey = await this.partitionManager.extractKey(\n                    accountEntity\n                );\n            } else {\n                partitionKey = await this.partitionManager.getKey();\n            }\n\n            await this.client.set(\n                partitionKey,\n                cacheContext.tokenCache.serialize()\n            );\n        }\n    }\n}\n"],"names":[],"mappings":";;;;;;AAAA;;;CAGG,GAWH;;;CAGG,SACU,sBAAsB,CAAA;IAI/B,WAAY,CAAA,MAAoB,EAAE,gBAAmC,CAAA;QACjE,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;KAC5C;IAED;;;KAGG,GACI,MAAM,iBAAiB,CAC1B,YAA+B,EAAA;QAE/B,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,MAAM,EAAE,CAAC;QAC1D,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;QACtD,YAAY,CAAC,UAAU,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC;KAClD;IAED;;;KAGG,GACI,MAAM,gBAAgB,CACzB,YAA+B,EAAA;QAE/B,IAAI,YAAY,CAAC,eAAe,EAAE;YAC9B,MAAM,OAAO,GACT,YAAY,CAAC,UAChB,CAAC,UAAU,EAAE,CAAC;YACf,MAAM,eAAe,GAAG,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC,KAAK,4LACxD,gBAAa,CAAC,eAAe,CAAC,KAAe,CAAC,CACjD,CAAC;YAEF,IAAI,YAAoB,CAAC;YACzB,IAAI,eAAe,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC5B,MAAM,aAAa,GAAG,eAAe,CAAC,CAAC,CAAkB,CAAC;gBAC1D,YAAY,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,UAAU,CACjD,aAAa,CAChB,CAAC;YACL,CAAA,MAAM;gBACH,YAAY,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,MAAM,EAAE,CAAC;YACvD,CAAA;YAED,MAAM,IAAI,CAAC,MAAM,CAAC,GAAG,CACjB,YAAY,EACZ,YAAY,CAAC,UAAU,CAAC,SAAS,EAAE,CACtC,CAAC;QACL,CAAA;KACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5348, "column": 0}, "map": {"version":3,"file":"index.mjs","sources":[],"names":[],"mappings":"","debugId":null}}]
}